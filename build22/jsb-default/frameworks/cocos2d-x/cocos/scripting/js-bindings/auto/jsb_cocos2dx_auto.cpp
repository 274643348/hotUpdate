#include "scripting/js-bindings/auto/jsb_cocos2dx_auto.hpp"
#include "scripting/js-bindings/manual/jsb_conversions.hpp"
#include "scripting/js-bindings/manual/jsb_global.h"
#include "cocos2d.h"
#include "scripting/js-bindings/manual/BaseJSAction.h"

se::Object* __jsb_cocos2d_Acceleration_proto = nullptr;
se::Class* __jsb_cocos2d_Acceleration_class = nullptr;

static bool js_cocos2dx_Acceleration_get_x(se::State& s)
{
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_get_x : Invalid Native Object");

    CC_UNUSED bool ok = true;
    se::Value jsret;
    ok &= double_to_seval(cobj->x, &jsret);
    s.rval() = jsret;
    return true;
}
SE_BIND_PROP_GET(js_cocos2dx_Acceleration_get_x)

static bool js_cocos2dx_Acceleration_set_x(se::State& s)
{
    const auto& args = s.args();
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_set_x : Invalid Native Object");

    CC_UNUSED bool ok = true;
    double arg0 = 0;
    ok &= seval_to_double(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_Acceleration_set_x : Error processing new value");
    cobj->x = arg0;
    return true;
}
SE_BIND_PROP_SET(js_cocos2dx_Acceleration_set_x)

static bool js_cocos2dx_Acceleration_get_y(se::State& s)
{
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_get_y : Invalid Native Object");

    CC_UNUSED bool ok = true;
    se::Value jsret;
    ok &= double_to_seval(cobj->y, &jsret);
    s.rval() = jsret;
    return true;
}
SE_BIND_PROP_GET(js_cocos2dx_Acceleration_get_y)

static bool js_cocos2dx_Acceleration_set_y(se::State& s)
{
    const auto& args = s.args();
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_set_y : Invalid Native Object");

    CC_UNUSED bool ok = true;
    double arg0 = 0;
    ok &= seval_to_double(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_Acceleration_set_y : Error processing new value");
    cobj->y = arg0;
    return true;
}
SE_BIND_PROP_SET(js_cocos2dx_Acceleration_set_y)

static bool js_cocos2dx_Acceleration_get_z(se::State& s)
{
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_get_z : Invalid Native Object");

    CC_UNUSED bool ok = true;
    se::Value jsret;
    ok &= double_to_seval(cobj->z, &jsret);
    s.rval() = jsret;
    return true;
}
SE_BIND_PROP_GET(js_cocos2dx_Acceleration_get_z)

static bool js_cocos2dx_Acceleration_set_z(se::State& s)
{
    const auto& args = s.args();
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_set_z : Invalid Native Object");

    CC_UNUSED bool ok = true;
    double arg0 = 0;
    ok &= seval_to_double(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_Acceleration_set_z : Error processing new value");
    cobj->z = arg0;
    return true;
}
SE_BIND_PROP_SET(js_cocos2dx_Acceleration_set_z)

static bool js_cocos2dx_Acceleration_get_timestamp(se::State& s)
{
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_get_timestamp : Invalid Native Object");

    CC_UNUSED bool ok = true;
    se::Value jsret;
    ok &= double_to_seval(cobj->timestamp, &jsret);
    s.rval() = jsret;
    return true;
}
SE_BIND_PROP_GET(js_cocos2dx_Acceleration_get_timestamp)

static bool js_cocos2dx_Acceleration_set_timestamp(se::State& s)
{
    const auto& args = s.args();
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Acceleration_set_timestamp : Invalid Native Object");

    CC_UNUSED bool ok = true;
    double arg0 = 0;
    ok &= seval_to_double(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_Acceleration_set_timestamp : Error processing new value");
    cobj->timestamp = arg0;
    return true;
}
SE_BIND_PROP_SET(js_cocos2dx_Acceleration_set_timestamp)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Acceleration_finalize)

static bool js_cocos2dx_Acceleration_constructor(se::State& s)
{
    cocos2d::Acceleration* cobj = new (std::nothrow) cocos2d::Acceleration();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Acceleration_constructor, __jsb_cocos2d_Acceleration_class, js_cocos2d_Acceleration_finalize)




static bool js_cocos2d_Acceleration_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Acceleration)", s.nativeThisObject());
    cocos2d::Acceleration* cobj = (cocos2d::Acceleration*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Acceleration_finalize)

bool js_register_cocos2dx_Acceleration(se::Object* obj)
{
    auto cls = se::Class::create("Acceleration", obj, nullptr, _SE(js_cocos2dx_Acceleration_constructor));

    cls->defineProperty("x", _SE(js_cocos2dx_Acceleration_get_x), _SE(js_cocos2dx_Acceleration_set_x));
    cls->defineProperty("y", _SE(js_cocos2dx_Acceleration_get_y), _SE(js_cocos2dx_Acceleration_set_y));
    cls->defineProperty("z", _SE(js_cocos2dx_Acceleration_get_z), _SE(js_cocos2dx_Acceleration_set_z));
    cls->defineProperty("timestamp", _SE(js_cocos2dx_Acceleration_get_timestamp), _SE(js_cocos2dx_Acceleration_set_timestamp));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Acceleration_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Acceleration>(cls);

    __jsb_cocos2d_Acceleration_proto = cls->getProto();
    __jsb_cocos2d_Acceleration_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Texture2D_proto = nullptr;
se::Class* __jsb_cocos2d_Texture2D_class = nullptr;

static bool js_cocos2dx_Texture2D_getGLProgram(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getGLProgram)

static bool js_cocos2dx_Texture2D_getMaxT(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getMaxT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxT();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getMaxT : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getMaxT)

static bool js_cocos2dx_Texture2D_setAlphaTexture(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAlphaTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setAlphaTexture : Error processing arguments");
        cobj->setAlphaTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAlphaTexture)

static bool js_cocos2dx_Texture2D_initWithImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Texture2D_initWithImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg1;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithImage(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithImage : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithImage(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithImage : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_initWithImage)

static bool js_cocos2dx_Texture2D_setGLProgram(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setGLProgram)

static bool js_cocos2dx_Texture2D_getMaxS(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getMaxS : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxS();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getMaxS : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getMaxS)

static bool js_cocos2dx_Texture2D_hasPremultipliedAlpha(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_hasPremultipliedAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasPremultipliedAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_hasPremultipliedAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_hasPremultipliedAlpha)

static bool js_cocos2dx_Texture2D_getPixelsHigh(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelsHigh : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getPixelsHigh();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelsHigh : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelsHigh)

static bool js_cocos2dx_Texture2D_getAlphaTextureName(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getAlphaTextureName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getAlphaTextureName();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getAlphaTextureName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getAlphaTextureName)

static bool js_cocos2dx_Texture2D_getName(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getName();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getName)

static bool js_cocos2dx_Texture2D_initWithString(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Texture2D_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::FontDefinition arg1;
            ok &= seval_to_FontDefinition(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int8(args[5], (int8_t*)&arg5);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 7) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int8(args[5], (int8_t*)&arg5);
            if (!ok) { ok = true; break; }
            bool arg6;
            ok &= seval_to_boolean(args[6], &arg6);
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 8) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int8(args[5], (int8_t*)&arg5);
            if (!ok) { ok = true; break; }
            bool arg6;
            ok &= seval_to_boolean(args[6], &arg6);
            int arg7 = 0;
            ok &= seval_to_int32(args[7], (int32_t*)&arg7);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_initWithString : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_initWithString)

static bool js_cocos2dx_Texture2D_setMaxT(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setMaxT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setMaxT : Error processing arguments");
        cobj->setMaxT(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setMaxT)

static bool js_cocos2dx_Texture2D_getPath(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getPath();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPath)

static bool js_cocos2dx_Texture2D_drawInRect(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_drawInRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_drawInRect : Error processing arguments");
        cobj->drawInRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_drawInRect)

static bool js_cocos2dx_Texture2D_getContentSize(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getContentSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getContentSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getContentSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getContentSize)

static bool js_cocos2dx_Texture2D_setAliasTexParameters(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAliasTexParameters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setAliasTexParameters();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAliasTexParameters)

static bool js_cocos2dx_Texture2D_setAntiAliasTexParameters(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setAntiAliasTexParameters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setAntiAliasTexParameters();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setAntiAliasTexParameters)

static bool js_cocos2dx_Texture2D_generateMipmap(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_generateMipmap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->generateMipmap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_generateMipmap)

static bool js_cocos2dx_Texture2D_getDescription(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getDescription)

static bool js_cocos2dx_Texture2D_getPixelFormat(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getPixelFormat();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelFormat)

static bool js_cocos2dx_Texture2D_getContentSizeInPixels(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getContentSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getContentSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getContentSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getContentSizeInPixels)

static bool js_cocos2dx_Texture2D_releaseGLTexture(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_releaseGLTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseGLTexture();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_releaseGLTexture)

static bool js_cocos2dx_Texture2D_getPixelsWide(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_getPixelsWide : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getPixelsWide();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getPixelsWide : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getPixelsWide)

static bool js_cocos2dx_Texture2D_drawAtPoint(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_drawAtPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_drawAtPoint : Error processing arguments");
        cobj->drawAtPoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_drawAtPoint)

static bool js_cocos2dx_Texture2D_hasMipmaps(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_hasMipmaps : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasMipmaps();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_hasMipmaps : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_hasMipmaps)

static bool js_cocos2dx_Texture2D_setMaxS(se::State& s)
{
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Texture2D_setMaxS : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setMaxS : Error processing arguments");
        cobj->setMaxS(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setMaxS)

static bool js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D::PixelFormat arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat : Error processing arguments");
        cocos2d::Texture2D::setDefaultAlphaPixelFormat(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat)

static bool js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cocos2d::Texture2D::getDefaultAlphaPixelFormat();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Texture2D_finalize)

static bool js_cocos2dx_Texture2D_constructor(se::State& s)
{
    cocos2d::Texture2D* cobj = new (std::nothrow) cocos2d::Texture2D();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Texture2D_constructor, __jsb_cocos2d_Texture2D_class, js_cocos2d_Texture2D_finalize)




static bool js_cocos2d_Texture2D_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Texture2D)", s.nativeThisObject());
    cocos2d::Texture2D* cobj = (cocos2d::Texture2D*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Texture2D_finalize)

bool js_register_cocos2dx_Texture2D(se::Object* obj)
{
    auto cls = se::Class::create("Texture2D", obj, nullptr, _SE(js_cocos2dx_Texture2D_constructor));

    cls->defineFunction("getShaderProgram", _SE(js_cocos2dx_Texture2D_getGLProgram));
    cls->defineFunction("getMaxT", _SE(js_cocos2dx_Texture2D_getMaxT));
    cls->defineFunction("setAlphaTexture", _SE(js_cocos2dx_Texture2D_setAlphaTexture));
    cls->defineFunction("initWithImage", _SE(js_cocos2dx_Texture2D_initWithImage));
    cls->defineFunction("setShaderProgram", _SE(js_cocos2dx_Texture2D_setGLProgram));
    cls->defineFunction("getMaxS", _SE(js_cocos2dx_Texture2D_getMaxS));
    cls->defineFunction("hasPremultipliedAlpha", _SE(js_cocos2dx_Texture2D_hasPremultipliedAlpha));
    cls->defineFunction("getPixelsHigh", _SE(js_cocos2dx_Texture2D_getPixelsHigh));
    cls->defineFunction("getAlphaTextureName", _SE(js_cocos2dx_Texture2D_getAlphaTextureName));
    cls->defineFunction("getName", _SE(js_cocos2dx_Texture2D_getName));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_Texture2D_initWithString));
    cls->defineFunction("setMaxT", _SE(js_cocos2dx_Texture2D_setMaxT));
    cls->defineFunction("getPath", _SE(js_cocos2dx_Texture2D_getPath));
    cls->defineFunction("drawInRect", _SE(js_cocos2dx_Texture2D_drawInRect));
    cls->defineFunction("getContentSize", _SE(js_cocos2dx_Texture2D_getContentSize));
    cls->defineFunction("setAliasTexParameters", _SE(js_cocos2dx_Texture2D_setAliasTexParameters));
    cls->defineFunction("setAntiAliasTexParameters", _SE(js_cocos2dx_Texture2D_setAntiAliasTexParameters));
    cls->defineFunction("generateMipmap", _SE(js_cocos2dx_Texture2D_generateMipmap));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_Texture2D_getDescription));
    cls->defineFunction("getPixelFormat", _SE(js_cocos2dx_Texture2D_getPixelFormat));
    cls->defineFunction("getContentSizeInPixels", _SE(js_cocos2dx_Texture2D_getContentSizeInPixels));
    cls->defineFunction("releaseTexture", _SE(js_cocos2dx_Texture2D_releaseGLTexture));
    cls->defineFunction("getPixelsWide", _SE(js_cocos2dx_Texture2D_getPixelsWide));
    cls->defineFunction("drawAtPoint", _SE(js_cocos2dx_Texture2D_drawAtPoint));
    cls->defineFunction("hasMipmaps", _SE(js_cocos2dx_Texture2D_hasMipmaps));
    cls->defineFunction("setMaxS", _SE(js_cocos2dx_Texture2D_setMaxS));
    cls->defineStaticFunction("setDefaultAlphaPixelFormat", _SE(js_cocos2dx_Texture2D_setDefaultAlphaPixelFormat));
    cls->defineStaticFunction("getDefaultAlphaPixelFormat", _SE(js_cocos2dx_Texture2D_getDefaultAlphaPixelFormat));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Texture2D_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Texture2D>(cls);

    __jsb_cocos2d_Texture2D_proto = cls->getProto();
    __jsb_cocos2d_Texture2D_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Touch_proto = nullptr;
se::Class* __jsb_cocos2d_Touch_class = nullptr;

static bool js_cocos2dx_Touch_getPreviousLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getPreviousLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getPreviousLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getPreviousLocationInView)

static bool js_cocos2dx_Touch_getLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getLocation)

static bool js_cocos2dx_Touch_getDelta(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getDelta : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getDelta();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getDelta : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getDelta)

static bool js_cocos2dx_Touch_getStartLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getStartLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getStartLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getStartLocationInView)

static bool js_cocos2dx_Touch_getCurrentForce(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getCurrentForce : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCurrentForce();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getCurrentForce : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getCurrentForce)

static bool js_cocos2dx_Touch_getStartLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getStartLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getStartLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getStartLocation)

static bool js_cocos2dx_Touch_getID(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getID();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getID)

static bool js_cocos2dx_Touch_setTouchInfo(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Touch_setTouchInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->setTouchInfo(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setTouchInfo(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_setTouchInfo)

static bool js_cocos2dx_Touch_getMaxForce(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getMaxForce : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxForce();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getMaxForce : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getMaxForce)

static bool js_cocos2dx_Touch_getLocationInView(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getLocationInView)

static bool js_cocos2dx_Touch_getPreviousLocation(se::State& s)
{
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Touch_getPreviousLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Touch_getPreviousLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Touch_getPreviousLocation)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Touch_finalize)

static bool js_cocos2dx_Touch_constructor(se::State& s)
{
    cocos2d::Touch* cobj = new (std::nothrow) cocos2d::Touch();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Touch_constructor, __jsb_cocos2d_Touch_class, js_cocos2d_Touch_finalize)




static bool js_cocos2d_Touch_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Touch)", s.nativeThisObject());
    cocos2d::Touch* cobj = (cocos2d::Touch*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Touch_finalize)

bool js_register_cocos2dx_Touch(se::Object* obj)
{
    auto cls = se::Class::create("Touch", obj, nullptr, _SE(js_cocos2dx_Touch_constructor));

    cls->defineFunction("getPreviousLocationInView", _SE(js_cocos2dx_Touch_getPreviousLocationInView));
    cls->defineFunction("getLocation", _SE(js_cocos2dx_Touch_getLocation));
    cls->defineFunction("getDelta", _SE(js_cocos2dx_Touch_getDelta));
    cls->defineFunction("getStartLocationInView", _SE(js_cocos2dx_Touch_getStartLocationInView));
    cls->defineFunction("getCurrentForce", _SE(js_cocos2dx_Touch_getCurrentForce));
    cls->defineFunction("getStartLocation", _SE(js_cocos2dx_Touch_getStartLocation));
    cls->defineFunction("getID", _SE(js_cocos2dx_Touch_getID));
    cls->defineFunction("setTouchInfo", _SE(js_cocos2dx_Touch_setTouchInfo));
    cls->defineFunction("getMaxForce", _SE(js_cocos2dx_Touch_getMaxForce));
    cls->defineFunction("getLocationInView", _SE(js_cocos2dx_Touch_getLocationInView));
    cls->defineFunction("getPreviousLocation", _SE(js_cocos2dx_Touch_getPreviousLocation));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Touch_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Touch>(cls);

    __jsb_cocos2d_Touch_proto = cls->getProto();
    __jsb_cocos2d_Touch_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Event_proto = nullptr;
se::Class* __jsb_cocos2d_Event_class = nullptr;

static bool js_cocos2dx_Event_reset(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Event_reset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reset();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_reset)

static bool js_cocos2dx_Event_getCurrentTarget(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Event_getCurrentTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getCurrentTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Event_getCurrentTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_getCurrentTarget)

static bool js_cocos2dx_Event_getType(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Event_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getType();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Event_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_getType)

static bool js_cocos2dx_Event_isStopped(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Event_isStopped : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStopped();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Event_isStopped : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_isStopped)

static bool js_cocos2dx_Event_stopPropagation(se::State& s)
{
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Event_stopPropagation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopPropagation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Event_stopPropagation)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Event_finalize)

static bool js_cocos2dx_Event_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::Event::Type arg0;
    ok &= seval_to_int32(args[0], (int32_t*)&arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_Event_constructor : Error processing arguments");
    cocos2d::Event* cobj = new (std::nothrow) cocos2d::Event(arg0);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Event_constructor, __jsb_cocos2d_Event_class, js_cocos2d_Event_finalize)




static bool js_cocos2d_Event_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Event)", s.nativeThisObject());
    cocos2d::Event* cobj = (cocos2d::Event*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Event_finalize)

bool js_register_cocos2dx_Event(se::Object* obj)
{
    auto cls = se::Class::create("Event", obj, nullptr, _SE(js_cocos2dx_Event_constructor));

    cls->defineFunction("reset", _SE(js_cocos2dx_Event_reset));
    cls->defineFunction("getCurrentTarget", _SE(js_cocos2dx_Event_getCurrentTarget));
    cls->defineFunction("getType", _SE(js_cocos2dx_Event_getType));
    cls->defineFunction("isStopped", _SE(js_cocos2dx_Event_isStopped));
    cls->defineFunction("stopPropagation", _SE(js_cocos2dx_Event_stopPropagation));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Event_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Event>(cls);

    __jsb_cocos2d_Event_proto = cls->getProto();
    __jsb_cocos2d_Event_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventTouch_proto = nullptr;
se::Class* __jsb_cocos2d_EventTouch_class = nullptr;

static bool js_cocos2dx_EventTouch_getEventCode(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_getEventCode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getEventCode();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_getEventCode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_getEventCode)

static bool js_cocos2dx_EventTouch_setTouches(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_setTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::vector<cocos2d::Touch *, std::allocator<cocos2d::Touch *> > arg0;
        ok &= seval_to_std_vector_Touch(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_setTouches : Error processing arguments");
        cobj->setTouches(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_setTouches)

static bool js_cocos2dx_EventTouch_setEventCode(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_setEventCode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventTouch::EventCode arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_setEventCode : Error processing arguments");
        cobj->setEventCode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_setEventCode)

static bool js_cocos2dx_EventTouch_getTouches(se::State& s)
{
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventTouch_getTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<cocos2d::Touch *, std::allocator<cocos2d::Touch *> >& result = cobj->getTouches();
        ok &= std_vector_Touch_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventTouch_getTouches : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventTouch_getTouches)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventTouch_finalize)

static bool js_cocos2dx_EventTouch_constructor(se::State& s)
{
    cocos2d::EventTouch* cobj = new (std::nothrow) cocos2d::EventTouch();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventTouch_constructor, __jsb_cocos2d_EventTouch_class, js_cocos2d_EventTouch_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

static bool js_cocos2d_EventTouch_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventTouch)", s.nativeThisObject());
    cocos2d::EventTouch* cobj = (cocos2d::EventTouch*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventTouch_finalize)

bool js_register_cocos2dx_EventTouch(se::Object* obj)
{
    auto cls = se::Class::create("EventTouch", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventTouch_constructor));

    cls->defineFunction("getEventCode", _SE(js_cocos2dx_EventTouch_getEventCode));
    cls->defineFunction("setTouches", _SE(js_cocos2dx_EventTouch_setTouches));
    cls->defineFunction("setEventCode", _SE(js_cocos2dx_EventTouch_setEventCode));
    cls->defineFunction("getTouches", _SE(js_cocos2dx_EventTouch_getTouches));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventTouch_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventTouch>(cls);

    __jsb_cocos2d_EventTouch_proto = cls->getProto();
    __jsb_cocos2d_EventTouch_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ComponentContainer_proto = nullptr;
se::Class* __jsb_cocos2d_ComponentContainer_class = nullptr;

static bool js_cocos2dx_ComponentContainer_visit(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_visit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_visit : Error processing arguments");
        cobj->visit(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_visit)

static bool js_cocos2dx_ComponentContainer_remove(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ComponentContainer_remove : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Component* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->remove(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_remove : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->remove(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_remove : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_remove)

static bool js_cocos2dx_ComponentContainer_removeAll(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_removeAll : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAll();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_removeAll)

static bool js_cocos2dx_ComponentContainer_add(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_add : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Component* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_add : Error processing arguments");
        bool result = cobj->add(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_add : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_add)

static bool js_cocos2dx_ComponentContainer_isEmpty(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_isEmpty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEmpty();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_isEmpty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_isEmpty)

static bool js_cocos2dx_ComponentContainer_get(se::State& s)
{
    cocos2d::ComponentContainer* cobj = (cocos2d::ComponentContainer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ComponentContainer_get : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_get : Error processing arguments");
        cocos2d::Component* result = cobj->get(arg0);
        ok &= native_ptr_to_seval<cocos2d::Component>((cocos2d::Component*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ComponentContainer_get : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ComponentContainer_get)




bool js_register_cocos2dx_ComponentContainer(se::Object* obj)
{
    auto cls = se::Class::create("ComponentContainer", obj, nullptr, nullptr);

    cls->defineFunction("visit", _SE(js_cocos2dx_ComponentContainer_visit));
    cls->defineFunction("remove", _SE(js_cocos2dx_ComponentContainer_remove));
    cls->defineFunction("removeAll", _SE(js_cocos2dx_ComponentContainer_removeAll));
    cls->defineFunction("add", _SE(js_cocos2dx_ComponentContainer_add));
    cls->defineFunction("isEmpty", _SE(js_cocos2dx_ComponentContainer_isEmpty));
    cls->defineFunction("getComponent", _SE(js_cocos2dx_ComponentContainer_get));
    cls->install();
    JSBClassType::registerClass<cocos2d::ComponentContainer>(cls);

    __jsb_cocos2d_ComponentContainer_proto = cls->getProto();
    __jsb_cocos2d_ComponentContainer_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Component_proto = nullptr;
se::Class* __jsb_cocos2d_Component_class = nullptr;

static bool js_cocos2dx_Component_setEnabled(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setEnabled)

static bool js_cocos2dx_Component_setName(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_setName : Error processing arguments");
        cobj->setName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setName)

static bool js_cocos2dx_Component_isEnabled(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_isEnabled)

static bool js_cocos2dx_Component_getOwner(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_getOwner : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getOwner();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_getOwner : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_getOwner)

static bool js_cocos2dx_Component_init(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_init)

static bool js_cocos2dx_Component_setOwner(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_setOwner : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_setOwner : Error processing arguments");
        cobj->setOwner(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_setOwner)

static bool js_cocos2dx_Component_getName(se::State& s)
{
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Component_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Component_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_getName)

static bool js_cocos2dx_Component_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Component::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Component_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Component_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Component_finalize)

static bool js_cocos2dx_Component_constructor(se::State& s)
{
    cocos2d::Component* cobj = new (std::nothrow) cocos2d::Component();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Component_constructor, __jsb_cocos2d_Component_class, js_cocos2d_Component_finalize)

static bool js_cocos2dx_Component_ctor(se::State& s)
{
    cocos2d::Component* cobj = new (std::nothrow) cocos2d::Component();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Component_ctor, __jsb_cocos2d_Component_class, js_cocos2d_Component_finalize)


    


static bool js_cocos2d_Component_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Component)", s.nativeThisObject());
    cocos2d::Component* cobj = (cocos2d::Component*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Component_finalize)

bool js_register_cocos2dx_Component(se::Object* obj)
{
    auto cls = se::Class::create("Component", obj, nullptr, _SE(js_cocos2dx_Component_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_Component_setEnabled));
    cls->defineFunction("setName", _SE(js_cocos2dx_Component_setName));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_Component_isEnabled));
    cls->defineFunction("getOwner", _SE(js_cocos2dx_Component_getOwner));
    cls->defineFunction("init", _SE(js_cocos2dx_Component_init));
    cls->defineFunction("setOwner", _SE(js_cocos2dx_Component_setOwner));
    cls->defineFunction("getName", _SE(js_cocos2dx_Component_getName));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Component_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Component_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Component_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Component>(cls);

    __jsb_cocos2d_Component_proto = cls->getProto();
    __jsb_cocos2d_Component_class = cls;

    jsb_set_extend_property("cc", "Component");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Node_proto = nullptr;
se::Class* __jsb_cocos2d_Node_class = nullptr;

static bool js_cocos2dx_Node_addChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_addChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_addChild)

static bool js_cocos2dx_Node_removeComponent(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Component* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeComponent(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeComponent : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->removeComponent(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeComponent : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeComponent)

static bool js_cocos2dx_Node_getGLProgram(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGLProgram)

static bool js_cocos2dx_Node_getDescription(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDescription)

static bool js_cocos2dx_Node_setOpacityModifyRGB(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOpacityModifyRGB : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOpacityModifyRGB : Error processing arguments");
        cobj->setOpacityModifyRGB(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOpacityModifyRGB)

static bool js_cocos2dx_Node_setCascadeOpacityEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCascadeOpacityEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCascadeOpacityEnabled : Error processing arguments");
        cobj->setCascadeOpacityEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCascadeOpacityEnabled)

static bool js_cocos2dx_Node_getChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::Node *>& result = cobj->getChildren();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildren : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Node *>& result = cobj->getChildren();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildren : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildren)

static bool js_cocos2dx_Node_pause(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_pause : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pause();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_pause)

static bool js_cocos2dx_Node_convertToWorldSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToWorldSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToWorldSpaceAR)

static bool js_cocos2dx_Node_isIgnoreAnchorPointForPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isIgnoreAnchorPointForPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isIgnoreAnchorPointForPosition();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isIgnoreAnchorPointForPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isIgnoreAnchorPointForPosition)

static bool js_cocos2dx_Node_getChildByName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByName : Error processing arguments");
        cocos2d::Node* result = cobj->getChildByName(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildByName)

static bool js_cocos2dx_Node_init(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_init)

static bool js_cocos2dx_Node_getBeforeVisitCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getBeforeVisitCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::function<void (cocos2d::Renderer *)>& result = cobj->getBeforeVisitCallback();
        #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getBeforeVisitCallback : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getBeforeVisitCallback)

static bool js_cocos2dx_Node_getCameraMask(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getCameraMask : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned short result = cobj->getCameraMask();
        ok &= int16_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getCameraMask : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getCameraMask)

static bool js_cocos2dx_Node_setRotation(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotation : Error processing arguments");
        cobj->setRotation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotation)

static bool js_cocos2dx_Node_setScaleZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleZ : Error processing arguments");
        cobj->setScaleZ(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleZ)

static bool js_cocos2dx_Node_setScaleY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleY : Error processing arguments");
        cobj->setScaleY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleY)

static bool js_cocos2dx_Node_setScaleX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScaleX : Error processing arguments");
        cobj->setScaleX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScaleX)

static bool js_cocos2dx_Node_getColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getColor();
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getColor)

static bool js_cocos2dx_Node_removeAllComponents(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeAllComponents : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllComponents();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeAllComponents)

static bool js_cocos2dx_Node__setLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node__setLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node__setLocalZOrder : Error processing arguments");
        cobj->_setLocalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node__setLocalZOrder)

static bool js_cocos2dx_Node_setCameraMask(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCameraMask : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned short arg0 = 0;
        ok &= seval_to_uint16(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCameraMask : Error processing arguments");
        cobj->setCameraMask(arg0);
        return true;
    }
    if (argc == 2) {
        unsigned short arg0 = 0;
        bool arg1;
        ok &= seval_to_uint16(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCameraMask : Error processing arguments");
        cobj->setCameraMask(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCameraMask)

static bool js_cocos2dx_Node_getTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTag();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getTag)

static bool js_cocos2dx_Node_setAfterVisitCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setAfterVisitCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Renderer *)> arg0;
        do {
            if (args[0].isObject() && args[0].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[0]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Renderer* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Renderer>((cocos2d::Renderer*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg0 = lambda;
            }
            else
            {
                arg0 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setAfterVisitCallback : Error processing arguments");
        cobj->setAfterVisitCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setAfterVisitCallback)

static bool js_cocos2dx_Node_getNodeToWorldAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNodeToWorldAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getNodeToWorldAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToWorldAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToWorldAffineTransform)

static bool js_cocos2dx_Node_removeChild(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChild : Error processing arguments");
        cobj->removeChild(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChild : Error processing arguments");
        cobj->removeChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChild)

static bool js_cocos2dx_Node_convertToWorldSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToWorldSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToWorldSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToWorldSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToWorldSpace)

static bool js_cocos2dx_Node_getScene(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scene* result = cobj->getScene();
        ok &= native_ptr_to_seval<cocos2d::Scene>((cocos2d::Scene*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScene)

static bool js_cocos2dx_Node_getEventDispatcher(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventDispatcher* result = cobj->getEventDispatcher();
        ok &= native_ptr_to_seval<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getEventDispatcher : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getEventDispatcher)

static bool js_cocos2dx_Node_setSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setSkewX : Error processing arguments");
        cobj->setSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setSkewX)

static bool js_cocos2dx_Node_setGLProgramState(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGLProgramState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgramState* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGLProgramState : Error processing arguments");
        cobj->setGLProgramState(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGLProgramState)

static bool js_cocos2dx_Node_stopActionsByFlags(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopActionsByFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopActionsByFlags : Error processing arguments");
        cobj->stopActionsByFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopActionsByFlags)

static bool js_cocos2dx_Node_setNormalizedPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setNormalizedPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setNormalizedPosition : Error processing arguments");
        cobj->setNormalizedPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setNormalizedPosition)

static bool js_cocos2dx_Node_convertTouchToNodeSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Touch* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertTouchToNodeSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertTouchToNodeSpace)

static bool js_cocos2dx_Node_removeAllChildrenWithCleanup(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            bool arg0;
            ok &= seval_to_boolean(args[0], &arg0);
            cobj->removeAllChildrenWithCleanup(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->removeAllChildren();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Node_getRotationSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotationSkewX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotationSkewX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotationSkewX)

static bool js_cocos2dx_Node_getRotationSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotationSkewY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotationSkewY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotationSkewY)

static bool js_cocos2dx_Node_getNodeToWorldTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNodeToWorldTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Mat4 result = cobj->getNodeToWorldTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToWorldTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToWorldTransform)

static bool js_cocos2dx_Node_isCascadeOpacityEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isCascadeOpacityEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCascadeOpacityEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isCascadeOpacityEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isCascadeOpacityEnabled)

static bool js_cocos2dx_Node_setParent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setParent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setParent : Error processing arguments");
        cobj->setParent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setParent)

static bool js_cocos2dx_Node_getName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getName)

static bool js_cocos2dx_Node_resume(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_resume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resume();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_resume)

static bool js_cocos2dx_Node_getNodeToParentAffineTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::AffineTransform result = cobj->getNodeToParentAffineTransform(arg0);
            ok &= AffineTransform_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::AffineTransform result = cobj->getNodeToParentAffineTransform();
            ok &= AffineTransform_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentAffineTransform : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToParentAffineTransform)

static bool js_cocos2dx_Node_getAfterVisitCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getAfterVisitCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::function<void (cocos2d::Renderer *)>& result = cobj->getAfterVisitCallback();
        #pragma warning NO CONVERSION FROM NATIVE FOR std::function;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getAfterVisitCallback : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getAfterVisitCallback)

static bool js_cocos2dx_Node_isOpacityModifyRGB(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isOpacityModifyRGB : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isOpacityModifyRGB();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isOpacityModifyRGB : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isOpacityModifyRGB)

static bool js_cocos2dx_Node_stopActionByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopActionByTag : Error processing arguments");
        cobj->stopActionByTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopActionByTag)

static bool js_cocos2dx_Node_reorderChild(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_reorderChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_reorderChild : Error processing arguments");
        cobj->reorderChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_reorderChild)

static bool js_cocos2dx_Node_setSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setSkewY : Error processing arguments");
        cobj->setSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setSkewY)

static bool js_cocos2dx_Node_setColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setColor : Error processing arguments");
        cobj->setColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setColor)

static bool js_cocos2dx_Node_setPositionY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionY : Error processing arguments");
        cobj->setPositionY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionY)

static bool js_cocos2dx_Node_setPositionX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionX : Error processing arguments");
        cobj->setPositionX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionX)

static bool js_cocos2dx_Node_setNodeToParentTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setNodeToParentTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setNodeToParentTransform : Error processing arguments");
        cobj->setNodeToParentTransform(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setNodeToParentTransform)

static bool js_cocos2dx_Node_getAnchorPoint(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPoint();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getAnchorPoint)

static bool js_cocos2dx_Node_getNumberOfRunningActions(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNumberOfRunningActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getNumberOfRunningActions();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNumberOfRunningActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNumberOfRunningActions)

static bool js_cocos2dx_Node_isVisible(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isVisible();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isVisible : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isVisible)

static bool js_cocos2dx_Node_getChildrenCount(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildrenCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getChildrenCount();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildrenCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildrenCount)

static bool js_cocos2dx_Node_getNodeToParentTransform(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getNodeToParentTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 result = cobj->getNodeToParentTransform(arg0);
            ok &= Mat4_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentTransform : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Mat4& result = cobj->getNodeToParentTransform();
            ok &= Mat4_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNodeToParentTransform : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNodeToParentTransform)

static bool js_cocos2dx_Node_convertToNodeSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToNodeSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToNodeSpaceAR)

static bool js_cocos2dx_Node_addComponent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_addComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Component* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_addComponent : Error processing arguments");
        bool result = cobj->addComponent(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_addComponent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_addComponent)

static bool js_cocos2dx_Node_visit(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_visit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->visit();
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], (uint32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->visit(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_visit)

static bool js_cocos2dx_Node_setGLProgram(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGLProgram)

static bool js_cocos2dx_Node_getRotation(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getRotation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotation();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getRotation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getRotation)

static bool js_cocos2dx_Node_getAnchorPointInPoints(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getAnchorPointInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPointInPoints();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getAnchorPointInPoints : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getAnchorPointInPoints)

static bool js_cocos2dx_Node_runAction(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_runAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_runAction : Error processing arguments");
        cocos2d::Action* result = cobj->runAction(arg0);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_runAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_runAction)

static bool js_cocos2dx_Node_removeChildByName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChildByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByName : Error processing arguments");
        cobj->removeChildByName(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByName : Error processing arguments");
        cobj->removeChildByName(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChildByName)

static bool js_cocos2dx_Node_setPositionZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setPositionZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setPositionZ : Error processing arguments");
        cobj->setPositionZ(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setPositionZ)

static bool js_cocos2dx_Node_getGLProgramState(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGLProgramState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgramState* result = cobj->getGLProgramState();
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGLProgramState : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGLProgramState)

static bool js_cocos2dx_Node_setScheduler(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scheduler* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setScheduler : Error processing arguments");
        cobj->setScheduler(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScheduler)

static bool js_cocos2dx_Node_stopAllActions(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAllActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopAllActions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAllActions)

static bool js_cocos2dx_Node_getSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSkewX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getSkewX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getSkewX)

static bool js_cocos2dx_Node_getSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSkewY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getSkewY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getSkewY)

static bool js_cocos2dx_Node_getDisplayedColor(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDisplayedColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getDisplayedColor();
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDisplayedColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDisplayedColor)

static bool js_cocos2dx_Node_getActionByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionByTag : Error processing arguments");
        cocos2d::Action* result = cobj->getActionByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getActionByTag)

static bool js_cocos2dx_Node_setRotationSkewX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotationSkewX : Error processing arguments");
        cobj->setRotationSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotationSkewX)

static bool js_cocos2dx_Node_setRotationSkewY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setRotationSkewY : Error processing arguments");
        cobj->setRotationSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setRotationSkewY)

static bool js_cocos2dx_Node_setName(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setName : Error processing arguments");
        cobj->setName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setName)

static bool js_cocos2dx_Node_getDisplayedOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getDisplayedOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getDisplayedOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getDisplayedOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getDisplayedOpacity)

static bool js_cocos2dx_Node_getLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLocalZOrder();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getLocalZOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getLocalZOrder)

static bool js_cocos2dx_Node_getScheduler(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Scheduler* result = cobj->getScheduler();
            ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScheduler : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Scheduler* result = cobj->getScheduler();
            ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScheduler : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScheduler)

static bool js_cocos2dx_Node_setBeforeVisitCallback(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setBeforeVisitCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Renderer *)> arg0;
        do {
            if (args[0].isObject() && args[0].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[0]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Renderer* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Renderer>((cocos2d::Renderer*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg0 = lambda;
            }
            else
            {
                arg0 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setBeforeVisitCallback : Error processing arguments");
        cobj->setBeforeVisitCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setBeforeVisitCallback)

static bool js_cocos2dx_Node_setActionManager(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionManager* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setActionManager : Error processing arguments");
        cobj->setActionManager(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setActionManager)

static bool js_cocos2dx_Node_getPosition(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float* arg0 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
            ok = false;
            if (!ok) { ok = true; break; }
            float* arg1 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
            ok = false;
            if (!ok) { ok = true; break; }
            cobj->getPosition(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vec2& result = cobj->getPosition();
            ok &= Vec2_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPosition : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPosition)

static bool js_cocos2dx_Node_insertChildBefore(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_insertChildBefore : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_insertChildBefore : Error processing arguments");
        cobj->insertChildBefore(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_insertChildBefore)

static bool js_cocos2dx_Node_isRunning(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isRunning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRunning();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isRunning : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isRunning)

static bool js_cocos2dx_Node_getParent(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getParent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Node* result = cobj->getParent();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParent : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Node* result = cobj->getParent();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParent : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParent)

static bool js_cocos2dx_Node_getWorldToNodeTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getWorldToNodeTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Mat4 result = cobj->getWorldToNodeTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getWorldToNodeTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getWorldToNodeTransform)

static bool js_cocos2dx_Node_getPositionY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionY)

static bool js_cocos2dx_Node_getPositionX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionX)

static bool js_cocos2dx_Node_removeChildByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_removeChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByTag : Error processing arguments");
        cobj->removeChildByTag(arg0);
        return true;
    }
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_removeChildByTag : Error processing arguments");
        cobj->removeChildByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeChildByTag)

static bool js_cocos2dx_Node_setVisible(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setVisible : Error processing arguments");
        cobj->setVisible(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setVisible)

static bool js_cocos2dx_Node_getParentToNodeAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getParentToNodeAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getParentToNodeAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParentToNodeAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParentToNodeAffineTransform)

static bool js_cocos2dx_Node_getPositionZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getPositionZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPositionZ();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getPositionZ : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getPositionZ)

static bool js_cocos2dx_Node_setGlobalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setGlobalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setGlobalZOrder : Error processing arguments");
        cobj->setGlobalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setGlobalZOrder)

static bool js_cocos2dx_Node_setScale(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_setScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setScale(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setScale(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setScale)

static bool js_cocos2dx_Node_getChildByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByTag : Error processing arguments");
        cocos2d::Node* result = cobj->getChildByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getChildByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getChildByTag)

static bool js_cocos2dx_Node_getScaleZ(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleZ : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleZ();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleZ : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleZ)

static bool js_cocos2dx_Node_getScaleY(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleY)

static bool js_cocos2dx_Node_getScaleX(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScaleX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScaleX)

static bool js_cocos2dx_Node_setLocalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setLocalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setLocalZOrder : Error processing arguments");
        cobj->setLocalZOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setLocalZOrder)

static bool js_cocos2dx_Node_setCascadeColorEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setCascadeColorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setCascadeColorEnabled : Error processing arguments");
        cobj->setCascadeColorEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setCascadeColorEnabled)

static bool js_cocos2dx_Node_setOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], (uint8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setOpacity : Error processing arguments");
        cobj->setOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setOpacity)

static bool js_cocos2dx_Node_getComponent(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getComponent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getComponent : Error processing arguments");
        cocos2d::Component* result = cobj->getComponent(arg0);
        ok &= native_ptr_to_seval<cocos2d::Component>((cocos2d::Component*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getComponent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getComponent)

static bool js_cocos2dx_Node_getContentSize(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getContentSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getContentSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getContentSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getContentSize)

static bool js_cocos2dx_Node_stopAllActionsByTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAllActionsByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopAllActionsByTag : Error processing arguments");
        cobj->stopAllActionsByTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAllActionsByTag)

static bool js_cocos2dx_Node_getBoundingBox(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getBoundingBox : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getBoundingBox();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getBoundingBox : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getBoundingBox)

static bool js_cocos2dx_Node_setIgnoreAnchorPointForPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setIgnoreAnchorPointForPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setIgnoreAnchorPointForPosition : Error processing arguments");
        cobj->setIgnoreAnchorPointForPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setIgnoreAnchorPointForPosition)

static bool js_cocos2dx_Node_setEventDispatcher(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventDispatcher* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setEventDispatcher : Error processing arguments");
        cobj->setEventDispatcher(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setEventDispatcher)

static bool js_cocos2dx_Node_getGlobalZOrder(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getGlobalZOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getGlobalZOrder();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getGlobalZOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getGlobalZOrder)

static bool js_cocos2dx_Node_draw(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_draw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->draw();
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Renderer* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            unsigned int arg2 = 0;
            ok &= seval_to_uint32(args[2], (uint32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->draw(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_draw)

static bool js_cocos2dx_Node_setUserObject(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setUserObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Ref* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setUserObject : Error processing arguments");
        cobj->setUserObject(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setUserObject)

static bool js_cocos2dx_Node_enumerateChildren(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_enumerateChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<bool (cocos2d::Node *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Node* larg0) -> bool {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                    bool result;
                    ok &= seval_to_boolean(rval, &result);
                    SE_PRECONDITION2(ok, result, "lambda function : Error processing return value with type bool");
                    return result;
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_enumerateChildren : Error processing arguments");
        cobj->enumerateChildren(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_enumerateChildren)

static bool js_cocos2dx_Node_removeFromParentAndCleanup(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_removeFromParentAndCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            bool arg0;
            ok &= seval_to_boolean(args[0], &arg0);
            cobj->removeFromParentAndCleanup(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->removeFromParent();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_removeFromParentAndCleanup)

static bool js_cocos2dx_Node_convertTouchToNodeSpaceAR(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Touch* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertTouchToNodeSpaceAR(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertTouchToNodeSpaceAR : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertTouchToNodeSpaceAR)

static bool js_cocos2dx_Node_sortAllChildren(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_sortAllChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->sortAllChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_sortAllChildren)

static bool js_cocos2dx_Node_getWorldToNodeAffineTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getWorldToNodeAffineTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AffineTransform result = cobj->getWorldToNodeAffineTransform();
        ok &= AffineTransform_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getWorldToNodeAffineTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getWorldToNodeAffineTransform)

static bool js_cocos2dx_Node_getScale(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScale();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getScale : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getScale)

static bool js_cocos2dx_Node_getOpacity(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getOpacity)

static bool js_cocos2dx_Node_getNormalizedPosition(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getNormalizedPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getNormalizedPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getNormalizedPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getNormalizedPosition)

static bool js_cocos2dx_Node_getParentToNodeTransform(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_getParentToNodeTransform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Mat4& result = cobj->getParentToNodeTransform();
        ok &= Mat4_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getParentToNodeTransform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getParentToNodeTransform)

static bool js_cocos2dx_Node_convertToNodeSpace(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_convertToNodeSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpace : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToNodeSpace(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_convertToNodeSpace : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_convertToNodeSpace)

static bool js_cocos2dx_Node_setTag(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_setTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_setTag : Error processing arguments");
        cobj->setTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_setTag)

static bool js_cocos2dx_Node_isCascadeColorEnabled(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_isCascadeColorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCascadeColorEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_isCascadeColorEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_isCascadeColorEnabled)

static bool js_cocos2dx_Node_markCullingDirty(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_markCullingDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->markCullingDirty();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_markCullingDirty)

static bool js_cocos2dx_Node_stopAction(se::State& s)
{
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Node_stopAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_stopAction : Error processing arguments");
        cobj->stopAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_stopAction)

static bool js_cocos2dx_Node_getActionManager(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Node_getActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::ActionManager* result = cobj->getActionManager();
            ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionManager : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::ActionManager* result = cobj->getActionManager();
            ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Node_getActionManager : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_getActionManager)

static bool js_cocos2dx_Node_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Node::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Node_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Node_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Node_finalize)

static bool js_cocos2dx_Node_constructor(se::State& s)
{
    cocos2d::Node* cobj = new (std::nothrow) cocos2d::Node();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Node_constructor, __jsb_cocos2d_Node_class, js_cocos2d_Node_finalize)

static bool js_cocos2dx_Node_ctor(se::State& s)
{
    cocos2d::Node* cobj = new (std::nothrow) cocos2d::Node();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Node_ctor, __jsb_cocos2d_Node_class, js_cocos2d_Node_finalize)


    


static bool js_cocos2d_Node_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Node)", s.nativeThisObject());
    cocos2d::Node* cobj = (cocos2d::Node*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Node_finalize)

bool js_register_cocos2dx_Node(se::Object* obj)
{
    auto cls = se::Class::create("Node", obj, nullptr, _SE(js_cocos2dx_Node_constructor));

    cls->defineFunction("addChild", _SE(js_cocos2dx_Node_addChild));
    cls->defineFunction("removeComponent", _SE(js_cocos2dx_Node_removeComponent));
    cls->defineFunction("getShaderProgram", _SE(js_cocos2dx_Node_getGLProgram));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_Node_getDescription));
    cls->defineFunction("setOpacityModifyRGB", _SE(js_cocos2dx_Node_setOpacityModifyRGB));
    cls->defineFunction("setCascadeOpacityEnabled", _SE(js_cocos2dx_Node_setCascadeOpacityEnabled));
    cls->defineFunction("getChildren", _SE(js_cocos2dx_Node_getChildren));
    cls->defineFunction("pause", _SE(js_cocos2dx_Node_pause));
    cls->defineFunction("convertToWorldSpaceAR", _SE(js_cocos2dx_Node_convertToWorldSpaceAR));
    cls->defineFunction("isIgnoreAnchorPointForPosition", _SE(js_cocos2dx_Node_isIgnoreAnchorPointForPosition));
    cls->defineFunction("getChildByName", _SE(js_cocos2dx_Node_getChildByName));
    cls->defineFunction("init", _SE(js_cocos2dx_Node_init));
    cls->defineFunction("getBeforeVisitCallback", _SE(js_cocos2dx_Node_getBeforeVisitCallback));
    cls->defineFunction("getCameraMask", _SE(js_cocos2dx_Node_getCameraMask));
    cls->defineFunction("setRotation", _SE(js_cocos2dx_Node_setRotation));
    cls->defineFunction("setScaleZ", _SE(js_cocos2dx_Node_setScaleZ));
    cls->defineFunction("setScaleY", _SE(js_cocos2dx_Node_setScaleY));
    cls->defineFunction("setScaleX", _SE(js_cocos2dx_Node_setScaleX));
    cls->defineFunction("getColor", _SE(js_cocos2dx_Node_getColor));
    cls->defineFunction("removeAllComponents", _SE(js_cocos2dx_Node_removeAllComponents));
    cls->defineFunction("_setLocalZOrder", _SE(js_cocos2dx_Node__setLocalZOrder));
    cls->defineFunction("setCameraMask", _SE(js_cocos2dx_Node_setCameraMask));
    cls->defineFunction("getTag", _SE(js_cocos2dx_Node_getTag));
    cls->defineFunction("setAfterVisitCallback", _SE(js_cocos2dx_Node_setAfterVisitCallback));
    cls->defineFunction("getNodeToWorldTransform", _SE(js_cocos2dx_Node_getNodeToWorldAffineTransform));
    cls->defineFunction("removeChild", _SE(js_cocos2dx_Node_removeChild));
    cls->defineFunction("convertToWorldSpace", _SE(js_cocos2dx_Node_convertToWorldSpace));
    cls->defineFunction("getScene", _SE(js_cocos2dx_Node_getScene));
    cls->defineFunction("getEventDispatcher", _SE(js_cocos2dx_Node_getEventDispatcher));
    cls->defineFunction("setSkewX", _SE(js_cocos2dx_Node_setSkewX));
    cls->defineFunction("setGLProgramState", _SE(js_cocos2dx_Node_setGLProgramState));
    cls->defineFunction("stopActionsByFlags", _SE(js_cocos2dx_Node_stopActionsByFlags));
    cls->defineFunction("setNormalizedPosition", _SE(js_cocos2dx_Node_setNormalizedPosition));
    cls->defineFunction("convertTouchToNodeSpace", _SE(js_cocos2dx_Node_convertTouchToNodeSpace));
    cls->defineFunction("removeAllChildren", _SE(js_cocos2dx_Node_removeAllChildrenWithCleanup));
    cls->defineFunction("getRotationX", _SE(js_cocos2dx_Node_getRotationSkewX));
    cls->defineFunction("getRotationY", _SE(js_cocos2dx_Node_getRotationSkewY));
    cls->defineFunction("getNodeToWorldTransform3D", _SE(js_cocos2dx_Node_getNodeToWorldTransform));
    cls->defineFunction("isCascadeOpacityEnabled", _SE(js_cocos2dx_Node_isCascadeOpacityEnabled));
    cls->defineFunction("setParent", _SE(js_cocos2dx_Node_setParent));
    cls->defineFunction("getName", _SE(js_cocos2dx_Node_getName));
    cls->defineFunction("resume", _SE(js_cocos2dx_Node_resume));
    cls->defineFunction("getNodeToParentTransform", _SE(js_cocos2dx_Node_getNodeToParentAffineTransform));
    cls->defineFunction("getAfterVisitCallback", _SE(js_cocos2dx_Node_getAfterVisitCallback));
    cls->defineFunction("isOpacityModifyRGB", _SE(js_cocos2dx_Node_isOpacityModifyRGB));
    cls->defineFunction("stopActionByTag", _SE(js_cocos2dx_Node_stopActionByTag));
    cls->defineFunction("reorderChild", _SE(js_cocos2dx_Node_reorderChild));
    cls->defineFunction("setSkewY", _SE(js_cocos2dx_Node_setSkewY));
    cls->defineFunction("setColor", _SE(js_cocos2dx_Node_setColor));
    cls->defineFunction("setPositionY", _SE(js_cocos2dx_Node_setPositionY));
    cls->defineFunction("setPositionX", _SE(js_cocos2dx_Node_setPositionX));
    cls->defineFunction("setNodeToParentTransform", _SE(js_cocos2dx_Node_setNodeToParentTransform));
    cls->defineFunction("getAnchorPoint", _SE(js_cocos2dx_Node_getAnchorPoint));
    cls->defineFunction("getNumberOfRunningActions", _SE(js_cocos2dx_Node_getNumberOfRunningActions));
    cls->defineFunction("isVisible", _SE(js_cocos2dx_Node_isVisible));
    cls->defineFunction("getChildrenCount", _SE(js_cocos2dx_Node_getChildrenCount));
    cls->defineFunction("getNodeToParentTransform3D", _SE(js_cocos2dx_Node_getNodeToParentTransform));
    cls->defineFunction("convertToNodeSpaceAR", _SE(js_cocos2dx_Node_convertToNodeSpaceAR));
    cls->defineFunction("addComponent", _SE(js_cocos2dx_Node_addComponent));
    cls->defineFunction("visit", _SE(js_cocos2dx_Node_visit));
    cls->defineFunction("setShaderProgram", _SE(js_cocos2dx_Node_setGLProgram));
    cls->defineFunction("getRotation", _SE(js_cocos2dx_Node_getRotation));
    cls->defineFunction("getAnchorPointInPoints", _SE(js_cocos2dx_Node_getAnchorPointInPoints));
    cls->defineFunction("runAction", _SE(js_cocos2dx_Node_runAction));
    cls->defineFunction("removeChildByName", _SE(js_cocos2dx_Node_removeChildByName));
    cls->defineFunction("setVertexZ", _SE(js_cocos2dx_Node_setPositionZ));
    cls->defineFunction("getGLProgramState", _SE(js_cocos2dx_Node_getGLProgramState));
    cls->defineFunction("setScheduler", _SE(js_cocos2dx_Node_setScheduler));
    cls->defineFunction("stopAllActions", _SE(js_cocos2dx_Node_stopAllActions));
    cls->defineFunction("getSkewX", _SE(js_cocos2dx_Node_getSkewX));
    cls->defineFunction("getSkewY", _SE(js_cocos2dx_Node_getSkewY));
    cls->defineFunction("getDisplayedColor", _SE(js_cocos2dx_Node_getDisplayedColor));
    cls->defineFunction("getActionByTag", _SE(js_cocos2dx_Node_getActionByTag));
    cls->defineFunction("setRotationX", _SE(js_cocos2dx_Node_setRotationSkewX));
    cls->defineFunction("setRotationY", _SE(js_cocos2dx_Node_setRotationSkewY));
    cls->defineFunction("setName", _SE(js_cocos2dx_Node_setName));
    cls->defineFunction("getDisplayedOpacity", _SE(js_cocos2dx_Node_getDisplayedOpacity));
    cls->defineFunction("getLocalZOrder", _SE(js_cocos2dx_Node_getLocalZOrder));
    cls->defineFunction("getScheduler", _SE(js_cocos2dx_Node_getScheduler));
    cls->defineFunction("setBeforeVisitCallback", _SE(js_cocos2dx_Node_setBeforeVisitCallback));
    cls->defineFunction("setActionManager", _SE(js_cocos2dx_Node_setActionManager));
    cls->defineFunction("getPosition", _SE(js_cocos2dx_Node_getPosition));
    cls->defineFunction("insertChildBefore", _SE(js_cocos2dx_Node_insertChildBefore));
    cls->defineFunction("isRunning", _SE(js_cocos2dx_Node_isRunning));
    cls->defineFunction("getParent", _SE(js_cocos2dx_Node_getParent));
    cls->defineFunction("getWorldToNodeTransform3D", _SE(js_cocos2dx_Node_getWorldToNodeTransform));
    cls->defineFunction("getPositionY", _SE(js_cocos2dx_Node_getPositionY));
    cls->defineFunction("getPositionX", _SE(js_cocos2dx_Node_getPositionX));
    cls->defineFunction("removeChildByTag", _SE(js_cocos2dx_Node_removeChildByTag));
    cls->defineFunction("setVisible", _SE(js_cocos2dx_Node_setVisible));
    cls->defineFunction("getParentToNodeTransform", _SE(js_cocos2dx_Node_getParentToNodeAffineTransform));
    cls->defineFunction("getVertexZ", _SE(js_cocos2dx_Node_getPositionZ));
    cls->defineFunction("setGlobalZOrder", _SE(js_cocos2dx_Node_setGlobalZOrder));
    cls->defineFunction("setScale", _SE(js_cocos2dx_Node_setScale));
    cls->defineFunction("getChildByTag", _SE(js_cocos2dx_Node_getChildByTag));
    cls->defineFunction("getScaleZ", _SE(js_cocos2dx_Node_getScaleZ));
    cls->defineFunction("getScaleY", _SE(js_cocos2dx_Node_getScaleY));
    cls->defineFunction("getScaleX", _SE(js_cocos2dx_Node_getScaleX));
    cls->defineFunction("setLocalZOrder", _SE(js_cocos2dx_Node_setLocalZOrder));
    cls->defineFunction("setCascadeColorEnabled", _SE(js_cocos2dx_Node_setCascadeColorEnabled));
    cls->defineFunction("setOpacity", _SE(js_cocos2dx_Node_setOpacity));
    cls->defineFunction("getComponent", _SE(js_cocos2dx_Node_getComponent));
    cls->defineFunction("getContentSize", _SE(js_cocos2dx_Node_getContentSize));
    cls->defineFunction("stopAllActionsByTag", _SE(js_cocos2dx_Node_stopAllActionsByTag));
    cls->defineFunction("getBoundingBox", _SE(js_cocos2dx_Node_getBoundingBox));
    cls->defineFunction("setIgnoreAnchorPointForPosition", _SE(js_cocos2dx_Node_setIgnoreAnchorPointForPosition));
    cls->defineFunction("setEventDispatcher", _SE(js_cocos2dx_Node_setEventDispatcher));
    cls->defineFunction("getGlobalZOrder", _SE(js_cocos2dx_Node_getGlobalZOrder));
    cls->defineFunction("draw", _SE(js_cocos2dx_Node_draw));
    cls->defineFunction("setUserObject", _SE(js_cocos2dx_Node_setUserObject));
    cls->defineFunction("enumerateChildren", _SE(js_cocos2dx_Node_enumerateChildren));
    cls->defineFunction("removeFromParent", _SE(js_cocos2dx_Node_removeFromParentAndCleanup));
    cls->defineFunction("convertTouchToNodeSpaceAR", _SE(js_cocos2dx_Node_convertTouchToNodeSpaceAR));
    cls->defineFunction("sortAllChildren", _SE(js_cocos2dx_Node_sortAllChildren));
    cls->defineFunction("getWorldToNodeTransform", _SE(js_cocos2dx_Node_getWorldToNodeAffineTransform));
    cls->defineFunction("getScale", _SE(js_cocos2dx_Node_getScale));
    cls->defineFunction("getOpacity", _SE(js_cocos2dx_Node_getOpacity));
    cls->defineFunction("getNormalizedPosition", _SE(js_cocos2dx_Node_getNormalizedPosition));
    cls->defineFunction("getParentToNodeTransform3D", _SE(js_cocos2dx_Node_getParentToNodeTransform));
    cls->defineFunction("convertToNodeSpace", _SE(js_cocos2dx_Node_convertToNodeSpace));
    cls->defineFunction("setTag", _SE(js_cocos2dx_Node_setTag));
    cls->defineFunction("isCascadeColorEnabled", _SE(js_cocos2dx_Node_isCascadeColorEnabled));
    cls->defineFunction("markCullingDirty", _SE(js_cocos2dx_Node_markCullingDirty));
    cls->defineFunction("stopAction", _SE(js_cocos2dx_Node_stopAction));
    cls->defineFunction("getActionManager", _SE(js_cocos2dx_Node_getActionManager));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Node_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Node_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Node_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Node>(cls);

    __jsb_cocos2d_Node_proto = cls->getProto();
    __jsb_cocos2d_Node_class = cls;

    jsb_set_extend_property("cc", "Node");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Scene_proto = nullptr;
se::Class* __jsb_cocos2d_Scene_class = nullptr;

static bool js_cocos2dx_Scene_initWithSize(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_initWithSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scene_initWithSize : Error processing arguments");
        bool result = cobj->initWithSize(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scene_initWithSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_initWithSize)

static bool js_cocos2dx_Scene_render(se::State& s)
{
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scene_render : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Renderer* arg0 = nullptr;
        cocos2d::Mat4 arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scene_render : Error processing arguments");
        cobj->render(arg0, arg1);
        return true;
    }
    if (argc == 3) {
        cocos2d::Renderer* arg0 = nullptr;
        cocos2d::Mat4 arg1;
        const cocos2d::Mat4* arg2 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scene_render : Error processing arguments");
        cobj->render(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_render)

static bool js_cocos2dx_Scene_createWithSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scene_createWithSize : Error processing arguments");
        auto result = cocos2d::Scene::createWithSize(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Scene_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_createWithSize)

static bool js_cocos2dx_Scene_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Scene::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Scene_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scene_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Scene_finalize)

static bool js_cocos2dx_Scene_constructor(se::State& s)
{
    cocos2d::Scene* cobj = new (std::nothrow) cocos2d::Scene();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Scene_constructor, __jsb_cocos2d_Scene_class, js_cocos2d_Scene_finalize)

static bool js_cocos2dx_Scene_ctor(se::State& s)
{
    cocos2d::Scene* cobj = new (std::nothrow) cocos2d::Scene();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Scene_ctor, __jsb_cocos2d_Scene_class, js_cocos2d_Scene_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_Scene_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Scene)", s.nativeThisObject());
    cocos2d::Scene* cobj = (cocos2d::Scene*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Scene_finalize)

bool js_register_cocos2dx_Scene(se::Object* obj)
{
    auto cls = se::Class::create("Scene", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Scene_constructor));

    cls->defineFunction("initWithSize", _SE(js_cocos2dx_Scene_initWithSize));
    cls->defineFunction("render", _SE(js_cocos2dx_Scene_render));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Scene_ctor));
    cls->defineStaticFunction("createWithSize", _SE(js_cocos2dx_Scene_createWithSize));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Scene_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Scene_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Scene>(cls);

    __jsb_cocos2d_Scene_proto = cls->getProto();
    __jsb_cocos2d_Scene_class = cls;

    jsb_set_extend_property("cc", "Scene");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_GLView_proto = nullptr;
se::Class* __jsb_cocos2d_GLView_class = nullptr;

static bool js_cocos2dx_GLView_setFrameSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setFrameSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setFrameSize : Error processing arguments");
        cobj->setFrameSize(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setFrameSize)

static bool js_cocos2dx_GLView_getViewPortRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getViewPortRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getViewPortRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getViewPortRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getViewPortRect)

static bool js_cocos2dx_GLView_setContentScaleFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setContentScaleFactor : Error processing arguments");
        bool result = cobj->setContentScaleFactor(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setContentScaleFactor)

static bool js_cocos2dx_GLView_getContentScaleFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getContentScaleFactor();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getContentScaleFactor)

static bool js_cocos2dx_GLView_setIMEKeyboardState(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setIMEKeyboardState : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setIMEKeyboardState : Error processing arguments");
        cobj->setIMEKeyboardState(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setIMEKeyboardState)

static bool js_cocos2dx_GLView_getSafeAreaRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getSafeAreaRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getSafeAreaRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getSafeAreaRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getSafeAreaRect)

static bool js_cocos2dx_GLView_setScissorInPoints(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setScissorInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setScissorInPoints : Error processing arguments");
        cobj->setScissorInPoints(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setScissorInPoints)

static bool js_cocos2dx_GLView_getViewName(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getViewName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getViewName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getViewName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getViewName)

static bool js_cocos2dx_GLView_isOpenGLReady(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isOpenGLReady : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isOpenGLReady();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isOpenGLReady : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isOpenGLReady)

static bool js_cocos2dx_GLView_setCursorVisible(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setCursorVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setCursorVisible : Error processing arguments");
        cobj->setCursorVisible(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setCursorVisible)

static bool js_cocos2dx_GLView_getScaleY(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScaleY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScaleY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScaleY)

static bool js_cocos2dx_GLView_getScaleX(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScaleX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScaleX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScaleX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScaleX)

static bool js_cocos2dx_GLView_getVisibleOrigin(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleOrigin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getVisibleOrigin();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleOrigin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleOrigin)

static bool js_cocos2dx_GLView_getFrameSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getFrameSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getFrameSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getFrameSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getFrameSize)

static bool js_cocos2dx_GLView_setFrameZoomFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setFrameZoomFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setFrameZoomFactor : Error processing arguments");
        cobj->setFrameZoomFactor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setFrameZoomFactor)

static bool js_cocos2dx_GLView_getFrameZoomFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getFrameZoomFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFrameZoomFactor();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getFrameZoomFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getFrameZoomFactor)

static bool js_cocos2dx_GLView_getDesignResolutionSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getDesignResolutionSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getDesignResolutionSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getDesignResolutionSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getDesignResolutionSize)

static bool js_cocos2dx_GLView_windowShouldClose(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_windowShouldClose : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->windowShouldClose();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_windowShouldClose : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_windowShouldClose)

static bool js_cocos2dx_GLView_setDesignResolutionSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setDesignResolutionSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        ResolutionPolicy arg2;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setDesignResolutionSize : Error processing arguments");
        cobj->setDesignResolutionSize(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setDesignResolutionSize)

static bool js_cocos2dx_GLView_getResolutionPolicy(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getResolutionPolicy : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getResolutionPolicy();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getResolutionPolicy : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getResolutionPolicy)

static bool js_cocos2dx_GLView_isRetinaDisplay(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isRetinaDisplay : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRetinaDisplay();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isRetinaDisplay : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isRetinaDisplay)

static bool js_cocos2dx_GLView_renderScene(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_renderScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Scene* arg0 = nullptr;
        cocos2d::Renderer* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_renderScene : Error processing arguments");
        cobj->renderScene(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_renderScene)

static bool js_cocos2dx_GLView_setViewPortInPoints(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setViewPortInPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setViewPortInPoints : Error processing arguments");
        cobj->setViewPortInPoints(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setViewPortInPoints)

static bool js_cocos2dx_GLView_getScissorRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getScissorRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getScissorRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getScissorRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getScissorRect)

static bool js_cocos2dx_GLView_enableAntiAlias(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_enableAntiAlias : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_enableAntiAlias : Error processing arguments");
        cobj->enableAntiAlias(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_enableAntiAlias)

static bool js_cocos2dx_GLView_getRetinaFactor(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getRetinaFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getRetinaFactor();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getRetinaFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getRetinaFactor)

static bool js_cocos2dx_GLView_setViewName(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_setViewName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_setViewName : Error processing arguments");
        cobj->setViewName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_setViewName)

static bool js_cocos2dx_GLView_getVisibleRect(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getVisibleRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleRect)

static bool js_cocos2dx_GLView_getVisibleSize(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_getVisibleSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getVisibleSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_getVisibleSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_getVisibleSize)

static bool js_cocos2dx_GLView_isScissorEnabled(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isScissorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isScissorEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isScissorEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isScissorEnabled)

static bool js_cocos2dx_GLView_pollEvents(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_pollEvents : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pollEvents();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_pollEvents)

static bool js_cocos2dx_GLView_isAntiAliasEnabled(se::State& s)
{
    cocos2d::GLView* cobj = (cocos2d::GLView*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLView_isAntiAliasEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isAntiAliasEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLView_isAntiAliasEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLView_isAntiAliasEnabled)




bool js_register_cocos2dx_GLView(se::Object* obj)
{
    auto cls = se::Class::create("GLView", obj, nullptr, nullptr);

    cls->defineFunction("setFrameSize", _SE(js_cocos2dx_GLView_setFrameSize));
    cls->defineFunction("getViewPortRect", _SE(js_cocos2dx_GLView_getViewPortRect));
    cls->defineFunction("setContentScaleFactor", _SE(js_cocos2dx_GLView_setContentScaleFactor));
    cls->defineFunction("getContentScaleFactor", _SE(js_cocos2dx_GLView_getContentScaleFactor));
    cls->defineFunction("setIMEKeyboardState", _SE(js_cocos2dx_GLView_setIMEKeyboardState));
    cls->defineFunction("getSafeAreaRect", _SE(js_cocos2dx_GLView_getSafeAreaRect));
    cls->defineFunction("setScissorInPoints", _SE(js_cocos2dx_GLView_setScissorInPoints));
    cls->defineFunction("getViewName", _SE(js_cocos2dx_GLView_getViewName));
    cls->defineFunction("isOpenGLReady", _SE(js_cocos2dx_GLView_isOpenGLReady));
    cls->defineFunction("setCursorVisible", _SE(js_cocos2dx_GLView_setCursorVisible));
    cls->defineFunction("getScaleY", _SE(js_cocos2dx_GLView_getScaleY));
    cls->defineFunction("getScaleX", _SE(js_cocos2dx_GLView_getScaleX));
    cls->defineFunction("getVisibleOrigin", _SE(js_cocos2dx_GLView_getVisibleOrigin));
    cls->defineFunction("getFrameSize", _SE(js_cocos2dx_GLView_getFrameSize));
    cls->defineFunction("setFrameZoomFactor", _SE(js_cocos2dx_GLView_setFrameZoomFactor));
    cls->defineFunction("getFrameZoomFactor", _SE(js_cocos2dx_GLView_getFrameZoomFactor));
    cls->defineFunction("getDesignResolutionSize", _SE(js_cocos2dx_GLView_getDesignResolutionSize));
    cls->defineFunction("windowShouldClose", _SE(js_cocos2dx_GLView_windowShouldClose));
    cls->defineFunction("setDesignResolutionSize", _SE(js_cocos2dx_GLView_setDesignResolutionSize));
    cls->defineFunction("getResolutionPolicy", _SE(js_cocos2dx_GLView_getResolutionPolicy));
    cls->defineFunction("isRetinaDisplay", _SE(js_cocos2dx_GLView_isRetinaDisplay));
    cls->defineFunction("renderScene", _SE(js_cocos2dx_GLView_renderScene));
    cls->defineFunction("setViewPortInPoints", _SE(js_cocos2dx_GLView_setViewPortInPoints));
    cls->defineFunction("getScissorRect", _SE(js_cocos2dx_GLView_getScissorRect));
    cls->defineFunction("enableAntiAlias", _SE(js_cocos2dx_GLView_enableAntiAlias));
    cls->defineFunction("getRetinaFactor", _SE(js_cocos2dx_GLView_getRetinaFactor));
    cls->defineFunction("setViewName", _SE(js_cocos2dx_GLView_setViewName));
    cls->defineFunction("getVisibleRect", _SE(js_cocos2dx_GLView_getVisibleRect));
    cls->defineFunction("getVisibleSize", _SE(js_cocos2dx_GLView_getVisibleSize));
    cls->defineFunction("isScissorEnabled", _SE(js_cocos2dx_GLView_isScissorEnabled));
    cls->defineFunction("pollEvents", _SE(js_cocos2dx_GLView_pollEvents));
    cls->defineFunction("isAntiAliasEnabled", _SE(js_cocos2dx_GLView_isAntiAliasEnabled));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLView>(cls);

    __jsb_cocos2d_GLView_proto = cls->getProto();
    __jsb_cocos2d_GLView_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Director_proto = nullptr;
se::Class* __jsb_cocos2d_Director_class = nullptr;

static bool js_cocos2dx_Director_pause(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pause : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pause();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pause)

static bool js_cocos2dx_Director_isPurgeDirectorInNextLoop(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isPurgeDirectorInNextLoop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPurgeDirectorInNextLoop();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isPurgeDirectorInNextLoop : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isPurgeDirectorInNextLoop)

static bool js_cocos2dx_Director_setEventDispatcher(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventDispatcher* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setEventDispatcher : Error processing arguments");
        cobj->setEventDispatcher(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setEventDispatcher)

static bool js_cocos2dx_Director_setContentScaleFactor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setContentScaleFactor : Error processing arguments");
        cobj->setContentScaleFactor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setContentScaleFactor)

static bool js_cocos2dx_Director_getDeltaTime(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getDeltaTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDeltaTime();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getDeltaTime : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getDeltaTime)

static bool js_cocos2dx_Director_getContentScaleFactor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getContentScaleFactor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getContentScaleFactor();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getContentScaleFactor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getContentScaleFactor)

static bool js_cocos2dx_Director_getWinSizeInPixels(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getWinSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getWinSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getWinSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getWinSizeInPixels)

static bool js_cocos2dx_Director_getSafeAreaRect(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getSafeAreaRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->getSafeAreaRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getSafeAreaRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getSafeAreaRect)

static bool js_cocos2dx_Director_isCullingEnabled(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isCullingEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCullingEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isCullingEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isCullingEnabled)

static bool js_cocos2dx_Director_setGLDefaultValues(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setGLDefaultValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setGLDefaultValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setGLDefaultValues)

static bool js_cocos2dx_Director_setActionManager(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionManager* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setActionManager : Error processing arguments");
        cobj->setActionManager(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setActionManager)

static bool js_cocos2dx_Director_setAlphaBlending(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setAlphaBlending : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setAlphaBlending : Error processing arguments");
        cobj->setAlphaBlending(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setAlphaBlending)

static bool js_cocos2dx_Director_popToRootScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popToRootScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->popToRootScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popToRootScene)

static bool js_cocos2dx_Director_loadMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        cocos2d::Mat4 arg1;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadMatrix : Error processing arguments");
        cobj->loadMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadMatrix)

static bool js_cocos2dx_Director_setCullingEnabled(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setCullingEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setCullingEnabled : Error processing arguments");
        cobj->setCullingEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setCullingEnabled)

static bool js_cocos2dx_Director_getNotificationNode(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getNotificationNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNotificationNode();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getNotificationNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getNotificationNode)

static bool js_cocos2dx_Director_getWinSize(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getWinSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getWinSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getWinSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getWinSize)

static bool js_cocos2dx_Director_end(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_end : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->end();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_end)

static bool js_cocos2dx_Director_getTextureCache(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getTextureCache : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::TextureCache* result = cobj->getTextureCache();
        ok &= native_ptr_to_seval<cocos2d::TextureCache>((cocos2d::TextureCache*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getTextureCache : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getTextureCache)

static bool js_cocos2dx_Director_isSendCleanupToScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isSendCleanupToScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSendCleanupToScene();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isSendCleanupToScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isSendCleanupToScene)

static bool js_cocos2dx_Director_getVisibleOrigin(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getVisibleOrigin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getVisibleOrigin();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getVisibleOrigin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getVisibleOrigin)

static bool js_cocos2dx_Director_mainLoop(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_mainLoop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->mainLoop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_mainLoop)

static bool js_cocos2dx_Director_setDepthTest(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDepthTest : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setDepthTest : Error processing arguments");
        cobj->setDepthTest(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDepthTest)

static bool js_cocos2dx_Director_getFrameRate(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getFrameRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFrameRate();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getFrameRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getFrameRate)

static bool js_cocos2dx_Director_getSecondsPerFrame(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getSecondsPerFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSecondsPerFrame();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getSecondsPerFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getSecondsPerFrame)

static bool js_cocos2dx_Director_resetMatrixStack(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_resetMatrixStack : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resetMatrixStack();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_resetMatrixStack)

static bool js_cocos2dx_Director_convertToUI(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_convertToUI : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToUI : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToUI(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToUI : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_convertToUI)

static bool js_cocos2dx_Director_pushMatrix(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Director_pushMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->pushMatrix(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::MATRIX_STACK_TYPE arg0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cobj->pushMatrix(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pushMatrix)

static bool js_cocos2dx_Director_setDefaultValues(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDefaultValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setDefaultValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDefaultValues)

static bool js_cocos2dx_Director_init(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_init)

static bool js_cocos2dx_Director_setScheduler(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scheduler* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setScheduler : Error processing arguments");
        cobj->setScheduler(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setScheduler)

static bool js_cocos2dx_Director_getMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getMatrix : Error processing arguments");
        const cocos2d::Mat4& result = cobj->getMatrix(arg0);
        ok &= Mat4_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getMatrix : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getMatrix)

static bool js_cocos2dx_Director_isValid(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isValid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isValid();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isValid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isValid)

static bool js_cocos2dx_Director_startAnimation(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_startAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->startAnimation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_startAnimation)

static bool js_cocos2dx_Director_getOpenGLView(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getOpenGLView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLView* result = cobj->getOpenGLView();
        ok &= native_ptr_to_seval<cocos2d::GLView>((cocos2d::GLView*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getOpenGLView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getOpenGLView)

static bool js_cocos2dx_Director_getRunningScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getRunningScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scene* result = cobj->getRunningScene();
        ok &= native_ptr_to_seval<cocos2d::Scene>((cocos2d::Scene*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getRunningScene : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getRunningScene)

static bool js_cocos2dx_Director_setViewport(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setViewport();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setViewport)

static bool js_cocos2dx_Director_stopAnimation(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_stopAnimation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopAnimation();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_stopAnimation)

static bool js_cocos2dx_Director_popToSceneStackLevel(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popToSceneStackLevel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_popToSceneStackLevel : Error processing arguments");
        cobj->popToSceneStackLevel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popToSceneStackLevel)

static bool js_cocos2dx_Director_resume(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_resume : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resume();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_resume)

static bool js_cocos2dx_Director_isNextDeltaTimeZero(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isNextDeltaTimeZero : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isNextDeltaTimeZero();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isNextDeltaTimeZero : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isNextDeltaTimeZero)

static bool js_cocos2dx_Director_setClearColor(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setClearColor : Error processing arguments");
        cobj->setClearColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setClearColor)

static bool js_cocos2dx_Director_setOpenGLView(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setOpenGLView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLView* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setOpenGLView : Error processing arguments");
        cobj->setOpenGLView(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setOpenGLView)

static bool js_cocos2dx_Director_convertToGL(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_convertToGL : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToGL : Error processing arguments");
        cocos2d::Vec2 result = cobj->convertToGL(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_convertToGL : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_convertToGL)

static bool js_cocos2dx_Director_purgeCachedData(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_purgeCachedData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->purgeCachedData();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_purgeCachedData)

static bool js_cocos2dx_Director_getTotalFrames(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getTotalFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getTotalFrames();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getTotalFrames : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getTotalFrames)

static bool js_cocos2dx_Director_runWithScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_runWithScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_runWithScene : Error processing arguments");
        cobj->runWithScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_runWithScene)

static bool js_cocos2dx_Director_setNotificationNode(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setNotificationNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setNotificationNode : Error processing arguments");
        cobj->setNotificationNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setNotificationNode)

static bool js_cocos2dx_Director_drawScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_drawScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->drawScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_drawScene)

static bool js_cocos2dx_Director_restart(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_restart : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->restart();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_restart)

static bool js_cocos2dx_Director_popScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->popScene();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popScene)

static bool js_cocos2dx_Director_loadIdentityMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_loadIdentityMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_loadIdentityMatrix : Error processing arguments");
        cobj->loadIdentityMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_loadIdentityMatrix)

static bool js_cocos2dx_Director_isDisplayStats(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isDisplayStats : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDisplayStats();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isDisplayStats : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isDisplayStats)

static bool js_cocos2dx_Director_setProjection(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setProjection : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Director::Projection arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setProjection : Error processing arguments");
        cobj->setProjection(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setProjection)

static bool js_cocos2dx_Director_multiplyMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_multiplyMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        cocos2d::Mat4 arg1;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_Mat4(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_multiplyMatrix : Error processing arguments");
        cobj->multiplyMatrix(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_multiplyMatrix)

static bool js_cocos2dx_Director_getZEye(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getZEye : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getZEye();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getZEye : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getZEye)

static bool js_cocos2dx_Director_setNextDeltaTimeZero(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setNextDeltaTimeZero : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setNextDeltaTimeZero : Error processing arguments");
        cobj->setNextDeltaTimeZero(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setNextDeltaTimeZero)

static bool js_cocos2dx_Director_popMatrix(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_popMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MATRIX_STACK_TYPE arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_popMatrix : Error processing arguments");
        cobj->popMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_popMatrix)

static bool js_cocos2dx_Director_getVisibleSize(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getVisibleSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getVisibleSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getVisibleSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getVisibleSize)

static bool js_cocos2dx_Director_getScheduler(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getScheduler : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Scheduler* result = cobj->getScheduler();
        ok &= native_ptr_to_seval<cocos2d::Scheduler>((cocos2d::Scheduler*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getScheduler : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getScheduler)

static bool js_cocos2dx_Director_pushScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_pushScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_pushScene : Error processing arguments");
        cobj->pushScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_pushScene)

static bool js_cocos2dx_Director_getAnimationInterval(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getAnimationInterval : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAnimationInterval();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getAnimationInterval : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getAnimationInterval)

static bool js_cocos2dx_Director_isPaused(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_isPaused : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPaused();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_isPaused : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_isPaused)

static bool js_cocos2dx_Director_setDisplayStats(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setDisplayStats : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setDisplayStats : Error processing arguments");
        cobj->setDisplayStats(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setDisplayStats)

static bool js_cocos2dx_Director_getEventDispatcher(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getEventDispatcher : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventDispatcher* result = cobj->getEventDispatcher();
        ok &= native_ptr_to_seval<cocos2d::EventDispatcher>((cocos2d::EventDispatcher*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getEventDispatcher : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getEventDispatcher)

static bool js_cocos2dx_Director_replaceScene(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_replaceScene : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Scene* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_replaceScene : Error processing arguments");
        cobj->replaceScene(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_replaceScene)

static bool js_cocos2dx_Director_setAnimationInterval(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_setAnimationInterval : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_setAnimationInterval : Error processing arguments");
        cobj->setAnimationInterval(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_setAnimationInterval)

static bool js_cocos2dx_Director_getActionManager(se::State& s)
{
    cocos2d::Director* cobj = (cocos2d::Director*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Director_getActionManager : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionManager* result = cobj->getActionManager();
        ok &= native_ptr_to_seval<cocos2d::ActionManager>((cocos2d::ActionManager*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Director_getActionManager : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getActionManager)

static bool js_cocos2dx_Director_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Director::getInstance();
        se::Value instanceVal;
        native_ptr_to_seval<cocos2d::Director>(result, __jsb_cocos2d_Director_class, &instanceVal);
        instanceVal.toObject()->root();
        s.rval() = instanceVal;
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Director_getInstance)




bool js_register_cocos2dx_Director(se::Object* obj)
{
    auto cls = se::Class::create("Director", obj, nullptr, nullptr);

    cls->defineFunction("pause", _SE(js_cocos2dx_Director_pause));
    cls->defineFunction("isPurgeDirectorInNextLoop", _SE(js_cocos2dx_Director_isPurgeDirectorInNextLoop));
    cls->defineFunction("setEventDispatcher", _SE(js_cocos2dx_Director_setEventDispatcher));
    cls->defineFunction("setContentScaleFactor", _SE(js_cocos2dx_Director_setContentScaleFactor));
    cls->defineFunction("getDeltaTime", _SE(js_cocos2dx_Director_getDeltaTime));
    cls->defineFunction("getContentScaleFactor", _SE(js_cocos2dx_Director_getContentScaleFactor));
    cls->defineFunction("getWinSizeInPixels", _SE(js_cocos2dx_Director_getWinSizeInPixels));
    cls->defineFunction("getSafeAreaRect", _SE(js_cocos2dx_Director_getSafeAreaRect));
    cls->defineFunction("isCullingEnabled", _SE(js_cocos2dx_Director_isCullingEnabled));
    cls->defineFunction("setGLDefaultValues", _SE(js_cocos2dx_Director_setGLDefaultValues));
    cls->defineFunction("setActionManager", _SE(js_cocos2dx_Director_setActionManager));
    cls->defineFunction("setAlphaBlending", _SE(js_cocos2dx_Director_setAlphaBlending));
    cls->defineFunction("popToRootScene", _SE(js_cocos2dx_Director_popToRootScene));
    cls->defineFunction("loadMatrix", _SE(js_cocos2dx_Director_loadMatrix));
    cls->defineFunction("setCullingEnabled", _SE(js_cocos2dx_Director_setCullingEnabled));
    cls->defineFunction("getNotificationNode", _SE(js_cocos2dx_Director_getNotificationNode));
    cls->defineFunction("getWinSize", _SE(js_cocos2dx_Director_getWinSize));
    cls->defineFunction("end", _SE(js_cocos2dx_Director_end));
    cls->defineFunction("getTextureCache", _SE(js_cocos2dx_Director_getTextureCache));
    cls->defineFunction("isSendCleanupToScene", _SE(js_cocos2dx_Director_isSendCleanupToScene));
    cls->defineFunction("getVisibleOrigin", _SE(js_cocos2dx_Director_getVisibleOrigin));
    cls->defineFunction("mainLoop", _SE(js_cocos2dx_Director_mainLoop));
    cls->defineFunction("setDepthTest", _SE(js_cocos2dx_Director_setDepthTest));
    cls->defineFunction("getFrameRate", _SE(js_cocos2dx_Director_getFrameRate));
    cls->defineFunction("getSecondsPerFrame", _SE(js_cocos2dx_Director_getSecondsPerFrame));
    cls->defineFunction("resetMatrixStack", _SE(js_cocos2dx_Director_resetMatrixStack));
    cls->defineFunction("convertToUI", _SE(js_cocos2dx_Director_convertToUI));
    cls->defineFunction("pushMatrix", _SE(js_cocos2dx_Director_pushMatrix));
    cls->defineFunction("setDefaultValues", _SE(js_cocos2dx_Director_setDefaultValues));
    cls->defineFunction("init", _SE(js_cocos2dx_Director_init));
    cls->defineFunction("setScheduler", _SE(js_cocos2dx_Director_setScheduler));
    cls->defineFunction("getMatrix", _SE(js_cocos2dx_Director_getMatrix));
    cls->defineFunction("isValid", _SE(js_cocos2dx_Director_isValid));
    cls->defineFunction("startAnimation", _SE(js_cocos2dx_Director_startAnimation));
    cls->defineFunction("getOpenGLView", _SE(js_cocos2dx_Director_getOpenGLView));
    cls->defineFunction("getRunningScene", _SE(js_cocos2dx_Director_getRunningScene));
    cls->defineFunction("setViewport", _SE(js_cocos2dx_Director_setViewport));
    cls->defineFunction("stopAnimation", _SE(js_cocos2dx_Director_stopAnimation));
    cls->defineFunction("popToSceneStackLevel", _SE(js_cocos2dx_Director_popToSceneStackLevel));
    cls->defineFunction("resume", _SE(js_cocos2dx_Director_resume));
    cls->defineFunction("isNextDeltaTimeZero", _SE(js_cocos2dx_Director_isNextDeltaTimeZero));
    cls->defineFunction("setClearColor", _SE(js_cocos2dx_Director_setClearColor));
    cls->defineFunction("setOpenGLView", _SE(js_cocos2dx_Director_setOpenGLView));
    cls->defineFunction("convertToGL", _SE(js_cocos2dx_Director_convertToGL));
    cls->defineFunction("purgeCachedData", _SE(js_cocos2dx_Director_purgeCachedData));
    cls->defineFunction("getTotalFrames", _SE(js_cocos2dx_Director_getTotalFrames));
    cls->defineFunction("runWithScene", _SE(js_cocos2dx_Director_runWithScene));
    cls->defineFunction("setNotificationNode", _SE(js_cocos2dx_Director_setNotificationNode));
    cls->defineFunction("drawScene", _SE(js_cocos2dx_Director_drawScene));
    cls->defineFunction("restart", _SE(js_cocos2dx_Director_restart));
    cls->defineFunction("popScene", _SE(js_cocos2dx_Director_popScene));
    cls->defineFunction("loadIdentityMatrix", _SE(js_cocos2dx_Director_loadIdentityMatrix));
    cls->defineFunction("isDisplayStats", _SE(js_cocos2dx_Director_isDisplayStats));
    cls->defineFunction("setProjection", _SE(js_cocos2dx_Director_setProjection));
    cls->defineFunction("multiplyMatrix", _SE(js_cocos2dx_Director_multiplyMatrix));
    cls->defineFunction("getZEye", _SE(js_cocos2dx_Director_getZEye));
    cls->defineFunction("setNextDeltaTimeZero", _SE(js_cocos2dx_Director_setNextDeltaTimeZero));
    cls->defineFunction("popMatrix", _SE(js_cocos2dx_Director_popMatrix));
    cls->defineFunction("getVisibleSize", _SE(js_cocos2dx_Director_getVisibleSize));
    cls->defineFunction("getScheduler", _SE(js_cocos2dx_Director_getScheduler));
    cls->defineFunction("pushScene", _SE(js_cocos2dx_Director_pushScene));
    cls->defineFunction("getAnimationInterval", _SE(js_cocos2dx_Director_getAnimationInterval));
    cls->defineFunction("isPaused", _SE(js_cocos2dx_Director_isPaused));
    cls->defineFunction("setDisplayStats", _SE(js_cocos2dx_Director_setDisplayStats));
    cls->defineFunction("getEventDispatcher", _SE(js_cocos2dx_Director_getEventDispatcher));
    cls->defineFunction("replaceScene", _SE(js_cocos2dx_Director_replaceScene));
    cls->defineFunction("setAnimationInterval", _SE(js_cocos2dx_Director_setAnimationInterval));
    cls->defineFunction("getActionManager", _SE(js_cocos2dx_Director_getActionManager));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Director_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Director>(cls);

    __jsb_cocos2d_Director_proto = cls->getProto();
    __jsb_cocos2d_Director_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Scheduler_proto = nullptr;
se::Class* __jsb_cocos2d_Scheduler_class = nullptr;

static bool js_cocos2dx_Scheduler_setTimeScale(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_setTimeScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_setTimeScale : Error processing arguments");
        cobj->setTimeScale(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_setTimeScale)

static bool js_cocos2dx_Scheduler_isCurrentTargetSalvaged(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_isCurrentTargetSalvaged : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCurrentTargetSalvaged();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_isCurrentTargetSalvaged : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_isCurrentTargetSalvaged)

static bool js_cocos2dx_Scheduler_update(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_update)

static bool js_cocos2dx_Scheduler_unscheduleScriptEntry(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleScriptEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_unscheduleScriptEntry : Error processing arguments");
        cobj->unscheduleScriptEntry(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleScriptEntry)

static bool js_cocos2dx_Scheduler_unscheduleAll(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleAll : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unscheduleAll();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleAll)

static bool js_cocos2dx_Scheduler_getTimeScale(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_getTimeScale : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTimeScale();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_getTimeScale : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_getTimeScale)

static bool js_cocos2dx_Scheduler_unscheduleAllWithMinPriority(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_unscheduleAllWithMinPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Scheduler_unscheduleAllWithMinPriority : Error processing arguments");
        cobj->unscheduleAllWithMinPriority(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_unscheduleAllWithMinPriority)

static bool js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread(se::State& s)
{
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllFunctionsToBePerformedInCocosThread();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Scheduler_finalize)

static bool js_cocos2dx_Scheduler_constructor(se::State& s)
{
    cocos2d::Scheduler* cobj = new (std::nothrow) cocos2d::Scheduler();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Scheduler_constructor, __jsb_cocos2d_Scheduler_class, js_cocos2d_Scheduler_finalize)




static bool js_cocos2d_Scheduler_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Scheduler)", s.nativeThisObject());
    cocos2d::Scheduler* cobj = (cocos2d::Scheduler*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Scheduler_finalize)

bool js_register_cocos2dx_Scheduler(se::Object* obj)
{
    auto cls = se::Class::create("Scheduler", obj, nullptr, _SE(js_cocos2dx_Scheduler_constructor));

    cls->defineFunction("setTimeScale", _SE(js_cocos2dx_Scheduler_setTimeScale));
    cls->defineFunction("isCurrentTargetSalvaged", _SE(js_cocos2dx_Scheduler_isCurrentTargetSalvaged));
    cls->defineFunction("update", _SE(js_cocos2dx_Scheduler_update));
    cls->defineFunction("unscheduleScriptEntry", _SE(js_cocos2dx_Scheduler_unscheduleScriptEntry));
    cls->defineFunction("unscheduleAll", _SE(js_cocos2dx_Scheduler_unscheduleAll));
    cls->defineFunction("getTimeScale", _SE(js_cocos2dx_Scheduler_getTimeScale));
    cls->defineFunction("unscheduleAllWithMinPriority", _SE(js_cocos2dx_Scheduler_unscheduleAllWithMinPriority));
    cls->defineFunction("removeAllFunctionsToBePerformedInCocosThread", _SE(js_cocos2dx_Scheduler_removeAllFunctionsToBePerformedInCocosThread));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Scheduler_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Scheduler>(cls);

    __jsb_cocos2d_Scheduler_proto = cls->getProto();
    __jsb_cocos2d_Scheduler_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_AsyncTaskPool_proto = nullptr;
se::Class* __jsb_cocos2d_AsyncTaskPool_class = nullptr;

static bool js_cocos2dx_AsyncTaskPool_stopTasks(se::State& s)
{
    cocos2d::AsyncTaskPool* cobj = (cocos2d::AsyncTaskPool*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AsyncTaskPool_stopTasks : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::AsyncTaskPool::TaskType arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AsyncTaskPool_stopTasks : Error processing arguments");
        cobj->stopTasks(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_stopTasks)

static bool js_cocos2dx_AsyncTaskPool_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::AsyncTaskPool::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_destroyInstance)

static bool js_cocos2dx_AsyncTaskPool_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::AsyncTaskPool* result = cocos2d::AsyncTaskPool::getInstance();
        ok &= native_ptr_to_seval<cocos2d::AsyncTaskPool>((cocos2d::AsyncTaskPool*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AsyncTaskPool_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AsyncTaskPool_getInstance)




bool js_register_cocos2dx_AsyncTaskPool(se::Object* obj)
{
    auto cls = se::Class::create("AsyncTaskPool", obj, nullptr, nullptr);

    cls->defineFunction("stopTasks", _SE(js_cocos2dx_AsyncTaskPool_stopTasks));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_AsyncTaskPool_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_AsyncTaskPool_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::AsyncTaskPool>(cls);

    __jsb_cocos2d_AsyncTaskPool_proto = cls->getProto();
    __jsb_cocos2d_AsyncTaskPool_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Configuration_proto = nullptr;
se::Class* __jsb_cocos2d_Configuration_class = nullptr;

static bool js_cocos2dx_Configuration_supportsPVRTC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsPVRTC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsPVRTC();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsPVRTC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsPVRTC)

static bool js_cocos2dx_Configuration_supportsOESDepth24(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsOESDepth24 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsOESDepth24();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsOESDepth24 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsOESDepth24)

static bool js_cocos2dx_Configuration_getMaxModelviewStackDepth(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxModelviewStackDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxModelviewStackDepth();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxModelviewStackDepth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxModelviewStackDepth)

static bool js_cocos2dx_Configuration_supportsShareableVAO(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsShareableVAO : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsShareableVAO();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsShareableVAO : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsShareableVAO)

static bool js_cocos2dx_Configuration_supportsBGRA8888(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsBGRA8888 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsBGRA8888();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsBGRA8888 : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsBGRA8888)

static bool js_cocos2dx_Configuration_checkForGLExtension(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_checkForGLExtension : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_checkForGLExtension : Error processing arguments");
        bool result = cobj->checkForGLExtension(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_checkForGLExtension : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_checkForGLExtension)

static bool js_cocos2dx_Configuration_supportsNPOT(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsNPOT : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsNPOT();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsNPOT : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsNPOT)

static bool js_cocos2dx_Configuration_init(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_init)

static bool js_cocos2dx_Configuration_getMaxSupportPointLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportPointLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportPointLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportPointLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportPointLightInShader)

static bool js_cocos2dx_Configuration_getMaxTextureSize(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxTextureSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxTextureSize();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxTextureSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxTextureSize)

static bool js_cocos2dx_Configuration_setValue(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_setValue : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::Value arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ccvalue(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_setValue : Error processing arguments");
        cobj->setValue(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_setValue)

static bool js_cocos2dx_Configuration_getMaxSupportSpotLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportSpotLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportSpotLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportSpotLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportSpotLightInShader)

static bool js_cocos2dx_Configuration_supportsETC(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsETC : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsETC();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsETC : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsETC)

static bool js_cocos2dx_Configuration_getMaxSupportDirLightInShader(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxSupportDirLightInShader : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxSupportDirLightInShader();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxSupportDirLightInShader : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxSupportDirLightInShader)

static bool js_cocos2dx_Configuration_loadConfigFile(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_loadConfigFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_loadConfigFile : Error processing arguments");
        cobj->loadConfigFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_loadConfigFile)

static bool js_cocos2dx_Configuration_supportsDiscardFramebuffer(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsDiscardFramebuffer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsDiscardFramebuffer();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsDiscardFramebuffer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsDiscardFramebuffer)

static bool js_cocos2dx_Configuration_supportsOESPackedDepthStencil(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsOESPackedDepthStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsOESPackedDepthStencil();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsOESPackedDepthStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsOESPackedDepthStencil)

static bool js_cocos2dx_Configuration_getInfo(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getInfo();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getInfo)

static bool js_cocos2dx_Configuration_getMaxTextureUnits(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getMaxTextureUnits : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMaxTextureUnits();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getMaxTextureUnits : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getMaxTextureUnits)

static bool js_cocos2dx_Configuration_getValue(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_getValue : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        const cocos2d::Value& result = cobj->getValue(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        cocos2d::Value arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ccvalue(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        const cocos2d::Value& result = cobj->getValue(arg0, arg1);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_getValue : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getValue)

static bool js_cocos2dx_Configuration_gatherGPUInfo(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_gatherGPUInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->gatherGPUInfo();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_gatherGPUInfo)

static bool js_cocos2dx_Configuration_supportsMapBuffer(se::State& s)
{
    cocos2d::Configuration* cobj = (cocos2d::Configuration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Configuration_supportsMapBuffer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->supportsMapBuffer();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Configuration_supportsMapBuffer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_supportsMapBuffer)

static bool js_cocos2dx_Configuration_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::Configuration::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_destroyInstance)

static bool js_cocos2dx_Configuration_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Configuration::getInstance();
        se::Value instanceVal;
        native_ptr_to_seval<cocos2d::Configuration>(result, __jsb_cocos2d_Configuration_class, &instanceVal);
        instanceVal.toObject()->root();
        s.rval() = instanceVal;
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Configuration_getInstance)




bool js_register_cocos2dx_Configuration(se::Object* obj)
{
    auto cls = se::Class::create("Configuration", obj, nullptr, nullptr);

    cls->defineFunction("supportsPVRTC", _SE(js_cocos2dx_Configuration_supportsPVRTC));
    cls->defineFunction("supportsOESDepth24", _SE(js_cocos2dx_Configuration_supportsOESDepth24));
    cls->defineFunction("getMaxModelviewStackDepth", _SE(js_cocos2dx_Configuration_getMaxModelviewStackDepth));
    cls->defineFunction("supportsShareableVAO", _SE(js_cocos2dx_Configuration_supportsShareableVAO));
    cls->defineFunction("supportsBGRA8888", _SE(js_cocos2dx_Configuration_supportsBGRA8888));
    cls->defineFunction("checkForGLExtension", _SE(js_cocos2dx_Configuration_checkForGLExtension));
    cls->defineFunction("supportsNPOT", _SE(js_cocos2dx_Configuration_supportsNPOT));
    cls->defineFunction("init", _SE(js_cocos2dx_Configuration_init));
    cls->defineFunction("getMaxSupportPointLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportPointLightInShader));
    cls->defineFunction("getMaxTextureSize", _SE(js_cocos2dx_Configuration_getMaxTextureSize));
    cls->defineFunction("setValue", _SE(js_cocos2dx_Configuration_setValue));
    cls->defineFunction("getMaxSupportSpotLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportSpotLightInShader));
    cls->defineFunction("supportsETC", _SE(js_cocos2dx_Configuration_supportsETC));
    cls->defineFunction("getMaxSupportDirLightInShader", _SE(js_cocos2dx_Configuration_getMaxSupportDirLightInShader));
    cls->defineFunction("loadConfigFile", _SE(js_cocos2dx_Configuration_loadConfigFile));
    cls->defineFunction("supportsDiscardFramebuffer", _SE(js_cocos2dx_Configuration_supportsDiscardFramebuffer));
    cls->defineFunction("supportsOESPackedDepthStencil", _SE(js_cocos2dx_Configuration_supportsOESPackedDepthStencil));
    cls->defineFunction("dumpInfo", _SE(js_cocos2dx_Configuration_getInfo));
    cls->defineFunction("getMaxTextureUnits", _SE(js_cocos2dx_Configuration_getMaxTextureUnits));
    cls->defineFunction("getValue", _SE(js_cocos2dx_Configuration_getValue));
    cls->defineFunction("gatherGPUInfo", _SE(js_cocos2dx_Configuration_gatherGPUInfo));
    cls->defineFunction("supportsMapBuffer", _SE(js_cocos2dx_Configuration_supportsMapBuffer));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_Configuration_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Configuration_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Configuration>(cls);

    __jsb_cocos2d_Configuration_proto = cls->getProto();
    __jsb_cocos2d_Configuration_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FileUtils_proto = nullptr;
se::Class* __jsb_cocos2d_FileUtils_class = nullptr;

static bool js_cocos2dx_FileUtils_writeDataToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeDataToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Data arg0;
        std::string arg1;
        ok &= seval_to_Data(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeDataToFile : Error processing arguments");
        bool result = cobj->writeDataToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeDataToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeDataToFile)

static bool js_cocos2dx_FileUtils_fullPathForFilename(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_fullPathForFilename : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathForFilename : Error processing arguments");
        std::string result = cobj->fullPathForFilename(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathForFilename : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_fullPathForFilename)

static bool js_cocos2dx_FileUtils_getStringFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getStringFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getStringFromFile : Error processing arguments");
        std::string result = cobj->getStringFromFile(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getStringFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getStringFromFile)

static bool js_cocos2dx_FileUtils_removeFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_removeFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeFile : Error processing arguments");
        bool result = cobj->removeFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_removeFile)

static bool js_cocos2dx_FileUtils_getDataFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getDataFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getDataFromFile : Error processing arguments");
        cocos2d::Data result = cobj->getDataFromFile(arg0);
        ok &= Data_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getDataFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getDataFromFile)

static bool js_cocos2dx_FileUtils_isAbsolutePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isAbsolutePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isAbsolutePath : Error processing arguments");
        bool result = cobj->isAbsolutePath(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isAbsolutePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isAbsolutePath)

static bool js_cocos2dx_FileUtils_renameFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_FileUtils_renameFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->renameFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_renameFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->renameFile(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_renameFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_renameFile)

static bool js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile : Error processing arguments");
        cobj->loadFilenameLookupDictionaryFromFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile)

static bool js_cocos2dx_FileUtils_isPopupNotify(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isPopupNotify : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPopupNotify();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isPopupNotify : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isPopupNotify)

static bool js_cocos2dx_FileUtils_getValueVectorFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Error processing arguments");
        cocos2d::ValueVector result = cobj->getValueVectorFromFile(arg0);
        ok &= ccvaluevector_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueVectorFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueVectorFromFile)

static bool js_cocos2dx_FileUtils_getSearchPaths(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSearchPaths : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<std::string>& result = cobj->getSearchPaths();
        ok &= std_vector_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSearchPaths : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSearchPaths)

static bool js_cocos2dx_FileUtils_writeToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ValueMap arg0;
        std::string arg1;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeToFile : Error processing arguments");
        bool result = cobj->writeToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeToFile)

static bool js_cocos2dx_FileUtils_listFiles(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_listFiles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFiles : Error processing arguments");
        std::vector<std::string> result = cobj->listFiles(arg0);
        ok &= std_vector_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFiles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_listFiles)

static bool js_cocos2dx_FileUtils_getValueMapFromFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Error processing arguments");
        cocos2d::ValueMap result = cobj->getValueMapFromFile(arg0);
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueMapFromFile)

static bool js_cocos2dx_FileUtils_getFileSize(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getFileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileSize : Error processing arguments");
        long result = cobj->getFileSize(arg0);
        ok &= long_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getFileSize)

static bool js_cocos2dx_FileUtils_getValueMapFromData(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getValueMapFromData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        const char* arg0 = nullptr;
        int arg1 = 0;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromData : Error processing arguments");
        cocos2d::ValueMap result = cobj->getValueMapFromData(arg0, arg1);
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getValueMapFromData : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getValueMapFromData)

static bool js_cocos2dx_FileUtils_removeDirectory(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_removeDirectory : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeDirectory : Error processing arguments");
        bool result = cobj->removeDirectory(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_removeDirectory : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_removeDirectory)

static bool js_cocos2dx_FileUtils_setSearchPaths(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setSearchPaths : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::vector<std::string> arg0;
        ok &= seval_to_std_vector_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setSearchPaths : Error processing arguments");
        cobj->setSearchPaths(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setSearchPaths)

static bool js_cocos2dx_FileUtils_writeStringToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeStringToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeStringToFile : Error processing arguments");
        bool result = cobj->writeStringToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeStringToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeStringToFile)

static bool js_cocos2dx_FileUtils_setSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::vector<std::string> arg0;
        ok &= seval_to_std_vector_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setSearchResolutionsOrder : Error processing arguments");
        cobj->setSearchResolutionsOrder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_addSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing arguments");
        cobj->addSearchResolutionsOrder(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchResolutionsOrder : Error processing arguments");
        cobj->addSearchResolutionsOrder(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_addSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_addSearchPath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_addSearchPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchPath : Error processing arguments");
        cobj->addSearchPath(arg0);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_addSearchPath : Error processing arguments");
        cobj->addSearchPath(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_addSearchPath)

static bool js_cocos2dx_FileUtils_writeValueVectorToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeValueVectorToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ValueVector arg0;
        std::string arg1;
        ok &= seval_to_ccvaluevector(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueVectorToFile : Error processing arguments");
        bool result = cobj->writeValueVectorToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueVectorToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeValueVectorToFile)

static bool js_cocos2dx_FileUtils_isFileExist(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isFileExist : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isFileExist : Error processing arguments");
        bool result = cobj->isFileExist(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isFileExist : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isFileExist)

static bool js_cocos2dx_FileUtils_purgeCachedEntries(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_purgeCachedEntries : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->purgeCachedEntries();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_purgeCachedEntries)

static bool js_cocos2dx_FileUtils_fullPathFromRelativeFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Error processing arguments");
        std::string result = cobj->fullPathFromRelativeFile(arg0, arg1);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_fullPathFromRelativeFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_fullPathFromRelativeFile)

static bool js_cocos2dx_FileUtils_getSuitableFOpen(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Error processing arguments");
        std::string result = cobj->getSuitableFOpen(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSuitableFOpen : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSuitableFOpen)

static bool js_cocos2dx_FileUtils_writeValueMapToFile(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_writeValueMapToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ValueMap arg0;
        std::string arg1;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueMapToFile : Error processing arguments");
        bool result = cobj->writeValueMapToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_writeValueMapToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_writeValueMapToFile)

static bool js_cocos2dx_FileUtils_getFileExtension(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getFileExtension : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileExtension : Error processing arguments");
        std::string result = cobj->getFileExtension(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getFileExtension : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getFileExtension)

static bool js_cocos2dx_FileUtils_setWritablePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setWritablePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setWritablePath : Error processing arguments");
        cobj->setWritablePath(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setWritablePath)

static bool js_cocos2dx_FileUtils_setPopupNotify(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setPopupNotify : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setPopupNotify : Error processing arguments");
        cobj->setPopupNotify(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setPopupNotify)

static bool js_cocos2dx_FileUtils_isDirectoryExist(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_isDirectoryExist : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isDirectoryExist : Error processing arguments");
        bool result = cobj->isDirectoryExist(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_isDirectoryExist : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_isDirectoryExist)

static bool js_cocos2dx_FileUtils_setDefaultResourceRootPath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_setDefaultResourceRootPath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setDefaultResourceRootPath : Error processing arguments");
        cobj->setDefaultResourceRootPath(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setDefaultResourceRootPath)

static bool js_cocos2dx_FileUtils_getSearchResolutionsOrder(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getSearchResolutionsOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::vector<std::string>& result = cobj->getSearchResolutionsOrder();
        ok &= std_vector_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getSearchResolutionsOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getSearchResolutionsOrder)

static bool js_cocos2dx_FileUtils_createDirectory(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_createDirectory : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_createDirectory : Error processing arguments");
        bool result = cobj->createDirectory(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_createDirectory : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_createDirectory)

static bool js_cocos2dx_FileUtils_listFilesRecursively(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_listFilesRecursively : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::vector<std::basic_string<char>, std::allocator<std::basic_string<char> > >* arg1 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_listFilesRecursively : Error processing arguments");
        cobj->listFilesRecursively(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_listFilesRecursively)

static bool js_cocos2dx_FileUtils_getWritablePath(se::State& s)
{
    cocos2d::FileUtils* cobj = (cocos2d::FileUtils*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FileUtils_getWritablePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getWritablePath();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getWritablePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getWritablePath)

static bool js_cocos2dx_FileUtils_setDelegate(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FileUtils* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_setDelegate : Error processing arguments");
        cocos2d::FileUtils::setDelegate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_setDelegate)

static bool js_cocos2dx_FileUtils_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::FileUtils* result = cocos2d::FileUtils::getInstance();
        ok &= native_ptr_to_seval<cocos2d::FileUtils>((cocos2d::FileUtils*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FileUtils_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FileUtils_getInstance)




bool js_register_cocos2dx_FileUtils(se::Object* obj)
{
    auto cls = se::Class::create("FileUtils", obj, nullptr, nullptr);

    cls->defineFunction("writeDataToFile", _SE(js_cocos2dx_FileUtils_writeDataToFile));
    cls->defineFunction("fullPathForFilename", _SE(js_cocos2dx_FileUtils_fullPathForFilename));
    cls->defineFunction("getStringFromFile", _SE(js_cocos2dx_FileUtils_getStringFromFile));
    cls->defineFunction("removeFile", _SE(js_cocos2dx_FileUtils_removeFile));
    cls->defineFunction("getDataFromFile", _SE(js_cocos2dx_FileUtils_getDataFromFile));
    cls->defineFunction("isAbsolutePath", _SE(js_cocos2dx_FileUtils_isAbsolutePath));
    cls->defineFunction("renameFile", _SE(js_cocos2dx_FileUtils_renameFile));
    cls->defineFunction("loadFilenameLookup", _SE(js_cocos2dx_FileUtils_loadFilenameLookupDictionaryFromFile));
    cls->defineFunction("isPopupNotify", _SE(js_cocos2dx_FileUtils_isPopupNotify));
    cls->defineFunction("getValueVectorFromFile", _SE(js_cocos2dx_FileUtils_getValueVectorFromFile));
    cls->defineFunction("getSearchPaths", _SE(js_cocos2dx_FileUtils_getSearchPaths));
    cls->defineFunction("writeToFile", _SE(js_cocos2dx_FileUtils_writeToFile));
    cls->defineFunction("listFiles", _SE(js_cocos2dx_FileUtils_listFiles));
    cls->defineFunction("getValueMapFromFile", _SE(js_cocos2dx_FileUtils_getValueMapFromFile));
    cls->defineFunction("getFileSize", _SE(js_cocos2dx_FileUtils_getFileSize));
    cls->defineFunction("getValueMapFromData", _SE(js_cocos2dx_FileUtils_getValueMapFromData));
    cls->defineFunction("removeDirectory", _SE(js_cocos2dx_FileUtils_removeDirectory));
    cls->defineFunction("setSearchPaths", _SE(js_cocos2dx_FileUtils_setSearchPaths));
    cls->defineFunction("writeStringToFile", _SE(js_cocos2dx_FileUtils_writeStringToFile));
    cls->defineFunction("setSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_setSearchResolutionsOrder));
    cls->defineFunction("addSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_addSearchResolutionsOrder));
    cls->defineFunction("addSearchPath", _SE(js_cocos2dx_FileUtils_addSearchPath));
    cls->defineFunction("writeValueVectorToFile", _SE(js_cocos2dx_FileUtils_writeValueVectorToFile));
    cls->defineFunction("isFileExist", _SE(js_cocos2dx_FileUtils_isFileExist));
    cls->defineFunction("purgeCachedEntries", _SE(js_cocos2dx_FileUtils_purgeCachedEntries));
    cls->defineFunction("fullPathFromRelativeFile", _SE(js_cocos2dx_FileUtils_fullPathFromRelativeFile));
    cls->defineFunction("getSuitableFOpen", _SE(js_cocos2dx_FileUtils_getSuitableFOpen));
    cls->defineFunction("writeValueMapToFile", _SE(js_cocos2dx_FileUtils_writeValueMapToFile));
    cls->defineFunction("getFileExtension", _SE(js_cocos2dx_FileUtils_getFileExtension));
    cls->defineFunction("setWritablePath", _SE(js_cocos2dx_FileUtils_setWritablePath));
    cls->defineFunction("setPopupNotify", _SE(js_cocos2dx_FileUtils_setPopupNotify));
    cls->defineFunction("isDirectoryExist", _SE(js_cocos2dx_FileUtils_isDirectoryExist));
    cls->defineFunction("setDefaultResourceRootPath", _SE(js_cocos2dx_FileUtils_setDefaultResourceRootPath));
    cls->defineFunction("getSearchResolutionsOrder", _SE(js_cocos2dx_FileUtils_getSearchResolutionsOrder));
    cls->defineFunction("createDirectory", _SE(js_cocos2dx_FileUtils_createDirectory));
    cls->defineFunction("listFilesRecursively", _SE(js_cocos2dx_FileUtils_listFilesRecursively));
    cls->defineFunction("getWritablePath", _SE(js_cocos2dx_FileUtils_getWritablePath));
    cls->defineStaticFunction("setDelegate", _SE(js_cocos2dx_FileUtils_setDelegate));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_FileUtils_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::FileUtils>(cls);

    __jsb_cocos2d_FileUtils_proto = cls->getProto();
    __jsb_cocos2d_FileUtils_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventAcceleration_proto = nullptr;
se::Class* __jsb_cocos2d_EventAcceleration_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventAcceleration_finalize)

static bool js_cocos2dx_EventAcceleration_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::Acceleration arg0;
    ok &= seval_to_Acceleration(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_EventAcceleration_constructor : Error processing arguments");
    cocos2d::EventAcceleration* cobj = new (std::nothrow) cocos2d::EventAcceleration(arg0);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventAcceleration_constructor, __jsb_cocos2d_EventAcceleration_class, js_cocos2d_EventAcceleration_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

static bool js_cocos2d_EventAcceleration_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventAcceleration)", s.nativeThisObject());
    cocos2d::EventAcceleration* cobj = (cocos2d::EventAcceleration*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventAcceleration_finalize)

bool js_register_cocos2dx_EventAcceleration(se::Object* obj)
{
    auto cls = se::Class::create("EventAcceleration", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventAcceleration_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_EventAcceleration_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventAcceleration>(cls);

    __jsb_cocos2d_EventAcceleration_proto = cls->getProto();
    __jsb_cocos2d_EventAcceleration_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventCustom_proto = nullptr;
se::Class* __jsb_cocos2d_EventCustom_class = nullptr;

static bool js_cocos2dx_EventCustom_getEventName(se::State& s)
{
    cocos2d::EventCustom* cobj = (cocos2d::EventCustom*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventCustom_getEventName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getEventName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventCustom_getEventName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventCustom_getEventName)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventCustom_finalize)

static bool js_cocos2dx_EventCustom_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    std::string arg0;
    ok &= seval_to_std_string(args[0], &arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_EventCustom_constructor : Error processing arguments");
    cocos2d::EventCustom* cobj = new (std::nothrow) cocos2d::EventCustom(arg0);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventCustom_constructor, __jsb_cocos2d_EventCustom_class, js_cocos2d_EventCustom_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

static bool js_cocos2d_EventCustom_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventCustom)", s.nativeThisObject());
    cocos2d::EventCustom* cobj = (cocos2d::EventCustom*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventCustom_finalize)

bool js_register_cocos2dx_EventCustom(se::Object* obj)
{
    auto cls = se::Class::create("EventCustom", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventCustom_constructor));

    cls->defineFunction("getEventName", _SE(js_cocos2dx_EventCustom_getEventName));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventCustom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventCustom>(cls);

    __jsb_cocos2d_EventCustom_proto = cls->getProto();
    __jsb_cocos2d_EventCustom_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListener_proto = nullptr;
se::Class* __jsb_cocos2d_EventListener_class = nullptr;

static bool js_cocos2dx_EventListener_setEnabled(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_setEnabled)

static bool js_cocos2dx_EventListener_isEnabled(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_isEnabled)

static bool js_cocos2dx_EventListener_clone(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::EventListener* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::EventListener>((cocos2d::EventListener*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_clone)

static bool js_cocos2dx_EventListener_checkAvailable(se::State& s)
{
    cocos2d::EventListener* cobj = (cocos2d::EventListener*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListener_checkAvailable : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->checkAvailable();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListener_checkAvailable : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListener_checkAvailable)




bool js_register_cocos2dx_EventListener(se::Object* obj)
{
    auto cls = se::Class::create("EventListener", obj, nullptr, nullptr);

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_EventListener_setEnabled));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_EventListener_isEnabled));
    cls->defineFunction("clone", _SE(js_cocos2dx_EventListener_clone));
    cls->defineFunction("checkAvailable", _SE(js_cocos2dx_EventListener_checkAvailable));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListener>(cls);

    __jsb_cocos2d_EventListener_proto = cls->getProto();
    __jsb_cocos2d_EventListener_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventDispatcher_proto = nullptr;
se::Class* __jsb_cocos2d_EventDispatcher_class = nullptr;

static bool js_cocos2dx_EventDispatcher_setEnabled(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_setEnabled)

static bool js_cocos2dx_EventDispatcher_removeAllEventListeners(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeAllEventListeners : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllEventListeners();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeAllEventListeners)

static bool js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority : Error processing arguments");
        cobj->addEventListenerWithSceneGraphPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority)

static bool js_cocos2dx_EventDispatcher_addCustomEventListener(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_addCustomEventListener : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::EventCustom *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsFunc.toObject()->root();
                auto lambda = [=](cocos2d::EventCustom* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::EventCustom>((cocos2d::EventCustom*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addCustomEventListener : Error processing arguments");
        cocos2d::EventListenerCustom* result = cobj->addCustomEventListener(arg0, arg1);
        ok &= native_ptr_to_seval<cocos2d::EventListenerCustom>((cocos2d::EventListenerCustom*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addCustomEventListener : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_addCustomEventListener)

static bool js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority : Error processing arguments");
        cobj->addEventListenerWithFixedPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority)

static bool js_cocos2dx_EventDispatcher_removeEventListenersForTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_EventDispatcher_removeEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->removeEventListenersForTarget(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cobj->removeEventListenersForTarget(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::EventListener::Type arg0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cobj->removeEventListenersForType(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_resumeEventListenersForTarget(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing arguments");
        cobj->resumeEventListenersForTarget(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_resumeEventListenersForTarget : Error processing arguments");
        cobj->resumeEventListenersForTarget(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_resumeEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_setPriority(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_setPriority : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::EventListener* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_setPriority : Error processing arguments");
        cobj->setPriority(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_setPriority)

static bool js_cocos2dx_EventDispatcher_dispatchEvent(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_dispatchEvent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Event* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_dispatchEvent : Error processing arguments");
        cobj->dispatchEvent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_dispatchEvent)

static bool js_cocos2dx_EventDispatcher_hasEventListener(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_hasEventListener : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventListener::ListenerID arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_hasEventListener : Error processing arguments");
        bool result = cobj->hasEventListener(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_hasEventListener : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_hasEventListener)

static bool js_cocos2dx_EventDispatcher_pauseEventListenersForTarget(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing arguments");
        cobj->pauseEventListenersForTarget(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_pauseEventListenersForTarget : Error processing arguments");
        cobj->pauseEventListenersForTarget(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_pauseEventListenersForTarget)

static bool js_cocos2dx_EventDispatcher_removeCustomEventListeners(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeCustomEventListeners : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_removeCustomEventListeners : Error processing arguments");
        cobj->removeCustomEventListeners(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeCustomEventListeners)

static bool js_cocos2dx_EventDispatcher_removeEventListener(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_removeEventListener : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventListener* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_removeEventListener : Error processing arguments");
        cobj->removeEventListener(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_removeEventListener)

static bool js_cocos2dx_EventDispatcher_isEnabled(se::State& s)
{
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventDispatcher_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventDispatcher_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventDispatcher_isEnabled)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventDispatcher_finalize)

static bool js_cocos2dx_EventDispatcher_constructor(se::State& s)
{
    cocos2d::EventDispatcher* cobj = new (std::nothrow) cocos2d::EventDispatcher();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventDispatcher_constructor, __jsb_cocos2d_EventDispatcher_class, js_cocos2d_EventDispatcher_finalize)




static bool js_cocos2d_EventDispatcher_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventDispatcher)", s.nativeThisObject());
    cocos2d::EventDispatcher* cobj = (cocos2d::EventDispatcher*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventDispatcher_finalize)

bool js_register_cocos2dx_EventDispatcher(se::Object* obj)
{
    auto cls = se::Class::create("EventDispatcher", obj, nullptr, _SE(js_cocos2dx_EventDispatcher_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_EventDispatcher_setEnabled));
    cls->defineFunction("removeAllListeners", _SE(js_cocos2dx_EventDispatcher_removeAllEventListeners));
    cls->defineFunction("addEventListenerWithSceneGraphPriority", _SE(js_cocos2dx_EventDispatcher_addEventListenerWithSceneGraphPriority));
    cls->defineFunction("addCustomListener", _SE(js_cocos2dx_EventDispatcher_addCustomEventListener));
    cls->defineFunction("addEventListenerWithFixedPriority", _SE(js_cocos2dx_EventDispatcher_addEventListenerWithFixedPriority));
    cls->defineFunction("removeListeners", _SE(js_cocos2dx_EventDispatcher_removeEventListenersForTarget));
    cls->defineFunction("resumeTarget", _SE(js_cocos2dx_EventDispatcher_resumeEventListenersForTarget));
    cls->defineFunction("setPriority", _SE(js_cocos2dx_EventDispatcher_setPriority));
    cls->defineFunction("dispatchEvent", _SE(js_cocos2dx_EventDispatcher_dispatchEvent));
    cls->defineFunction("hasEventListener", _SE(js_cocos2dx_EventDispatcher_hasEventListener));
    cls->defineFunction("pauseTarget", _SE(js_cocos2dx_EventDispatcher_pauseEventListenersForTarget));
    cls->defineFunction("removeCustomListeners", _SE(js_cocos2dx_EventDispatcher_removeCustomEventListeners));
    cls->defineFunction("removeListener", _SE(js_cocos2dx_EventDispatcher_removeEventListener));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_EventDispatcher_isEnabled));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventDispatcher_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventDispatcher>(cls);

    __jsb_cocos2d_EventDispatcher_proto = cls->getProto();
    __jsb_cocos2d_EventDispatcher_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventFocus_proto = nullptr;
se::Class* __jsb_cocos2d_EventFocus_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventFocus_finalize)

static bool js_cocos2dx_EventFocus_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::ui::Widget* arg0 = nullptr;
    cocos2d::ui::Widget* arg1 = nullptr;
    ok &= seval_to_native_ptr(args[0], &arg0);
    ok &= seval_to_native_ptr(args[1], &arg1);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_EventFocus_constructor : Error processing arguments");
    cocos2d::EventFocus* cobj = new (std::nothrow) cocos2d::EventFocus(arg0, arg1);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventFocus_constructor, __jsb_cocos2d_EventFocus_class, js_cocos2d_EventFocus_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

static bool js_cocos2d_EventFocus_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventFocus)", s.nativeThisObject());
    cocos2d::EventFocus* cobj = (cocos2d::EventFocus*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventFocus_finalize)

bool js_register_cocos2dx_EventFocus(se::Object* obj)
{
    auto cls = se::Class::create("EventFocus", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventFocus_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_EventFocus_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventFocus>(cls);

    __jsb_cocos2d_EventFocus_proto = cls->getProto();
    __jsb_cocos2d_EventFocus_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerAcceleration_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerAcceleration_class = nullptr;

static bool js_cocos2dx_EventListenerAcceleration_init(se::State& s)
{
    cocos2d::EventListenerAcceleration* cobj = (cocos2d::EventListenerAcceleration*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerAcceleration_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Acceleration *, cocos2d::Event *)> arg0;
        do {
            if (args[0].isObject() && args[0].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[0]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Acceleration* larg0, cocos2d::Event* larg1) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(2);
                    ok &= Acceleration_to_seval(larg0, &args[0]);
                    ok &= native_ptr_to_seval<cocos2d::Event>((cocos2d::Event*)larg1, &args[1]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg0 = lambda;
            }
            else
            {
                arg0 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerAcceleration_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerAcceleration_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerAcceleration_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerAcceleration_finalize)

static bool js_cocos2dx_EventListenerAcceleration_constructor(se::State& s)
{
    cocos2d::EventListenerAcceleration* cobj = new (std::nothrow) cocos2d::EventListenerAcceleration();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerAcceleration_constructor, __jsb_cocos2d_EventListenerAcceleration_class, js_cocos2d_EventListenerAcceleration_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerAcceleration_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerAcceleration)", s.nativeThisObject());
    cocos2d::EventListenerAcceleration* cobj = (cocos2d::EventListenerAcceleration*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerAcceleration_finalize)

bool js_register_cocos2dx_EventListenerAcceleration(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerAcceleration", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerAcceleration_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerAcceleration_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerAcceleration_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerAcceleration>(cls);

    __jsb_cocos2d_EventListenerAcceleration_proto = cls->getProto();
    __jsb_cocos2d_EventListenerAcceleration_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerCustom_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerCustom_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerCustom_finalize)

static bool js_cocos2dx_EventListenerCustom_constructor(se::State& s)
{
    cocos2d::EventListenerCustom* cobj = new (std::nothrow) cocos2d::EventListenerCustom();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerCustom_constructor, __jsb_cocos2d_EventListenerCustom_class, js_cocos2d_EventListenerCustom_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerCustom_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerCustom)", s.nativeThisObject());
    cocos2d::EventListenerCustom* cobj = (cocos2d::EventListenerCustom*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerCustom_finalize)

bool js_register_cocos2dx_EventListenerCustom(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerCustom", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerCustom_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerCustom_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerCustom>(cls);

    __jsb_cocos2d_EventListenerCustom_proto = cls->getProto();
    __jsb_cocos2d_EventListenerCustom_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerFocus_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerFocus_class = nullptr;

static bool js_cocos2dx_EventListenerFocus_init(se::State& s)
{
    cocos2d::EventListenerFocus* cobj = (cocos2d::EventListenerFocus*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerFocus_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerFocus_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerFocus_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerFocus_finalize)

static bool js_cocos2dx_EventListenerFocus_constructor(se::State& s)
{
    cocos2d::EventListenerFocus* cobj = new (std::nothrow) cocos2d::EventListenerFocus();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerFocus_constructor, __jsb_cocos2d_EventListenerFocus_class, js_cocos2d_EventListenerFocus_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerFocus_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerFocus)", s.nativeThisObject());
    cocos2d::EventListenerFocus* cobj = (cocos2d::EventListenerFocus*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerFocus_finalize)

bool js_register_cocos2dx_EventListenerFocus(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerFocus", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerFocus_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerFocus_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerFocus_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerFocus>(cls);

    __jsb_cocos2d_EventListenerFocus_proto = cls->getProto();
    __jsb_cocos2d_EventListenerFocus_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerKeyboard_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerKeyboard_class = nullptr;

static bool js_cocos2dx_EventListenerKeyboard_init(se::State& s)
{
    cocos2d::EventListenerKeyboard* cobj = (cocos2d::EventListenerKeyboard*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerKeyboard_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerKeyboard_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerKeyboard_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerKeyboard_finalize)

static bool js_cocos2dx_EventListenerKeyboard_constructor(se::State& s)
{
    cocos2d::EventListenerKeyboard* cobj = new (std::nothrow) cocos2d::EventListenerKeyboard();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerKeyboard_constructor, __jsb_cocos2d_EventListenerKeyboard_class, js_cocos2d_EventListenerKeyboard_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerKeyboard_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerKeyboard)", s.nativeThisObject());
    cocos2d::EventListenerKeyboard* cobj = (cocos2d::EventListenerKeyboard*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerKeyboard_finalize)

bool js_register_cocos2dx_EventListenerKeyboard(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerKeyboard", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerKeyboard_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerKeyboard_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerKeyboard_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerKeyboard>(cls);

    __jsb_cocos2d_EventListenerKeyboard_proto = cls->getProto();
    __jsb_cocos2d_EventListenerKeyboard_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventMouse_proto = nullptr;
se::Class* __jsb_cocos2d_EventMouse_class = nullptr;

static bool js_cocos2dx_EventMouse_getMouseButton(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getMouseButton : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMouseButton();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getMouseButton : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getMouseButton)

static bool js_cocos2dx_EventMouse_getLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getLocation)

static bool js_cocos2dx_EventMouse_setMouseButton(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setMouseButton : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setMouseButton : Error processing arguments");
        cobj->setMouseButton(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setMouseButton)

static bool js_cocos2dx_EventMouse_setScrollData(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setScrollData : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setScrollData : Error processing arguments");
        cobj->setScrollData(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setScrollData)

static bool js_cocos2dx_EventMouse_getPreviousLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getPreviousLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getPreviousLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getPreviousLocationInView)

static bool js_cocos2dx_EventMouse_getDelta(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getDelta : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getDelta();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getDelta : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getDelta)

static bool js_cocos2dx_EventMouse_getStartLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getStartLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getStartLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getStartLocation)

static bool js_cocos2dx_EventMouse_getCursorY(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getCursorY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCursorY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getCursorY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getCursorY)

static bool js_cocos2dx_EventMouse_getCursorX(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getCursorX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getCursorX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getCursorX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getCursorX)

static bool js_cocos2dx_EventMouse_getLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getLocationInView)

static bool js_cocos2dx_EventMouse_getScrollY(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getScrollY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScrollY();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getScrollY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getScrollY)

static bool js_cocos2dx_EventMouse_setCursorPosition(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_setCursorPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_setCursorPosition : Error processing arguments");
        cobj->setCursorPosition(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_setCursorPosition)

static bool js_cocos2dx_EventMouse_getScrollX(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getScrollX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getScrollX();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getScrollX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getScrollX)

static bool js_cocos2dx_EventMouse_getPreviousLocation(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getPreviousLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getPreviousLocation();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getPreviousLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getPreviousLocation)

static bool js_cocos2dx_EventMouse_getStartLocationInView(se::State& s)
{
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventMouse_getStartLocationInView : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getStartLocationInView();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_getStartLocationInView : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventMouse_getStartLocationInView)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventMouse_finalize)

static bool js_cocos2dx_EventMouse_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::EventMouse::MouseEventType arg0;
    ok &= seval_to_int32(args[0], (int32_t*)&arg0);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_EventMouse_constructor : Error processing arguments");
    cocos2d::EventMouse* cobj = new (std::nothrow) cocos2d::EventMouse(arg0);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventMouse_constructor, __jsb_cocos2d_EventMouse_class, js_cocos2d_EventMouse_finalize)



extern se::Object* __jsb_cocos2d_Event_proto;

static bool js_cocos2d_EventMouse_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventMouse)", s.nativeThisObject());
    cocos2d::EventMouse* cobj = (cocos2d::EventMouse*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventMouse_finalize)

bool js_register_cocos2dx_EventMouse(se::Object* obj)
{
    auto cls = se::Class::create("EventMouse", obj, __jsb_cocos2d_Event_proto, _SE(js_cocos2dx_EventMouse_constructor));

    cls->defineFunction("getButton", _SE(js_cocos2dx_EventMouse_getMouseButton));
    cls->defineFunction("getLocation", _SE(js_cocos2dx_EventMouse_getLocation));
    cls->defineFunction("setButton", _SE(js_cocos2dx_EventMouse_setMouseButton));
    cls->defineFunction("setScrollData", _SE(js_cocos2dx_EventMouse_setScrollData));
    cls->defineFunction("getPreviousLocationInView", _SE(js_cocos2dx_EventMouse_getPreviousLocationInView));
    cls->defineFunction("getDelta", _SE(js_cocos2dx_EventMouse_getDelta));
    cls->defineFunction("getStartLocation", _SE(js_cocos2dx_EventMouse_getStartLocation));
    cls->defineFunction("getLocationY", _SE(js_cocos2dx_EventMouse_getCursorY));
    cls->defineFunction("getLocationX", _SE(js_cocos2dx_EventMouse_getCursorX));
    cls->defineFunction("getLocationInView", _SE(js_cocos2dx_EventMouse_getLocationInView));
    cls->defineFunction("getScrollY", _SE(js_cocos2dx_EventMouse_getScrollY));
    cls->defineFunction("setLocation", _SE(js_cocos2dx_EventMouse_setCursorPosition));
    cls->defineFunction("getScrollX", _SE(js_cocos2dx_EventMouse_getScrollX));
    cls->defineFunction("getPreviousLocation", _SE(js_cocos2dx_EventMouse_getPreviousLocation));
    cls->defineFunction("getStartLocationInView", _SE(js_cocos2dx_EventMouse_getStartLocationInView));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventMouse_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventMouse>(cls);

    __jsb_cocos2d_EventMouse_proto = cls->getProto();
    __jsb_cocos2d_EventMouse_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerMouse_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerMouse_class = nullptr;

static bool js_cocos2dx_EventListenerMouse_init(se::State& s)
{
    cocos2d::EventListenerMouse* cobj = (cocos2d::EventListenerMouse*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerMouse_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerMouse_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerMouse_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerMouse_finalize)

static bool js_cocos2dx_EventListenerMouse_constructor(se::State& s)
{
    cocos2d::EventListenerMouse* cobj = new (std::nothrow) cocos2d::EventListenerMouse();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerMouse_constructor, __jsb_cocos2d_EventListenerMouse_class, js_cocos2d_EventListenerMouse_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerMouse_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerMouse)", s.nativeThisObject());
    cocos2d::EventListenerMouse* cobj = (cocos2d::EventListenerMouse*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerMouse_finalize)

bool js_register_cocos2dx_EventListenerMouse(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerMouse", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerMouse_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerMouse_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerMouse_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerMouse>(cls);

    __jsb_cocos2d_EventListenerMouse_proto = cls->getProto();
    __jsb_cocos2d_EventListenerMouse_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerTouchOneByOne_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerTouchOneByOne_class = nullptr;

static bool js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSwallowTouches();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches)

static bool js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches : Error processing arguments");
        cobj->setSwallowTouches(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches)

static bool js_cocos2dx_EventListenerTouchOneByOne_init(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchOneByOne_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchOneByOne_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchOneByOne_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerTouchOneByOne_finalize)

static bool js_cocos2dx_EventListenerTouchOneByOne_constructor(se::State& s)
{
    cocos2d::EventListenerTouchOneByOne* cobj = new (std::nothrow) cocos2d::EventListenerTouchOneByOne();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerTouchOneByOne_constructor, __jsb_cocos2d_EventListenerTouchOneByOne_class, js_cocos2d_EventListenerTouchOneByOne_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerTouchOneByOne_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerTouchOneByOne)", s.nativeThisObject());
    cocos2d::EventListenerTouchOneByOne* cobj = (cocos2d::EventListenerTouchOneByOne*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerTouchOneByOne_finalize)

bool js_register_cocos2dx_EventListenerTouchOneByOne(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerTouchOneByOne", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerTouchOneByOne_constructor));

    cls->defineFunction("isSwallowTouches", _SE(js_cocos2dx_EventListenerTouchOneByOne_isSwallowTouches));
    cls->defineFunction("setSwallowTouches", _SE(js_cocos2dx_EventListenerTouchOneByOne_setSwallowTouches));
    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerTouchOneByOne_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerTouchOneByOne_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerTouchOneByOne>(cls);

    __jsb_cocos2d_EventListenerTouchOneByOne_proto = cls->getProto();
    __jsb_cocos2d_EventListenerTouchOneByOne_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EventListenerTouchAllAtOnce_proto = nullptr;
se::Class* __jsb_cocos2d_EventListenerTouchAllAtOnce_class = nullptr;

static bool js_cocos2dx_EventListenerTouchAllAtOnce_init(se::State& s)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = (cocos2d::EventListenerTouchAllAtOnce*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EventListenerTouchAllAtOnce_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EventListenerTouchAllAtOnce_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EventListenerTouchAllAtOnce_init)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EventListenerTouchAllAtOnce_finalize)

static bool js_cocos2dx_EventListenerTouchAllAtOnce_constructor(se::State& s)
{
    cocos2d::EventListenerTouchAllAtOnce* cobj = new (std::nothrow) cocos2d::EventListenerTouchAllAtOnce();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EventListenerTouchAllAtOnce_constructor, __jsb_cocos2d_EventListenerTouchAllAtOnce_class, js_cocos2d_EventListenerTouchAllAtOnce_finalize)



extern se::Object* __jsb_cocos2d_EventListener_proto;

static bool js_cocos2d_EventListenerTouchAllAtOnce_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EventListenerTouchAllAtOnce)", s.nativeThisObject());
    cocos2d::EventListenerTouchAllAtOnce* cobj = (cocos2d::EventListenerTouchAllAtOnce*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EventListenerTouchAllAtOnce_finalize)

bool js_register_cocos2dx_EventListenerTouchAllAtOnce(se::Object* obj)
{
    auto cls = se::Class::create("EventListenerTouchAllAtOnce", obj, __jsb_cocos2d_EventListener_proto, _SE(js_cocos2dx_EventListenerTouchAllAtOnce_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_EventListenerTouchAllAtOnce_init));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EventListenerTouchAllAtOnce_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EventListenerTouchAllAtOnce>(cls);

    __jsb_cocos2d_EventListenerTouchAllAtOnce_proto = cls->getProto();
    __jsb_cocos2d_EventListenerTouchAllAtOnce_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Action_proto = nullptr;
se::Class* __jsb_cocos2d_Action_class = nullptr;

static bool js_cocos2dx_Action_startWithTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_startWithTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_startWithTarget : Error processing arguments");
        cobj->startWithTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_startWithTarget)

static bool js_cocos2dx_Action_setOriginalTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setOriginalTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_setOriginalTarget : Error processing arguments");
        cobj->setOriginalTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setOriginalTarget)

static bool js_cocos2dx_Action_clone(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Action* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_clone)

static bool js_cocos2dx_Action_getOriginalTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getOriginalTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getOriginalTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_getOriginalTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getOriginalTarget)

static bool js_cocos2dx_Action_stop(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_stop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_stop)

static bool js_cocos2dx_Action_getTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getTarget();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_getTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getTarget)

static bool js_cocos2dx_Action_getFlags(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getFlags();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_getFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getFlags)

static bool js_cocos2dx_Action_step(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_step : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_step : Error processing arguments");
        cobj->step(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_step)

static bool js_cocos2dx_Action_setTag(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_setTag : Error processing arguments");
        cobj->setTag(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setTag)

static bool js_cocos2dx_Action_setFlags(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_setFlags : Error processing arguments");
        cobj->setFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setFlags)

static bool js_cocos2dx_Action_getTag(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_getTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTag();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_getTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_getTag)

static bool js_cocos2dx_Action_setTarget(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_setTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_setTarget : Error processing arguments");
        cobj->setTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_setTarget)

static bool js_cocos2dx_Action_isDone(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_isDone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDone();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_isDone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_isDone)

static bool js_cocos2dx_Action_reverse(se::State& s)
{
    cocos2d::Action* cobj = (cocos2d::Action*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Action_reverse : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Action* result = cobj->reverse();
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Action_reverse : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Action_reverse)




bool js_register_cocos2dx_Action(se::Object* obj)
{
    auto cls = se::Class::create("Action", obj, nullptr, nullptr);

    cls->defineFunction("startWithTarget", _SE(js_cocos2dx_Action_startWithTarget));
    cls->defineFunction("setOriginalTarget", _SE(js_cocos2dx_Action_setOriginalTarget));
    cls->defineFunction("clone", _SE(js_cocos2dx_Action_clone));
    cls->defineFunction("getOriginalTarget", _SE(js_cocos2dx_Action_getOriginalTarget));
    cls->defineFunction("stop", _SE(js_cocos2dx_Action_stop));
    cls->defineFunction("getTarget", _SE(js_cocos2dx_Action_getTarget));
    cls->defineFunction("getFlags", _SE(js_cocos2dx_Action_getFlags));
    cls->defineFunction("step", _SE(js_cocos2dx_Action_step));
    cls->defineFunction("setTag", _SE(js_cocos2dx_Action_setTag));
    cls->defineFunction("setFlags", _SE(js_cocos2dx_Action_setFlags));
    cls->defineFunction("getTag", _SE(js_cocos2dx_Action_getTag));
    cls->defineFunction("setTarget", _SE(js_cocos2dx_Action_setTarget));
    cls->defineFunction("isDone", _SE(js_cocos2dx_Action_isDone));
    cls->defineFunction("reverse", _SE(js_cocos2dx_Action_reverse));
    cls->install();
    JSBClassType::registerClass<cocos2d::Action>(cls);

    __jsb_cocos2d_Action_proto = cls->getProto();
    __jsb_cocos2d_Action_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FiniteTimeAction_proto = nullptr;
se::Class* __jsb_cocos2d_FiniteTimeAction_class = nullptr;

static bool js_cocos2dx_FiniteTimeAction_setDuration(se::State& s)
{
    cocos2d::FiniteTimeAction* cobj = (cocos2d::FiniteTimeAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FiniteTimeAction_setDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FiniteTimeAction_setDuration : Error processing arguments");
        cobj->setDuration(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FiniteTimeAction_setDuration)

static bool js_cocos2dx_FiniteTimeAction_getDuration(se::State& s)
{
    cocos2d::FiniteTimeAction* cobj = (cocos2d::FiniteTimeAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FiniteTimeAction_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FiniteTimeAction_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FiniteTimeAction_getDuration)


extern se::Object* __jsb_cocos2d_Action_proto;


bool js_register_cocos2dx_FiniteTimeAction(se::Object* obj)
{
    auto cls = se::Class::create("FiniteTimeAction", obj, __jsb_cocos2d_Action_proto, nullptr);

    cls->defineFunction("setDuration", _SE(js_cocos2dx_FiniteTimeAction_setDuration));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_FiniteTimeAction_getDuration));
    cls->install();
    JSBClassType::registerClass<cocos2d::FiniteTimeAction>(cls);

    __jsb_cocos2d_FiniteTimeAction_proto = cls->getProto();
    __jsb_cocos2d_FiniteTimeAction_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Speed_proto = nullptr;
se::Class* __jsb_cocos2d_Speed_class = nullptr;

static bool js_cocos2dx_Speed_setInnerAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_setInnerAction)

static bool js_cocos2dx_Speed_getSpeed(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_getSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeed();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_getSpeed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_getSpeed)

static bool js_cocos2dx_Speed_setSpeed(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_setSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_setSpeed : Error processing arguments");
        cobj->setSpeed(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_setSpeed)

static bool js_cocos2dx_Speed_initWithAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_initWithAction)

static bool js_cocos2dx_Speed_getInnerAction(se::State& s)
{
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Speed_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Speed_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Speed_getInnerAction)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Speed_finalize)

static bool js_cocos2dx_Speed_constructor(se::State& s)
{
    cocos2d::Speed* cobj = new (std::nothrow) cocos2d::Speed();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Speed_constructor, __jsb_cocos2d_Speed_class, js_cocos2d_Speed_finalize)



extern se::Object* __jsb_cocos2d_Action_proto;

static bool js_cocos2d_Speed_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Speed)", s.nativeThisObject());
    cocos2d::Speed* cobj = (cocos2d::Speed*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Speed_finalize)

bool js_register_cocos2dx_Speed(se::Object* obj)
{
    auto cls = se::Class::create("Speed", obj, __jsb_cocos2d_Action_proto, _SE(js_cocos2dx_Speed_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_Speed_setInnerAction));
    cls->defineFunction("_getSpeed", _SE(js_cocos2dx_Speed_getSpeed));
    cls->defineFunction("_setSpeed", _SE(js_cocos2dx_Speed_setSpeed));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_Speed_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_Speed_getInnerAction));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Speed_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Speed>(cls);

    __jsb_cocos2d_Speed_proto = cls->getProto();
    __jsb_cocos2d_Speed_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Image_proto = nullptr;
se::Class* __jsb_cocos2d_Image_class = nullptr;

static bool js_cocos2dx_Image_hasPremultipliedAlpha(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_hasPremultipliedAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasPremultipliedAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_hasPremultipliedAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_hasPremultipliedAlpha)

static bool js_cocos2dx_Image_getDataLen(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getDataLen : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getDataLen();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getDataLen : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getDataLen)

static bool js_cocos2dx_Image_saveToFile(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_saveToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        bool result = cobj->saveToFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        bool arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        bool result = cobj->saveToFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_saveToFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_saveToFile)

static bool js_cocos2dx_Image_hasAlpha(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_hasAlpha : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasAlpha();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_hasAlpha : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_hasAlpha)

static bool js_cocos2dx_Image_isCompressed(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_isCompressed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCompressed();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_isCompressed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_isCompressed)

static bool js_cocos2dx_Image_getHeight(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getHeight();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getHeight)

static bool js_cocos2dx_Image_initWithImageFile(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_initWithImageFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithImageFile : Error processing arguments");
        bool result = cobj->initWithImageFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_initWithImageFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_initWithImageFile)

static bool js_cocos2dx_Image_getWidth(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getWidth();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getWidth)

static bool js_cocos2dx_Image_getBitPerPixel(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getBitPerPixel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getBitPerPixel();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getBitPerPixel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getBitPerPixel)

static bool js_cocos2dx_Image_getFileType(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getFileType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getFileType();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getFileType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getFileType)

static bool js_cocos2dx_Image_getFilePath(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getFilePath();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getFilePath)

static bool js_cocos2dx_Image_getNumberOfMipmaps(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getNumberOfMipmaps : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getNumberOfMipmaps();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getNumberOfMipmaps : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getNumberOfMipmaps)

static bool js_cocos2dx_Image_getRenderFormat(se::State& s)
{
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Image_getRenderFormat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getRenderFormat();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_getRenderFormat : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_getRenderFormat)

static bool js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha : Error processing arguments");
        cocos2d::Image::setPVRImagesHavePremultipliedAlpha(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha)

static bool js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled : Error processing arguments");
        cocos2d::Image::setPNGPremultipliedAlphaEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Image_finalize)

static bool js_cocos2dx_Image_constructor(se::State& s)
{
    cocos2d::Image* cobj = new (std::nothrow) cocos2d::Image();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Image_constructor, __jsb_cocos2d_Image_class, js_cocos2d_Image_finalize)




static bool js_cocos2d_Image_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Image)", s.nativeThisObject());
    cocos2d::Image* cobj = (cocos2d::Image*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Image_finalize)

bool js_register_cocos2dx_Image(se::Object* obj)
{
    auto cls = se::Class::create("Image", obj, nullptr, _SE(js_cocos2dx_Image_constructor));

    cls->defineFunction("hasPremultipliedAlpha", _SE(js_cocos2dx_Image_hasPremultipliedAlpha));
    cls->defineFunction("getDataLen", _SE(js_cocos2dx_Image_getDataLen));
    cls->defineFunction("saveToFile", _SE(js_cocos2dx_Image_saveToFile));
    cls->defineFunction("hasAlpha", _SE(js_cocos2dx_Image_hasAlpha));
    cls->defineFunction("isCompressed", _SE(js_cocos2dx_Image_isCompressed));
    cls->defineFunction("getHeight", _SE(js_cocos2dx_Image_getHeight));
    cls->defineFunction("initWithImageFile", _SE(js_cocos2dx_Image_initWithImageFile));
    cls->defineFunction("getWidth", _SE(js_cocos2dx_Image_getWidth));
    cls->defineFunction("getBitPerPixel", _SE(js_cocos2dx_Image_getBitPerPixel));
    cls->defineFunction("getFileType", _SE(js_cocos2dx_Image_getFileType));
    cls->defineFunction("getFilePath", _SE(js_cocos2dx_Image_getFilePath));
    cls->defineFunction("getNumberOfMipmaps", _SE(js_cocos2dx_Image_getNumberOfMipmaps));
    cls->defineFunction("getRenderFormat", _SE(js_cocos2dx_Image_getRenderFormat));
    cls->defineStaticFunction("setPVRImagesHavePremultipliedAlpha", _SE(js_cocos2dx_Image_setPVRImagesHavePremultipliedAlpha));
    cls->defineStaticFunction("setPNGPremultipliedAlphaEnabled", _SE(js_cocos2dx_Image_setPNGPremultipliedAlphaEnabled));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Image_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Image>(cls);

    __jsb_cocos2d_Image_proto = cls->getProto();
    __jsb_cocos2d_Image_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_GLProgramState_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgramState_class = nullptr;

static bool js_cocos2dx_GLProgramState_setUniformCallback(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::GLProgram *, cocos2d::Uniform *)> arg1;
            do {
                if (args[1].isObject() && args[1].toObject()->isFunction())
                {
                    se::Value jsThis(s.thisObject());
                    se::Value jsFunc(args[1]);
                    jsThis.toObject()->attachObject(jsFunc.toObject());
                    auto lambda = [=](cocos2d::GLProgram* larg0, cocos2d::Uniform* larg1) -> void {
                        se::ScriptEngine::getInstance()->clearException();
                        se::AutoHandleScope hs;
            
                        CC_UNUSED bool ok = true;
                        se::ValueArray args;
                        args.resize(2);
                        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)larg0, &args[0]);
                        ok &= uniform_to_seval(larg1, &args[1]);
                        se::Value rval;
                        se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                        se::Object* funcObj = jsFunc.toObject();
                        bool succeed = funcObj->call(args, thisObj, &rval);
                        if (!succeed) {
                            se::ScriptEngine::getInstance()->clearException();
                        }
                    };
                    arg1 = lambda;
                }
                else
                {
                    arg1 = nullptr;
                }
            } while(false)
            ;
            if (!ok) { ok = true; break; }
            cobj->setUniformCallback(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::function<void (cocos2d::GLProgram *, cocos2d::Uniform *)> arg1;
            do {
                if (args[1].isObject() && args[1].toObject()->isFunction())
                {
                    se::Value jsThis(s.thisObject());
                    se::Value jsFunc(args[1]);
                    jsThis.toObject()->attachObject(jsFunc.toObject());
                    auto lambda = [=](cocos2d::GLProgram* larg0, cocos2d::Uniform* larg1) -> void {
                        se::ScriptEngine::getInstance()->clearException();
                        se::AutoHandleScope hs;
            
                        CC_UNUSED bool ok = true;
                        se::ValueArray args;
                        args.resize(2);
                        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)larg0, &args[0]);
                        ok &= uniform_to_seval(larg1, &args[1]);
                        se::Value rval;
                        se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                        se::Object* funcObj = jsFunc.toObject();
                        bool succeed = funcObj->call(args, thisObj, &rval);
                        if (!succeed) {
                            se::ScriptEngine::getInstance()->clearException();
                        }
                    };
                    arg1 = lambda;
                }
                else
                {
                    arg1 = nullptr;
                }
            } while(false)
            ;
            if (!ok) { ok = true; break; }
            cobj->setUniformCallback(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformCallback)

static bool js_cocos2dx_GLProgramState_getVertexAttribsFlags(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getVertexAttribsFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getVertexAttribsFlags();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getVertexAttribsFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getVertexAttribsFlags)

static bool js_cocos2dx_GLProgramState_applyAutoBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyAutoBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyAutoBinding : Error processing arguments");
        cobj->applyAutoBinding(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyAutoBinding)

static bool js_cocos2dx_GLProgramState_setUniformVec2(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec2 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec2)

static bool js_cocos2dx_GLProgramState_setUniformVec3(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec3 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec3 arg1;
            ok &= seval_to_Vec3(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec3)

static bool js_cocos2dx_GLProgramState_setVertexAttribCallback(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setVertexAttribCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::VertexAttrib *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::VertexAttrib* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::VertexAttrib>((cocos2d::VertexAttrib*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setVertexAttribCallback : Error processing arguments");
        cobj->setVertexAttribCallback(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setVertexAttribCallback)

static bool js_cocos2dx_GLProgramState_apply(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_apply : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_apply : Error processing arguments");
        cobj->apply(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_apply)

static bool js_cocos2dx_GLProgramState_getNodeBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getNodeBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNodeBinding();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getNodeBinding : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getNodeBinding)

static bool js_cocos2dx_GLProgramState_applyGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Mat4 arg0;
        ok &= seval_to_Mat4(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyGLProgram : Error processing arguments");
        cobj->applyGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyGLProgram)

static bool js_cocos2dx_GLProgramState_setNodeBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setNodeBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setNodeBinding : Error processing arguments");
        cobj->setNodeBinding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setNodeBinding)

static bool js_cocos2dx_GLProgramState_setUniformInt(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformInt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformInt(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformInt(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformInt)

static bool js_cocos2dx_GLProgramState_setParameterAutoBinding(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setParameterAutoBinding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setParameterAutoBinding : Error processing arguments");
        cobj->setParameterAutoBinding(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setParameterAutoBinding)

static bool js_cocos2dx_GLProgramState_setUniformVec2v(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec2v : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec2* arg2 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[2], &tempData);arg2=tempData.data();
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec2* arg2 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[2], &tempData);arg2=tempData.data();
            if (!ok) { ok = true; break; }
            cobj->setUniformVec2v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec2v)

static bool js_cocos2dx_GLProgramState_getUniformCount(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getUniformCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getUniformCount();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getUniformCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getUniformCount)

static bool js_cocos2dx_GLProgramState_applyAttributes(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyAttributes : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->applyAttributes();
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_applyAttributes : Error processing arguments");
        cobj->applyAttributes(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyAttributes)

static bool js_cocos2dx_GLProgramState_clone(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgramState* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_clone)

static bool js_cocos2dx_GLProgramState_setGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_setGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_setGLProgram : Error processing arguments");
        cobj->setGLProgram(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setGLProgram)

static bool js_cocos2dx_GLProgramState_setUniformFloatv(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformFloatv : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const float* arg2 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
            ok = false;
            if (!ok) { ok = true; break; }
            cobj->setUniformFloatv(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const float* arg2 = 0;
            #pragma warning NO CONVERSION TO NATIVE FOR float*
            ok = false;
            if (!ok) { ok = true; break; }
            cobj->setUniformFloatv(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformFloatv)

static bool js_cocos2dx_GLProgramState_getGLProgram(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::GLProgram* result = cobj->getGLProgram();
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getGLProgram)

static bool js_cocos2dx_GLProgramState_setUniformTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformTexture(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformTexture)

static bool js_cocos2dx_GLProgramState_applyUniforms(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_applyUniforms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->applyUniforms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_applyUniforms)

static bool js_cocos2dx_GLProgramState_setUniformFloat(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformFloat : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformFloat(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformFloat(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformFloat)

static bool js_cocos2dx_GLProgramState_setUniformMat4(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformMat4 : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformMat4(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Mat4 arg1;
            ok &= seval_to_Mat4(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformMat4(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformMat4)

static bool js_cocos2dx_GLProgramState_setUniformVec3v(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgramState_setUniformVec3v : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec3* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            ssize_t arg1 = 0;
            ok &= seval_to_ssize(args[1], &arg1);
            if (!ok) { ok = true; break; }
            const cocos2d::Vec3* arg2 = nullptr;
            ok &= seval_to_native_ptr(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformVec3v(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_setUniformVec3v)

static bool js_cocos2dx_GLProgramState_getVertexAttribCount(se::State& s)
{
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramState_getVertexAttribCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getVertexAttribCount();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getVertexAttribCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getVertexAttribCount)

static bool js_cocos2dx_GLProgramState_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_create : Error processing arguments");
        auto result = cocos2d::GLProgramState::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_GLProgramState_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_create)

static bool js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : Error processing arguments");
        cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithGLProgramName(arg0);
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName)

static bool js_cocos2dx_GLProgramState_getOrCreateWithGLProgram(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::GLProgram* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgram : Error processing arguments");
        cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithGLProgram(arg0);
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithGLProgram)

static bool js_cocos2dx_GLProgramState_getOrCreateWithShaders(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_std_string(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithShaders : Error processing arguments");
        cocos2d::GLProgramState* result = cocos2d::GLProgramState::getOrCreateWithShaders(arg0, arg1, arg2);
        ok &= native_ptr_to_seval<cocos2d::GLProgramState>((cocos2d::GLProgramState*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramState_getOrCreateWithShaders : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramState_getOrCreateWithShaders)



static bool js_cocos2d_GLProgramState_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::GLProgramState)", s.nativeThisObject());
    cocos2d::GLProgramState* cobj = (cocos2d::GLProgramState*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_GLProgramState_finalize)

bool js_register_cocos2dx_GLProgramState(se::Object* obj)
{
    auto cls = se::Class::create("GLProgramState", obj, nullptr, nullptr);

    cls->defineFunction("setUniformCallback", _SE(js_cocos2dx_GLProgramState_setUniformCallback));
    cls->defineFunction("getVertexAttribsFlags", _SE(js_cocos2dx_GLProgramState_getVertexAttribsFlags));
    cls->defineFunction("applyAutoBinding", _SE(js_cocos2dx_GLProgramState_applyAutoBinding));
    cls->defineFunction("setUniformVec2", _SE(js_cocos2dx_GLProgramState_setUniformVec2));
    cls->defineFunction("setUniformVec3", _SE(js_cocos2dx_GLProgramState_setUniformVec3));
    cls->defineFunction("setVertexAttribCallback", _SE(js_cocos2dx_GLProgramState_setVertexAttribCallback));
    cls->defineFunction("apply", _SE(js_cocos2dx_GLProgramState_apply));
    cls->defineFunction("getNodeBinding", _SE(js_cocos2dx_GLProgramState_getNodeBinding));
    cls->defineFunction("applyGLProgram", _SE(js_cocos2dx_GLProgramState_applyGLProgram));
    cls->defineFunction("setNodeBinding", _SE(js_cocos2dx_GLProgramState_setNodeBinding));
    cls->defineFunction("setUniformInt", _SE(js_cocos2dx_GLProgramState_setUniformInt));
    cls->defineFunction("setParameterAutoBinding", _SE(js_cocos2dx_GLProgramState_setParameterAutoBinding));
    cls->defineFunction("setUniformVec2v", _SE(js_cocos2dx_GLProgramState_setUniformVec2v));
    cls->defineFunction("getUniformCount", _SE(js_cocos2dx_GLProgramState_getUniformCount));
    cls->defineFunction("applyAttributes", _SE(js_cocos2dx_GLProgramState_applyAttributes));
    cls->defineFunction("clone", _SE(js_cocos2dx_GLProgramState_clone));
    cls->defineFunction("setGLProgram", _SE(js_cocos2dx_GLProgramState_setGLProgram));
    cls->defineFunction("setUniformFloatv", _SE(js_cocos2dx_GLProgramState_setUniformFloatv));
    cls->defineFunction("getGLProgram", _SE(js_cocos2dx_GLProgramState_getGLProgram));
    cls->defineFunction("setUniformTexture", _SE(js_cocos2dx_GLProgramState_setUniformTexture));
    cls->defineFunction("applyUniforms", _SE(js_cocos2dx_GLProgramState_applyUniforms));
    cls->defineFunction("setUniformFloat", _SE(js_cocos2dx_GLProgramState_setUniformFloat));
    cls->defineFunction("setUniformMat4", _SE(js_cocos2dx_GLProgramState_setUniformMat4));
    cls->defineFunction("setUniformVec3v", _SE(js_cocos2dx_GLProgramState_setUniformVec3v));
    cls->defineFunction("getVertexAttribCount", _SE(js_cocos2dx_GLProgramState_getVertexAttribCount));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_GLProgramState_create));
    cls->defineStaticFunction("getOrCreateWithGLProgramName", _SE(js_cocos2dx_GLProgramState_getOrCreateWithGLProgramName));
    cls->defineStaticFunction("getOrCreateWithGLProgram", _SE(js_cocos2dx_GLProgramState_getOrCreateWithGLProgram));
    cls->defineStaticFunction("getOrCreateWithShaders", _SE(js_cocos2dx_GLProgramState_getOrCreateWithShaders));
    cls->defineFinalizeFunction(_SE(js_cocos2d_GLProgramState_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgramState>(cls);

    __jsb_cocos2d_GLProgramState_proto = cls->getProto();
    __jsb_cocos2d_GLProgramState_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SpriteFrame_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteFrame_class = nullptr;

static bool js_cocos2dx_SpriteFrame_setAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setAnchorPoint : Error processing arguments");
        cobj->setAnchorPoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setAnchorPoint)

static bool js_cocos2dx_SpriteFrame_setTexture(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setTexture)

static bool js_cocos2dx_SpriteFrame_getTexture(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getTexture)

static bool js_cocos2dx_SpriteFrame_setOffsetInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOffsetInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOffsetInPixels : Error processing arguments");
        cobj->setOffsetInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOffsetInPixels)

static bool js_cocos2dx_SpriteFrame_getOriginalSizeInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOriginalSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getOriginalSizeInPixels();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOriginalSizeInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOriginalSizeInPixels)

static bool js_cocos2dx_SpriteFrame_setOriginalSize(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOriginalSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOriginalSize : Error processing arguments");
        cobj->setOriginalSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOriginalSize)

static bool js_cocos2dx_SpriteFrame_setRectInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRectInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRectInPixels : Error processing arguments");
        cobj->setRectInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRectInPixels)

static bool js_cocos2dx_SpriteFrame_getRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getRect)

static bool js_cocos2dx_SpriteFrame_setOffset(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOffset : Error processing arguments");
        cobj->setOffset(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOffset)

static bool js_cocos2dx_SpriteFrame_initWithTextureFilename(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTextureFilename(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTextureFilename(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTextureFilename : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_initWithTextureFilename)

static bool js_cocos2dx_SpriteFrame_setRect(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRect : Error processing arguments");
        cobj->setRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRect)

static bool js_cocos2dx_SpriteFrame_initWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrame_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_initWithTexture)

static bool js_cocos2dx_SpriteFrame_getOriginalSize(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOriginalSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getOriginalSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOriginalSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOriginalSize)

static bool js_cocos2dx_SpriteFrame_clone(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_clone : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteFrame* result = cobj->clone();
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_clone : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_clone)

static bool js_cocos2dx_SpriteFrame_getRectInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getRectInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getRectInPixels();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getRectInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getRectInPixels)

static bool js_cocos2dx_SpriteFrame_isRotated(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_isRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isRotated();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_isRotated : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_isRotated)

static bool js_cocos2dx_SpriteFrame_setRotated(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setRotated : Error processing arguments");
        cobj->setRotated(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setRotated)

static bool js_cocos2dx_SpriteFrame_getOffset(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffset();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOffset)

static bool js_cocos2dx_SpriteFrame_setOriginalSizeInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_setOriginalSizeInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_setOriginalSizeInPixels : Error processing arguments");
        cobj->setOriginalSizeInPixels(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_setOriginalSizeInPixels)

static bool js_cocos2dx_SpriteFrame_getAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getAnchorPoint();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getAnchorPoint)

static bool js_cocos2dx_SpriteFrame_hasAnchorPoint(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_hasAnchorPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasAnchorPoint();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_hasAnchorPoint : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_hasAnchorPoint)

static bool js_cocos2dx_SpriteFrame_getOffsetInPixels(se::State& s)
{
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrame_getOffsetInPixels : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffsetInPixels();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_getOffsetInPixels : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_getOffsetInPixels)

static bool js_cocos2dx_SpriteFrame_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_create)

static bool js_cocos2dx_SpriteFrame_createWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg4;
            ok &= seval_to_Size(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::createWithTexture(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_createWithTexture : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::SpriteFrame* result = cocos2d::SpriteFrame::createWithTexture(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrame_createWithTexture : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrame_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SpriteFrame_finalize)

static bool js_cocos2dx_SpriteFrame_constructor(se::State& s)
{
    cocos2d::SpriteFrame* cobj = new (std::nothrow) cocos2d::SpriteFrame();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SpriteFrame_constructor, __jsb_cocos2d_SpriteFrame_class, js_cocos2d_SpriteFrame_finalize)

static bool js_cocos2dx_SpriteFrame_ctor(se::State& s)
{
    cocos2d::SpriteFrame* cobj = new (std::nothrow) cocos2d::SpriteFrame();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SpriteFrame_ctor, __jsb_cocos2d_SpriteFrame_class, js_cocos2d_SpriteFrame_finalize)


    


static bool js_cocos2d_SpriteFrame_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::SpriteFrame)", s.nativeThisObject());
    cocos2d::SpriteFrame* cobj = (cocos2d::SpriteFrame*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SpriteFrame_finalize)

bool js_register_cocos2dx_SpriteFrame(se::Object* obj)
{
    auto cls = se::Class::create("SpriteFrame", obj, nullptr, _SE(js_cocos2dx_SpriteFrame_constructor));

    cls->defineFunction("setAnchorPoint", _SE(js_cocos2dx_SpriteFrame_setAnchorPoint));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_SpriteFrame_setTexture));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_SpriteFrame_getTexture));
    cls->defineFunction("setOffsetInPixels", _SE(js_cocos2dx_SpriteFrame_setOffsetInPixels));
    cls->defineFunction("getOriginalSizeInPixels", _SE(js_cocos2dx_SpriteFrame_getOriginalSizeInPixels));
    cls->defineFunction("setOriginalSize", _SE(js_cocos2dx_SpriteFrame_setOriginalSize));
    cls->defineFunction("setRectInPixels", _SE(js_cocos2dx_SpriteFrame_setRectInPixels));
    cls->defineFunction("getRect", _SE(js_cocos2dx_SpriteFrame_getRect));
    cls->defineFunction("setOffset", _SE(js_cocos2dx_SpriteFrame_setOffset));
    cls->defineFunction("initWithTextureFilename", _SE(js_cocos2dx_SpriteFrame_initWithTextureFilename));
    cls->defineFunction("setRect", _SE(js_cocos2dx_SpriteFrame_setRect));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_SpriteFrame_initWithTexture));
    cls->defineFunction("getOriginalSize", _SE(js_cocos2dx_SpriteFrame_getOriginalSize));
    cls->defineFunction("clone", _SE(js_cocos2dx_SpriteFrame_clone));
    cls->defineFunction("getRectInPixels", _SE(js_cocos2dx_SpriteFrame_getRectInPixels));
    cls->defineFunction("isRotated", _SE(js_cocos2dx_SpriteFrame_isRotated));
    cls->defineFunction("setRotated", _SE(js_cocos2dx_SpriteFrame_setRotated));
    cls->defineFunction("getOffset", _SE(js_cocos2dx_SpriteFrame_getOffset));
    cls->defineFunction("setOriginalSizeInPixels", _SE(js_cocos2dx_SpriteFrame_setOriginalSizeInPixels));
    cls->defineFunction("getAnchorPoint", _SE(js_cocos2dx_SpriteFrame_getAnchorPoint));
    cls->defineFunction("hasAnchorPoint", _SE(js_cocos2dx_SpriteFrame_hasAnchorPoint));
    cls->defineFunction("getOffsetInPixels", _SE(js_cocos2dx_SpriteFrame_getOffsetInPixels));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SpriteFrame_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SpriteFrame_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_SpriteFrame_createWithTexture));
    cls->defineFinalizeFunction(_SE(js_cocos2d_SpriteFrame_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteFrame>(cls);

    __jsb_cocos2d_SpriteFrame_proto = cls->getProto();
    __jsb_cocos2d_SpriteFrame_class = cls;

    jsb_set_extend_property("cc", "SpriteFrame");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ActionInterval_proto = nullptr;
se::Class* __jsb_cocos2d_ActionInterval_class = nullptr;

static bool js_cocos2dx_ActionInterval_getAmplitudeRate(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_getAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAmplitudeRate();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_getAmplitudeRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_getAmplitudeRate)

static bool js_cocos2dx_ActionInterval_initWithDuration(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_initWithDuration)

static bool js_cocos2dx_ActionInterval_setAmplitudeRate(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_setAmplitudeRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_setAmplitudeRate : Error processing arguments");
        cobj->setAmplitudeRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_setAmplitudeRate)

static bool js_cocos2dx_ActionInterval_getElapsed(se::State& s)
{
    cocos2d::ActionInterval* cobj = (cocos2d::ActionInterval*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionInterval_getElapsed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getElapsed();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionInterval_getElapsed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionInterval_getElapsed)


extern se::Object* __jsb_cocos2d_FiniteTimeAction_proto;


bool js_register_cocos2dx_ActionInterval(se::Object* obj)
{
    auto cls = se::Class::create("ActionInterval", obj, __jsb_cocos2d_FiniteTimeAction_proto, nullptr);

    cls->defineFunction("getAmplitudeRate", _SE(js_cocos2dx_ActionInterval_getAmplitudeRate));
    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ActionInterval_initWithDuration));
    cls->defineFunction("setAmplitudeRate", _SE(js_cocos2dx_ActionInterval_setAmplitudeRate));
    cls->defineFunction("getElapsed", _SE(js_cocos2dx_ActionInterval_getElapsed));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionInterval>(cls);

    __jsb_cocos2d_ActionInterval_proto = cls->getProto();
    __jsb_cocos2d_ActionInterval_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Sequence_proto = nullptr;
se::Class* __jsb_cocos2d_Sequence_class = nullptr;

static bool js_cocos2dx_Sequence_init(se::State& s)
{
    cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sequence_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::FiniteTimeAction *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sequence_init)

static bool js_cocos2dx_Sequence_initWithTwoActions(se::State& s)
{
    cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sequence_initWithTwoActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_initWithTwoActions : Error processing arguments");
        bool result = cobj->initWithTwoActions(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sequence_initWithTwoActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sequence_initWithTwoActions)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Sequence_finalize)

static bool js_cocos2dx_Sequence_constructor(se::State& s)
{
    cocos2d::Sequence* cobj = new (std::nothrow) cocos2d::Sequence();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Sequence_constructor, __jsb_cocos2d_Sequence_class, js_cocos2d_Sequence_finalize)

static bool js_cocos2dx_Sequence_ctor(se::State& s)
{
    cocos2d::Sequence* cobj = new (std::nothrow) cocos2d::Sequence();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Sequence_ctor, __jsb_cocos2d_Sequence_class, js_cocos2d_Sequence_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_Sequence_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Sequence)", s.nativeThisObject());
    cocos2d::Sequence* cobj = (cocos2d::Sequence*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Sequence_finalize)

bool js_register_cocos2dx_Sequence(se::Object* obj)
{
    auto cls = se::Class::create("Sequence", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Sequence_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_Sequence_init));
    cls->defineFunction("initWithTwoActions", _SE(js_cocos2dx_Sequence_initWithTwoActions));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Sequence_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Sequence_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Sequence>(cls);

    __jsb_cocos2d_Sequence_proto = cls->getProto();
    __jsb_cocos2d_Sequence_class = cls;

    jsb_set_extend_property("cc", "Sequence");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Repeat_proto = nullptr;
se::Class* __jsb_cocos2d_Repeat_class = nullptr;

static bool js_cocos2dx_Repeat_setInnerAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_setInnerAction)

static bool js_cocos2dx_Repeat_initWithAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        unsigned int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_initWithAction)

static bool js_cocos2dx_Repeat_getInnerAction(se::State& s)
{
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Repeat_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::FiniteTimeAction* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::FiniteTimeAction>((cocos2d::FiniteTimeAction*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Repeat_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Repeat_getInnerAction)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Repeat_finalize)

static bool js_cocos2dx_Repeat_constructor(se::State& s)
{
    cocos2d::Repeat* cobj = new (std::nothrow) cocos2d::Repeat();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Repeat_constructor, __jsb_cocos2d_Repeat_class, js_cocos2d_Repeat_finalize)

static bool js_cocos2dx_Repeat_ctor(se::State& s)
{
    cocos2d::Repeat* cobj = new (std::nothrow) cocos2d::Repeat();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Repeat_ctor, __jsb_cocos2d_Repeat_class, js_cocos2d_Repeat_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_Repeat_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Repeat)", s.nativeThisObject());
    cocos2d::Repeat* cobj = (cocos2d::Repeat*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Repeat_finalize)

bool js_register_cocos2dx_Repeat(se::Object* obj)
{
    auto cls = se::Class::create("Repeat", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Repeat_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_Repeat_setInnerAction));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_Repeat_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_Repeat_getInnerAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Repeat_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Repeat_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Repeat>(cls);

    __jsb_cocos2d_Repeat_proto = cls->getProto();
    __jsb_cocos2d_Repeat_class = cls;

    jsb_set_extend_property("cc", "Repeat");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_RepeatForever_proto = nullptr;
se::Class* __jsb_cocos2d_RepeatForever_class = nullptr;

static bool js_cocos2dx_RepeatForever_setInnerAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_setInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_setInnerAction : Error processing arguments");
        cobj->setInnerAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_setInnerAction)

static bool js_cocos2dx_RepeatForever_initWithAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_initWithAction)

static bool js_cocos2dx_RepeatForever_getInnerAction(se::State& s)
{
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RepeatForever_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RepeatForever_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RepeatForever_getInnerAction)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RepeatForever_finalize)

static bool js_cocos2dx_RepeatForever_constructor(se::State& s)
{
    cocos2d::RepeatForever* cobj = new (std::nothrow) cocos2d::RepeatForever();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RepeatForever_constructor, __jsb_cocos2d_RepeatForever_class, js_cocos2d_RepeatForever_finalize)

static bool js_cocos2dx_RepeatForever_ctor(se::State& s)
{
    cocos2d::RepeatForever* cobj = new (std::nothrow) cocos2d::RepeatForever();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RepeatForever_ctor, __jsb_cocos2d_RepeatForever_class, js_cocos2d_RepeatForever_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_RepeatForever_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::RepeatForever)", s.nativeThisObject());
    cocos2d::RepeatForever* cobj = (cocos2d::RepeatForever*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RepeatForever_finalize)

bool js_register_cocos2dx_RepeatForever(se::Object* obj)
{
    auto cls = se::Class::create("RepeatForever", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RepeatForever_constructor));

    cls->defineFunction("setInnerAction", _SE(js_cocos2dx_RepeatForever_setInnerAction));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_RepeatForever_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_RepeatForever_getInnerAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RepeatForever_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_RepeatForever_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RepeatForever>(cls);

    __jsb_cocos2d_RepeatForever_proto = cls->getProto();
    __jsb_cocos2d_RepeatForever_class = cls;

    jsb_set_extend_property("cc", "RepeatForever");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Spawn_proto = nullptr;
se::Class* __jsb_cocos2d_Spawn_class = nullptr;

static bool js_cocos2dx_Spawn_init(se::State& s)
{
    cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Spawn_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::FiniteTimeAction *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Spawn_init)

static bool js_cocos2dx_Spawn_initWithTwoActions(se::State& s)
{
    cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Spawn_initWithTwoActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_initWithTwoActions : Error processing arguments");
        bool result = cobj->initWithTwoActions(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Spawn_initWithTwoActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Spawn_initWithTwoActions)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Spawn_finalize)

static bool js_cocos2dx_Spawn_constructor(se::State& s)
{
    cocos2d::Spawn* cobj = new (std::nothrow) cocos2d::Spawn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Spawn_constructor, __jsb_cocos2d_Spawn_class, js_cocos2d_Spawn_finalize)

static bool js_cocos2dx_Spawn_ctor(se::State& s)
{
    cocos2d::Spawn* cobj = new (std::nothrow) cocos2d::Spawn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Spawn_ctor, __jsb_cocos2d_Spawn_class, js_cocos2d_Spawn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_Spawn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Spawn)", s.nativeThisObject());
    cocos2d::Spawn* cobj = (cocos2d::Spawn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Spawn_finalize)

bool js_register_cocos2dx_Spawn(se::Object* obj)
{
    auto cls = se::Class::create("Spawn", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Spawn_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_Spawn_init));
    cls->defineFunction("initWithTwoActions", _SE(js_cocos2dx_Spawn_initWithTwoActions));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Spawn_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Spawn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Spawn>(cls);

    __jsb_cocos2d_Spawn_proto = cls->getProto();
    __jsb_cocos2d_Spawn_class = cls;

    jsb_set_extend_property("cc", "Spawn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_RotateTo_proto = nullptr;
se::Class* __jsb_cocos2d_RotateTo_class = nullptr;

static bool js_cocos2dx_RotateTo_initWithDuration(se::State& s)
{
    cocos2d::RotateTo* cobj = (cocos2d::RotateTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RotateTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateTo_initWithDuration)

static bool js_cocos2dx_RotateTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateTo* result = cocos2d::RotateTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateTo>((cocos2d::RotateTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RotateTo* result = cocos2d::RotateTo::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RotateTo>((cocos2d::RotateTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RotateTo_finalize)

static bool js_cocos2dx_RotateTo_constructor(se::State& s)
{
    cocos2d::RotateTo* cobj = new (std::nothrow) cocos2d::RotateTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RotateTo_constructor, __jsb_cocos2d_RotateTo_class, js_cocos2d_RotateTo_finalize)

static bool js_cocos2dx_RotateTo_ctor(se::State& s)
{
    cocos2d::RotateTo* cobj = new (std::nothrow) cocos2d::RotateTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RotateTo_ctor, __jsb_cocos2d_RotateTo_class, js_cocos2d_RotateTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_RotateTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::RotateTo)", s.nativeThisObject());
    cocos2d::RotateTo* cobj = (cocos2d::RotateTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RotateTo_finalize)

bool js_register_cocos2dx_RotateTo(se::Object* obj)
{
    auto cls = se::Class::create("RotateTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RotateTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_RotateTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RotateTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RotateTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_RotateTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RotateTo>(cls);

    __jsb_cocos2d_RotateTo_proto = cls->getProto();
    __jsb_cocos2d_RotateTo_class = cls;

    jsb_set_extend_property("cc", "RotateTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_RotateBy_proto = nullptr;
se::Class* __jsb_cocos2d_RotateBy_class = nullptr;

static bool js_cocos2dx_RotateBy_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RotateBy* cobj = (cocos2d::RotateBy*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_RotateBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateBy_initWithDuration)

static bool js_cocos2dx_RotateBy_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RotateBy* result = cocos2d::RotateBy::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RotateBy>((cocos2d::RotateBy*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RotateBy* result = cocos2d::RotateBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RotateBy>((cocos2d::RotateBy*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RotateBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RotateBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RotateBy_finalize)

static bool js_cocos2dx_RotateBy_constructor(se::State& s)
{
    cocos2d::RotateBy* cobj = new (std::nothrow) cocos2d::RotateBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RotateBy_constructor, __jsb_cocos2d_RotateBy_class, js_cocos2d_RotateBy_finalize)

static bool js_cocos2dx_RotateBy_ctor(se::State& s)
{
    cocos2d::RotateBy* cobj = new (std::nothrow) cocos2d::RotateBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RotateBy_ctor, __jsb_cocos2d_RotateBy_class, js_cocos2d_RotateBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_RotateBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::RotateBy)", s.nativeThisObject());
    cocos2d::RotateBy* cobj = (cocos2d::RotateBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RotateBy_finalize)

bool js_register_cocos2dx_RotateBy(se::Object* obj)
{
    auto cls = se::Class::create("RotateBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_RotateBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_RotateBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RotateBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RotateBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_RotateBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RotateBy>(cls);

    __jsb_cocos2d_RotateBy_proto = cls->getProto();
    __jsb_cocos2d_RotateBy_class = cls;

    jsb_set_extend_property("cc", "RotateBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MoveBy_proto = nullptr;
se::Class* __jsb_cocos2d_MoveBy_class = nullptr;

static bool js_cocos2dx_MoveBy_initWithDuration(se::State& s)
{
    cocos2d::MoveBy* cobj = (cocos2d::MoveBy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MoveBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveBy_initWithDuration)

static bool js_cocos2dx_MoveBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveBy_create : Error processing arguments");
        auto result = cocos2d::MoveBy::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_MoveBy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MoveBy_finalize)

static bool js_cocos2dx_MoveBy_constructor(se::State& s)
{
    cocos2d::MoveBy* cobj = new (std::nothrow) cocos2d::MoveBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MoveBy_constructor, __jsb_cocos2d_MoveBy_class, js_cocos2d_MoveBy_finalize)

static bool js_cocos2dx_MoveBy_ctor(se::State& s)
{
    cocos2d::MoveBy* cobj = new (std::nothrow) cocos2d::MoveBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MoveBy_ctor, __jsb_cocos2d_MoveBy_class, js_cocos2d_MoveBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_MoveBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MoveBy)", s.nativeThisObject());
    cocos2d::MoveBy* cobj = (cocos2d::MoveBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MoveBy_finalize)

bool js_register_cocos2dx_MoveBy(se::Object* obj)
{
    auto cls = se::Class::create("MoveBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_MoveBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_MoveBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MoveBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MoveBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MoveBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MoveBy>(cls);

    __jsb_cocos2d_MoveBy_proto = cls->getProto();
    __jsb_cocos2d_MoveBy_class = cls;

    jsb_set_extend_property("cc", "MoveBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MoveTo_proto = nullptr;
se::Class* __jsb_cocos2d_MoveTo_class = nullptr;

static bool js_cocos2dx_MoveTo_initWithDuration(se::State& s)
{
    cocos2d::MoveTo* cobj = (cocos2d::MoveTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MoveTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveTo_initWithDuration)

static bool js_cocos2dx_MoveTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MoveTo_create : Error processing arguments");
        auto result = cocos2d::MoveTo::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_MoveTo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MoveTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MoveTo_finalize)

static bool js_cocos2dx_MoveTo_constructor(se::State& s)
{
    cocos2d::MoveTo* cobj = new (std::nothrow) cocos2d::MoveTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MoveTo_constructor, __jsb_cocos2d_MoveTo_class, js_cocos2d_MoveTo_finalize)

static bool js_cocos2dx_MoveTo_ctor(se::State& s)
{
    cocos2d::MoveTo* cobj = new (std::nothrow) cocos2d::MoveTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MoveTo_ctor, __jsb_cocos2d_MoveTo_class, js_cocos2d_MoveTo_finalize)


    

extern se::Object* __jsb_cocos2d_MoveBy_proto;

static bool js_cocos2d_MoveTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MoveTo)", s.nativeThisObject());
    cocos2d::MoveTo* cobj = (cocos2d::MoveTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MoveTo_finalize)

bool js_register_cocos2dx_MoveTo(se::Object* obj)
{
    auto cls = se::Class::create("MoveTo", obj, __jsb_cocos2d_MoveBy_proto, _SE(js_cocos2dx_MoveTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_MoveTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MoveTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MoveTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MoveTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MoveTo>(cls);

    __jsb_cocos2d_MoveTo_proto = cls->getProto();
    __jsb_cocos2d_MoveTo_class = cls;

    jsb_set_extend_property("cc", "MoveTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SkewTo_proto = nullptr;
se::Class* __jsb_cocos2d_SkewTo_class = nullptr;

static bool js_cocos2dx_SkewTo_initWithDuration(se::State& s)
{
    cocos2d::SkewTo* cobj = (cocos2d::SkewTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SkewTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewTo_initWithDuration)

static bool js_cocos2dx_SkewTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewTo_create : Error processing arguments");
        auto result = cocos2d::SkewTo::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SkewTo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SkewTo_finalize)

static bool js_cocos2dx_SkewTo_constructor(se::State& s)
{
    cocos2d::SkewTo* cobj = new (std::nothrow) cocos2d::SkewTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SkewTo_constructor, __jsb_cocos2d_SkewTo_class, js_cocos2d_SkewTo_finalize)

static bool js_cocos2dx_SkewTo_ctor(se::State& s)
{
    cocos2d::SkewTo* cobj = new (std::nothrow) cocos2d::SkewTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SkewTo_ctor, __jsb_cocos2d_SkewTo_class, js_cocos2d_SkewTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_SkewTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::SkewTo)", s.nativeThisObject());
    cocos2d::SkewTo* cobj = (cocos2d::SkewTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SkewTo_finalize)

bool js_register_cocos2dx_SkewTo(se::Object* obj)
{
    auto cls = se::Class::create("SkewTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_SkewTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SkewTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SkewTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SkewTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_SkewTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SkewTo>(cls);

    __jsb_cocos2d_SkewTo_proto = cls->getProto();
    __jsb_cocos2d_SkewTo_class = cls;

    jsb_set_extend_property("cc", "SkewTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SkewBy_proto = nullptr;
se::Class* __jsb_cocos2d_SkewBy_class = nullptr;

static bool js_cocos2dx_SkewBy_initWithDuration(se::State& s)
{
    cocos2d::SkewBy* cobj = (cocos2d::SkewBy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SkewBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewBy_initWithDuration)

static bool js_cocos2dx_SkewBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SkewBy_create : Error processing arguments");
        auto result = cocos2d::SkewBy::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SkewBy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SkewBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SkewBy_finalize)

static bool js_cocos2dx_SkewBy_constructor(se::State& s)
{
    cocos2d::SkewBy* cobj = new (std::nothrow) cocos2d::SkewBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SkewBy_constructor, __jsb_cocos2d_SkewBy_class, js_cocos2d_SkewBy_finalize)

static bool js_cocos2dx_SkewBy_ctor(se::State& s)
{
    cocos2d::SkewBy* cobj = new (std::nothrow) cocos2d::SkewBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SkewBy_ctor, __jsb_cocos2d_SkewBy_class, js_cocos2d_SkewBy_finalize)


    

extern se::Object* __jsb_cocos2d_SkewTo_proto;

static bool js_cocos2d_SkewBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::SkewBy)", s.nativeThisObject());
    cocos2d::SkewBy* cobj = (cocos2d::SkewBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SkewBy_finalize)

bool js_register_cocos2dx_SkewBy(se::Object* obj)
{
    auto cls = se::Class::create("SkewBy", obj, __jsb_cocos2d_SkewTo_proto, _SE(js_cocos2dx_SkewBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_SkewBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SkewBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SkewBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_SkewBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SkewBy>(cls);

    __jsb_cocos2d_SkewBy_proto = cls->getProto();
    __jsb_cocos2d_SkewBy_class = cls;

    jsb_set_extend_property("cc", "SkewBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_JumpBy_proto = nullptr;
se::Class* __jsb_cocos2d_JumpBy_class = nullptr;

static bool js_cocos2dx_JumpBy_initWithDuration(se::State& s)
{
    cocos2d::JumpBy* cobj = (cocos2d::JumpBy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_JumpBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpBy_initWithDuration)

static bool js_cocos2dx_JumpBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpBy_create : Error processing arguments");
        auto result = cocos2d::JumpBy::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_JumpBy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_JumpBy_finalize)

static bool js_cocos2dx_JumpBy_constructor(se::State& s)
{
    cocos2d::JumpBy* cobj = new (std::nothrow) cocos2d::JumpBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_JumpBy_constructor, __jsb_cocos2d_JumpBy_class, js_cocos2d_JumpBy_finalize)

static bool js_cocos2dx_JumpBy_ctor(se::State& s)
{
    cocos2d::JumpBy* cobj = new (std::nothrow) cocos2d::JumpBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_JumpBy_ctor, __jsb_cocos2d_JumpBy_class, js_cocos2d_JumpBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_JumpBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::JumpBy)", s.nativeThisObject());
    cocos2d::JumpBy* cobj = (cocos2d::JumpBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_JumpBy_finalize)

bool js_register_cocos2dx_JumpBy(se::Object* obj)
{
    auto cls = se::Class::create("JumpBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_JumpBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_JumpBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_JumpBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_JumpBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_JumpBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::JumpBy>(cls);

    __jsb_cocos2d_JumpBy_proto = cls->getProto();
    __jsb_cocos2d_JumpBy_class = cls;

    jsb_set_extend_property("cc", "JumpBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_JumpTo_proto = nullptr;
se::Class* __jsb_cocos2d_JumpTo_class = nullptr;

static bool js_cocos2dx_JumpTo_initWithDuration(se::State& s)
{
    cocos2d::JumpTo* cobj = (cocos2d::JumpTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_JumpTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTo_initWithDuration)

static bool js_cocos2dx_JumpTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_JumpTo_create : Error processing arguments");
        auto result = cocos2d::JumpTo::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_JumpTo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_JumpTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_JumpTo_finalize)

static bool js_cocos2dx_JumpTo_constructor(se::State& s)
{
    cocos2d::JumpTo* cobj = new (std::nothrow) cocos2d::JumpTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_JumpTo_constructor, __jsb_cocos2d_JumpTo_class, js_cocos2d_JumpTo_finalize)

static bool js_cocos2dx_JumpTo_ctor(se::State& s)
{
    cocos2d::JumpTo* cobj = new (std::nothrow) cocos2d::JumpTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_JumpTo_ctor, __jsb_cocos2d_JumpTo_class, js_cocos2d_JumpTo_finalize)


    

extern se::Object* __jsb_cocos2d_JumpBy_proto;

static bool js_cocos2d_JumpTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::JumpTo)", s.nativeThisObject());
    cocos2d::JumpTo* cobj = (cocos2d::JumpTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_JumpTo_finalize)

bool js_register_cocos2dx_JumpTo(se::Object* obj)
{
    auto cls = se::Class::create("JumpTo", obj, __jsb_cocos2d_JumpBy_proto, _SE(js_cocos2dx_JumpTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_JumpTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_JumpTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_JumpTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_JumpTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::JumpTo>(cls);

    __jsb_cocos2d_JumpTo_proto = cls->getProto();
    __jsb_cocos2d_JumpTo_class = cls;

    jsb_set_extend_property("cc", "JumpTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_BezierBy_proto = nullptr;
se::Class* __jsb_cocos2d_BezierBy_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_BezierBy_finalize)

static bool js_cocos2dx_BezierBy_constructor(se::State& s)
{
    cocos2d::BezierBy* cobj = new (std::nothrow) cocos2d::BezierBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_BezierBy_constructor, __jsb_cocos2d_BezierBy_class, js_cocos2d_BezierBy_finalize)

static bool js_cocos2dx_BezierBy_ctor(se::State& s)
{
    cocos2d::BezierBy* cobj = new (std::nothrow) cocos2d::BezierBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_BezierBy_ctor, __jsb_cocos2d_BezierBy_class, js_cocos2d_BezierBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_BezierBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::BezierBy)", s.nativeThisObject());
    cocos2d::BezierBy* cobj = (cocos2d::BezierBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_BezierBy_finalize)

bool js_register_cocos2dx_BezierBy(se::Object* obj)
{
    auto cls = se::Class::create("BezierBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_BezierBy_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_BezierBy_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_BezierBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::BezierBy>(cls);

    __jsb_cocos2d_BezierBy_proto = cls->getProto();
    __jsb_cocos2d_BezierBy_class = cls;

    jsb_set_extend_property("cc", "BezierBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_BezierTo_proto = nullptr;
se::Class* __jsb_cocos2d_BezierTo_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_BezierTo_finalize)

static bool js_cocos2dx_BezierTo_constructor(se::State& s)
{
    cocos2d::BezierTo* cobj = new (std::nothrow) cocos2d::BezierTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_BezierTo_constructor, __jsb_cocos2d_BezierTo_class, js_cocos2d_BezierTo_finalize)

static bool js_cocos2dx_BezierTo_ctor(se::State& s)
{
    cocos2d::BezierTo* cobj = new (std::nothrow) cocos2d::BezierTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_BezierTo_ctor, __jsb_cocos2d_BezierTo_class, js_cocos2d_BezierTo_finalize)


    

extern se::Object* __jsb_cocos2d_BezierBy_proto;

static bool js_cocos2d_BezierTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::BezierTo)", s.nativeThisObject());
    cocos2d::BezierTo* cobj = (cocos2d::BezierTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_BezierTo_finalize)

bool js_register_cocos2dx_BezierTo(se::Object* obj)
{
    auto cls = se::Class::create("BezierTo", obj, __jsb_cocos2d_BezierBy_proto, _SE(js_cocos2dx_BezierTo_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_BezierTo_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_BezierTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::BezierTo>(cls);

    __jsb_cocos2d_BezierTo_proto = cls->getProto();
    __jsb_cocos2d_BezierTo_class = cls;

    jsb_set_extend_property("cc", "BezierTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ScaleTo_proto = nullptr;
se::Class* __jsb_cocos2d_ScaleTo_class = nullptr;

static bool js_cocos2dx_ScaleTo_initWithDuration(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ScaleTo* cobj = (cocos2d::ScaleTo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ScaleTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_initWithDuration : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleTo_initWithDuration)

static bool js_cocos2dx_ScaleTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleTo* result = cocos2d::ScaleTo::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::ScaleTo>((cocos2d::ScaleTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ScaleTo_finalize)

static bool js_cocos2dx_ScaleTo_constructor(se::State& s)
{
    cocos2d::ScaleTo* cobj = new (std::nothrow) cocos2d::ScaleTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ScaleTo_constructor, __jsb_cocos2d_ScaleTo_class, js_cocos2d_ScaleTo_finalize)

static bool js_cocos2dx_ScaleTo_ctor(se::State& s)
{
    cocos2d::ScaleTo* cobj = new (std::nothrow) cocos2d::ScaleTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ScaleTo_ctor, __jsb_cocos2d_ScaleTo_class, js_cocos2d_ScaleTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_ScaleTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ScaleTo)", s.nativeThisObject());
    cocos2d::ScaleTo* cobj = (cocos2d::ScaleTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ScaleTo_finalize)

bool js_register_cocos2dx_ScaleTo(se::Object* obj)
{
    auto cls = se::Class::create("ScaleTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ScaleTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_ScaleTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ScaleTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ScaleTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ScaleTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ScaleTo>(cls);

    __jsb_cocos2d_ScaleTo_proto = cls->getProto();
    __jsb_cocos2d_ScaleTo_class = cls;

    jsb_set_extend_property("cc", "ScaleTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ScaleBy_proto = nullptr;
se::Class* __jsb_cocos2d_ScaleBy_class = nullptr;

static bool js_cocos2dx_ScaleBy_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::ScaleBy* result = cocos2d::ScaleBy::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::ScaleBy>((cocos2d::ScaleBy*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ScaleBy_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ScaleBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ScaleBy_finalize)

static bool js_cocos2dx_ScaleBy_constructor(se::State& s)
{
    cocos2d::ScaleBy* cobj = new (std::nothrow) cocos2d::ScaleBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ScaleBy_constructor, __jsb_cocos2d_ScaleBy_class, js_cocos2d_ScaleBy_finalize)

static bool js_cocos2dx_ScaleBy_ctor(se::State& s)
{
    cocos2d::ScaleBy* cobj = new (std::nothrow) cocos2d::ScaleBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ScaleBy_ctor, __jsb_cocos2d_ScaleBy_class, js_cocos2d_ScaleBy_finalize)


    

extern se::Object* __jsb_cocos2d_ScaleTo_proto;

static bool js_cocos2d_ScaleBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ScaleBy)", s.nativeThisObject());
    cocos2d::ScaleBy* cobj = (cocos2d::ScaleBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ScaleBy_finalize)

bool js_register_cocos2dx_ScaleBy(se::Object* obj)
{
    auto cls = se::Class::create("ScaleBy", obj, __jsb_cocos2d_ScaleTo_proto, _SE(js_cocos2dx_ScaleBy_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_ScaleBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ScaleBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ScaleBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ScaleBy>(cls);

    __jsb_cocos2d_ScaleBy_proto = cls->getProto();
    __jsb_cocos2d_ScaleBy_class = cls;

    jsb_set_extend_property("cc", "ScaleBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Blink_proto = nullptr;
se::Class* __jsb_cocos2d_Blink_class = nullptr;

static bool js_cocos2dx_Blink_initWithDuration(se::State& s)
{
    cocos2d::Blink* cobj = (cocos2d::Blink*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Blink_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Blink_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Blink_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Blink_initWithDuration)

static bool js_cocos2dx_Blink_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        int arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Blink_create : Error processing arguments");
        auto result = cocos2d::Blink::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Blink_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Blink_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Blink_finalize)

static bool js_cocos2dx_Blink_constructor(se::State& s)
{
    cocos2d::Blink* cobj = new (std::nothrow) cocos2d::Blink();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Blink_constructor, __jsb_cocos2d_Blink_class, js_cocos2d_Blink_finalize)

static bool js_cocos2dx_Blink_ctor(se::State& s)
{
    cocos2d::Blink* cobj = new (std::nothrow) cocos2d::Blink();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Blink_ctor, __jsb_cocos2d_Blink_class, js_cocos2d_Blink_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_Blink_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Blink)", s.nativeThisObject());
    cocos2d::Blink* cobj = (cocos2d::Blink*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Blink_finalize)

bool js_register_cocos2dx_Blink(se::Object* obj)
{
    auto cls = se::Class::create("Blink", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_Blink_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_Blink_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Blink_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Blink_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Blink_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Blink>(cls);

    __jsb_cocos2d_Blink_proto = cls->getProto();
    __jsb_cocos2d_Blink_class = cls;

    jsb_set_extend_property("cc", "Blink");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FadeTo_proto = nullptr;
se::Class* __jsb_cocos2d_FadeTo_class = nullptr;

static bool js_cocos2dx_FadeTo_initWithDuration(se::State& s)
{
    cocos2d::FadeTo* cobj = (cocos2d::FadeTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FadeTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        uint8_t arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], (uint8_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeTo_initWithDuration)

static bool js_cocos2dx_FadeTo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        uint8_t arg1;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], (uint8_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeTo_create : Error processing arguments");
        auto result = cocos2d::FadeTo::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeTo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeTo_finalize)

static bool js_cocos2dx_FadeTo_constructor(se::State& s)
{
    cocos2d::FadeTo* cobj = new (std::nothrow) cocos2d::FadeTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeTo_constructor, __jsb_cocos2d_FadeTo_class, js_cocos2d_FadeTo_finalize)

static bool js_cocos2dx_FadeTo_ctor(se::State& s)
{
    cocos2d::FadeTo* cobj = new (std::nothrow) cocos2d::FadeTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeTo_ctor, __jsb_cocos2d_FadeTo_class, js_cocos2d_FadeTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_FadeTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::FadeTo)", s.nativeThisObject());
    cocos2d::FadeTo* cobj = (cocos2d::FadeTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeTo_finalize)

bool js_register_cocos2dx_FadeTo(se::Object* obj)
{
    auto cls = se::Class::create("FadeTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_FadeTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_FadeTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_FadeTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeTo>(cls);

    __jsb_cocos2d_FadeTo_proto = cls->getProto();
    __jsb_cocos2d_FadeTo_class = cls;

    jsb_set_extend_property("cc", "FadeTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FadeIn_proto = nullptr;
se::Class* __jsb_cocos2d_FadeIn_class = nullptr;

static bool js_cocos2dx_FadeIn_setReverseAction(se::State& s)
{
    cocos2d::FadeIn* cobj = (cocos2d::FadeIn*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FadeIn_setReverseAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FadeTo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeIn_setReverseAction : Error processing arguments");
        cobj->setReverseAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeIn_setReverseAction)

static bool js_cocos2dx_FadeIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeIn_create : Error processing arguments");
        auto result = cocos2d::FadeIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeIn_finalize)

static bool js_cocos2dx_FadeIn_constructor(se::State& s)
{
    cocos2d::FadeIn* cobj = new (std::nothrow) cocos2d::FadeIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeIn_constructor, __jsb_cocos2d_FadeIn_class, js_cocos2d_FadeIn_finalize)

static bool js_cocos2dx_FadeIn_ctor(se::State& s)
{
    cocos2d::FadeIn* cobj = new (std::nothrow) cocos2d::FadeIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeIn_ctor, __jsb_cocos2d_FadeIn_class, js_cocos2d_FadeIn_finalize)


    

extern se::Object* __jsb_cocos2d_FadeTo_proto;

static bool js_cocos2d_FadeIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::FadeIn)", s.nativeThisObject());
    cocos2d::FadeIn* cobj = (cocos2d::FadeIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeIn_finalize)

bool js_register_cocos2dx_FadeIn(se::Object* obj)
{
    auto cls = se::Class::create("FadeIn", obj, __jsb_cocos2d_FadeTo_proto, _SE(js_cocos2dx_FadeIn_constructor));

    cls->defineFunction("setReverseAction", _SE(js_cocos2dx_FadeIn_setReverseAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_FadeIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeIn>(cls);

    __jsb_cocos2d_FadeIn_proto = cls->getProto();
    __jsb_cocos2d_FadeIn_class = cls;

    jsb_set_extend_property("cc", "FadeIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FadeOut_proto = nullptr;
se::Class* __jsb_cocos2d_FadeOut_class = nullptr;

static bool js_cocos2dx_FadeOut_setReverseAction(se::State& s)
{
    cocos2d::FadeOut* cobj = (cocos2d::FadeOut*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FadeOut_setReverseAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FadeTo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeOut_setReverseAction : Error processing arguments");
        cobj->setReverseAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOut_setReverseAction)

static bool js_cocos2dx_FadeOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FadeOut_create : Error processing arguments");
        auto result = cocos2d::FadeOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FadeOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FadeOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FadeOut_finalize)

static bool js_cocos2dx_FadeOut_constructor(se::State& s)
{
    cocos2d::FadeOut* cobj = new (std::nothrow) cocos2d::FadeOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FadeOut_constructor, __jsb_cocos2d_FadeOut_class, js_cocos2d_FadeOut_finalize)

static bool js_cocos2dx_FadeOut_ctor(se::State& s)
{
    cocos2d::FadeOut* cobj = new (std::nothrow) cocos2d::FadeOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FadeOut_ctor, __jsb_cocos2d_FadeOut_class, js_cocos2d_FadeOut_finalize)


    

extern se::Object* __jsb_cocos2d_FadeTo_proto;

static bool js_cocos2d_FadeOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::FadeOut)", s.nativeThisObject());
    cocos2d::FadeOut* cobj = (cocos2d::FadeOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FadeOut_finalize)

bool js_register_cocos2dx_FadeOut(se::Object* obj)
{
    auto cls = se::Class::create("FadeOut", obj, __jsb_cocos2d_FadeTo_proto, _SE(js_cocos2dx_FadeOut_constructor));

    cls->defineFunction("setReverseAction", _SE(js_cocos2dx_FadeOut_setReverseAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FadeOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FadeOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_FadeOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FadeOut>(cls);

    __jsb_cocos2d_FadeOut_proto = cls->getProto();
    __jsb_cocos2d_FadeOut_class = cls;

    jsb_set_extend_property("cc", "FadeOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TintTo_proto = nullptr;
se::Class* __jsb_cocos2d_TintTo_class = nullptr;

static bool js_cocos2dx_TintTo_initWithDuration(se::State& s)
{
    cocos2d::TintTo* cobj = (cocos2d::TintTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TintTo_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        uint8_t arg1;
        uint8_t arg2;
        uint8_t arg3;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_uint8(args[1], (uint8_t*)&arg1);
        ok &= seval_to_uint8(args[2], (uint8_t*)&arg2);
        ok &= seval_to_uint8(args[3], (uint8_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintTo_initWithDuration)

static bool js_cocos2dx_TintTo_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg1;
            ok &= seval_to_Color3B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TintTo* result = cocos2d::TintTo::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::TintTo>((cocos2d::TintTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            uint8_t arg1;
            ok &= seval_to_uint8(args[1], (uint8_t*)&arg1);
            if (!ok) { ok = true; break; }
            uint8_t arg2;
            ok &= seval_to_uint8(args[2], (uint8_t*)&arg2);
            if (!ok) { ok = true; break; }
            uint8_t arg3;
            ok &= seval_to_uint8(args[3], (uint8_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TintTo* result = cocos2d::TintTo::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::TintTo>((cocos2d::TintTo*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TintTo_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintTo_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TintTo_finalize)

static bool js_cocos2dx_TintTo_constructor(se::State& s)
{
    cocos2d::TintTo* cobj = new (std::nothrow) cocos2d::TintTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TintTo_constructor, __jsb_cocos2d_TintTo_class, js_cocos2d_TintTo_finalize)

static bool js_cocos2dx_TintTo_ctor(se::State& s)
{
    cocos2d::TintTo* cobj = new (std::nothrow) cocos2d::TintTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TintTo_ctor, __jsb_cocos2d_TintTo_class, js_cocos2d_TintTo_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_TintTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TintTo)", s.nativeThisObject());
    cocos2d::TintTo* cobj = (cocos2d::TintTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TintTo_finalize)

bool js_register_cocos2dx_TintTo(se::Object* obj)
{
    auto cls = se::Class::create("TintTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TintTo_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TintTo_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TintTo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TintTo_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TintTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TintTo>(cls);

    __jsb_cocos2d_TintTo_proto = cls->getProto();
    __jsb_cocos2d_TintTo_class = cls;

    jsb_set_extend_property("cc", "TintTo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TintBy_proto = nullptr;
se::Class* __jsb_cocos2d_TintBy_class = nullptr;

static bool js_cocos2dx_TintBy_initWithDuration(se::State& s)
{
    cocos2d::TintBy* cobj = (cocos2d::TintBy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TintBy_initWithDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        int16_t arg1 = 0;
        int16_t arg2 = 0;
        int16_t arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int16(args[1], &arg1);
        ok &= seval_to_int16(args[2], &arg2);
        ok &= seval_to_int16(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_initWithDuration : Error processing arguments");
        bool result = cobj->initWithDuration(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_initWithDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintBy_initWithDuration)

static bool js_cocos2dx_TintBy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        int16_t arg1 = 0;
        int16_t arg2 = 0;
        int16_t arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_int16(args[1], &arg1);
        ok &= seval_to_int16(args[2], &arg2);
        ok &= seval_to_int16(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TintBy_create : Error processing arguments");
        auto result = cocos2d::TintBy::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TintBy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TintBy_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TintBy_finalize)

static bool js_cocos2dx_TintBy_constructor(se::State& s)
{
    cocos2d::TintBy* cobj = new (std::nothrow) cocos2d::TintBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TintBy_constructor, __jsb_cocos2d_TintBy_class, js_cocos2d_TintBy_finalize)

static bool js_cocos2dx_TintBy_ctor(se::State& s)
{
    cocos2d::TintBy* cobj = new (std::nothrow) cocos2d::TintBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TintBy_ctor, __jsb_cocos2d_TintBy_class, js_cocos2d_TintBy_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_TintBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TintBy)", s.nativeThisObject());
    cocos2d::TintBy* cobj = (cocos2d::TintBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TintBy_finalize)

bool js_register_cocos2dx_TintBy(se::Object* obj)
{
    auto cls = se::Class::create("TintBy", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TintBy_constructor));

    cls->defineFunction("initWithDuration", _SE(js_cocos2dx_TintBy_initWithDuration));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TintBy_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TintBy_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TintBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TintBy>(cls);

    __jsb_cocos2d_TintBy_proto = cls->getProto();
    __jsb_cocos2d_TintBy_class = cls;

    jsb_set_extend_property("cc", "TintBy");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_DelayTime_proto = nullptr;
se::Class* __jsb_cocos2d_DelayTime_class = nullptr;

static bool js_cocos2dx_DelayTime_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DelayTime_create : Error processing arguments");
        auto result = cocos2d::DelayTime::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DelayTime_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DelayTime_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_DelayTime_finalize)

static bool js_cocos2dx_DelayTime_constructor(se::State& s)
{
    cocos2d::DelayTime* cobj = new (std::nothrow) cocos2d::DelayTime();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_DelayTime_constructor, __jsb_cocos2d_DelayTime_class, js_cocos2d_DelayTime_finalize)

static bool js_cocos2dx_DelayTime_ctor(se::State& s)
{
    cocos2d::DelayTime* cobj = new (std::nothrow) cocos2d::DelayTime();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_DelayTime_ctor, __jsb_cocos2d_DelayTime_class, js_cocos2d_DelayTime_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_DelayTime_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::DelayTime)", s.nativeThisObject());
    cocos2d::DelayTime* cobj = (cocos2d::DelayTime*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_DelayTime_finalize)

bool js_register_cocos2dx_DelayTime(se::Object* obj)
{
    auto cls = se::Class::create("DelayTime", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_DelayTime_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_DelayTime_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_DelayTime_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_DelayTime_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::DelayTime>(cls);

    __jsb_cocos2d_DelayTime_proto = cls->getProto();
    __jsb_cocos2d_DelayTime_class = cls;

    jsb_set_extend_property("cc", "DelayTime");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ReverseTime_proto = nullptr;
se::Class* __jsb_cocos2d_ReverseTime_class = nullptr;

static bool js_cocos2dx_ReverseTime_initWithAction(se::State& s)
{
    cocos2d::ReverseTime* cobj = (cocos2d::ReverseTime*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ReverseTime_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReverseTime_initWithAction)

static bool js_cocos2dx_ReverseTime_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FiniteTimeAction* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ReverseTime_create : Error processing arguments");
        auto result = cocos2d::ReverseTime::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ReverseTime_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ReverseTime_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ReverseTime_finalize)

static bool js_cocos2dx_ReverseTime_constructor(se::State& s)
{
    cocos2d::ReverseTime* cobj = new (std::nothrow) cocos2d::ReverseTime();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ReverseTime_constructor, __jsb_cocos2d_ReverseTime_class, js_cocos2d_ReverseTime_finalize)

static bool js_cocos2dx_ReverseTime_ctor(se::State& s)
{
    cocos2d::ReverseTime* cobj = new (std::nothrow) cocos2d::ReverseTime();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ReverseTime_ctor, __jsb_cocos2d_ReverseTime_class, js_cocos2d_ReverseTime_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_ReverseTime_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ReverseTime)", s.nativeThisObject());
    cocos2d::ReverseTime* cobj = (cocos2d::ReverseTime*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ReverseTime_finalize)

bool js_register_cocos2dx_ReverseTime(se::Object* obj)
{
    auto cls = se::Class::create("ReverseTime", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_ReverseTime_constructor));

    cls->defineFunction("initWithAction", _SE(js_cocos2dx_ReverseTime_initWithAction));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ReverseTime_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ReverseTime_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ReverseTime_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ReverseTime>(cls);

    __jsb_cocos2d_ReverseTime_proto = cls->getProto();
    __jsb_cocos2d_ReverseTime_class = cls;

    jsb_set_extend_property("cc", "ReverseTime");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TargetedAction_proto = nullptr;
se::Class* __jsb_cocos2d_TargetedAction_class = nullptr;

static bool js_cocos2dx_TargetedAction_getForcedTarget(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TargetedAction_getForcedTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            const cocos2d::Node* result = cobj->getForcedTarget();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_getForcedTarget : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cocos2d::Node* result = cobj->getForcedTarget();
            ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_getForcedTarget : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_getForcedTarget)

static bool js_cocos2dx_TargetedAction_initWithTarget(se::State& s)
{
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TargetedAction_initWithTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::FiniteTimeAction* arg1 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_initWithTarget : Error processing arguments");
        bool result = cobj->initWithTarget(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_initWithTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_initWithTarget)

static bool js_cocos2dx_TargetedAction_setForcedTarget(se::State& s)
{
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TargetedAction_setForcedTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TargetedAction_setForcedTarget : Error processing arguments");
        cobj->setForcedTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TargetedAction_setForcedTarget)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TargetedAction_finalize)

static bool js_cocos2dx_TargetedAction_constructor(se::State& s)
{
    cocos2d::TargetedAction* cobj = new (std::nothrow) cocos2d::TargetedAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TargetedAction_constructor, __jsb_cocos2d_TargetedAction_class, js_cocos2d_TargetedAction_finalize)

static bool js_cocos2dx_TargetedAction_ctor(se::State& s)
{
    cocos2d::TargetedAction* cobj = new (std::nothrow) cocos2d::TargetedAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TargetedAction_ctor, __jsb_cocos2d_TargetedAction_class, js_cocos2d_TargetedAction_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_TargetedAction_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TargetedAction)", s.nativeThisObject());
    cocos2d::TargetedAction* cobj = (cocos2d::TargetedAction*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TargetedAction_finalize)

bool js_register_cocos2dx_TargetedAction(se::Object* obj)
{
    auto cls = se::Class::create("TargetedAction", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_TargetedAction_constructor));

    cls->defineFunction("getForcedTarget", _SE(js_cocos2dx_TargetedAction_getForcedTarget));
    cls->defineFunction("initWithTarget", _SE(js_cocos2dx_TargetedAction_initWithTarget));
    cls->defineFunction("setForcedTarget", _SE(js_cocos2dx_TargetedAction_setForcedTarget));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TargetedAction_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TargetedAction_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TargetedAction>(cls);

    __jsb_cocos2d_TargetedAction_proto = cls->getProto();
    __jsb_cocos2d_TargetedAction_class = cls;

    jsb_set_extend_property("cc", "TargetedAction");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CardinalSplineTo_proto = nullptr;
se::Class* __jsb_cocos2d_CardinalSplineTo_class = nullptr;

static bool js_cocos2dx_CardinalSplineTo_updatePosition(se::State& s)
{
    cocos2d::CardinalSplineTo* cobj = (cocos2d::CardinalSplineTo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_CardinalSplineTo_updatePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_CardinalSplineTo_updatePosition : Error processing arguments");
        cobj->updatePosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CardinalSplineTo_updatePosition)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CardinalSplineTo_finalize)

static bool js_cocos2dx_CardinalSplineTo_constructor(se::State& s)
{
    cocos2d::CardinalSplineTo* cobj = new (std::nothrow) cocos2d::CardinalSplineTo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CardinalSplineTo_constructor, __jsb_cocos2d_CardinalSplineTo_class, js_cocos2d_CardinalSplineTo_finalize)



extern se::Object* __jsb_cocos2d_ActionInterval_proto;

static bool js_cocos2d_CardinalSplineTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CardinalSplineTo)", s.nativeThisObject());
    cocos2d::CardinalSplineTo* cobj = (cocos2d::CardinalSplineTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CardinalSplineTo_finalize)

bool js_register_cocos2dx_CardinalSplineTo(se::Object* obj)
{
    auto cls = se::Class::create("CardinalSplineTo", obj, __jsb_cocos2d_ActionInterval_proto, _SE(js_cocos2dx_CardinalSplineTo_constructor));

    cls->defineFunction("updatePosition", _SE(js_cocos2dx_CardinalSplineTo_updatePosition));
    cls->defineFinalizeFunction(_SE(js_cocos2d_CardinalSplineTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CardinalSplineTo>(cls);

    __jsb_cocos2d_CardinalSplineTo_proto = cls->getProto();
    __jsb_cocos2d_CardinalSplineTo_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CardinalSplineBy_proto = nullptr;
se::Class* __jsb_cocos2d_CardinalSplineBy_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CardinalSplineBy_finalize)

static bool js_cocos2dx_CardinalSplineBy_constructor(se::State& s)
{
    cocos2d::CardinalSplineBy* cobj = new (std::nothrow) cocos2d::CardinalSplineBy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CardinalSplineBy_constructor, __jsb_cocos2d_CardinalSplineBy_class, js_cocos2d_CardinalSplineBy_finalize)



extern se::Object* __jsb_cocos2d_CardinalSplineTo_proto;

static bool js_cocos2d_CardinalSplineBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CardinalSplineBy)", s.nativeThisObject());
    cocos2d::CardinalSplineBy* cobj = (cocos2d::CardinalSplineBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CardinalSplineBy_finalize)

bool js_register_cocos2dx_CardinalSplineBy(se::Object* obj)
{
    auto cls = se::Class::create("CardinalSplineBy", obj, __jsb_cocos2d_CardinalSplineTo_proto, _SE(js_cocos2dx_CardinalSplineBy_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_CardinalSplineBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CardinalSplineBy>(cls);

    __jsb_cocos2d_CardinalSplineBy_proto = cls->getProto();
    __jsb_cocos2d_CardinalSplineBy_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CatmullRomTo_proto = nullptr;
se::Class* __jsb_cocos2d_CatmullRomTo_class = nullptr;


extern se::Object* __jsb_cocos2d_CardinalSplineTo_proto;

static bool js_cocos2d_CatmullRomTo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CatmullRomTo)", s.nativeThisObject());
    cocos2d::CatmullRomTo* cobj = (cocos2d::CatmullRomTo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CatmullRomTo_finalize)

bool js_register_cocos2dx_CatmullRomTo(se::Object* obj)
{
    auto cls = se::Class::create("CatmullRomTo", obj, __jsb_cocos2d_CardinalSplineTo_proto, nullptr);

    cls->defineFinalizeFunction(_SE(js_cocos2d_CatmullRomTo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CatmullRomTo>(cls);

    __jsb_cocos2d_CatmullRomTo_proto = cls->getProto();
    __jsb_cocos2d_CatmullRomTo_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CatmullRomBy_proto = nullptr;
se::Class* __jsb_cocos2d_CatmullRomBy_class = nullptr;


extern se::Object* __jsb_cocos2d_CardinalSplineBy_proto;

static bool js_cocos2d_CatmullRomBy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CatmullRomBy)", s.nativeThisObject());
    cocos2d::CatmullRomBy* cobj = (cocos2d::CatmullRomBy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CatmullRomBy_finalize)

bool js_register_cocos2dx_CatmullRomBy(se::Object* obj)
{
    auto cls = se::Class::create("CatmullRomBy", obj, __jsb_cocos2d_CardinalSplineBy_proto, nullptr);

    cls->defineFinalizeFunction(_SE(js_cocos2d_CatmullRomBy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CatmullRomBy>(cls);

    __jsb_cocos2d_CatmullRomBy_proto = cls->getProto();
    __jsb_cocos2d_CatmullRomBy_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ActionEase_proto = nullptr;
se::Class* __jsb_cocos2d_ActionEase_class = nullptr;

static bool js_cocos2dx_ActionEase_initWithAction(se::State& s)
{
    cocos2d::ActionEase* cobj = (cocos2d::ActionEase*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionEase_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionEase_initWithAction)

static bool js_cocos2dx_ActionEase_getInnerAction(se::State& s)
{
    cocos2d::ActionEase* cobj = (cocos2d::ActionEase*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionEase_getInnerAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ActionInterval* result = cobj->getInnerAction();
        ok &= native_ptr_to_seval<cocos2d::ActionInterval>((cocos2d::ActionInterval*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionEase_getInnerAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionEase_getInnerAction)


extern se::Object* __jsb_cocos2d_ActionInterval_proto;


bool js_register_cocos2dx_ActionEase(se::Object* obj)
{
    auto cls = se::Class::create("ActionEase", obj, __jsb_cocos2d_ActionInterval_proto, nullptr);

    cls->defineFunction("initWithAction", _SE(js_cocos2dx_ActionEase_initWithAction));
    cls->defineFunction("getInnerAction", _SE(js_cocos2dx_ActionEase_getInnerAction));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionEase>(cls);

    __jsb_cocos2d_ActionEase_proto = cls->getProto();
    __jsb_cocos2d_ActionEase_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseRateAction_proto = nullptr;
se::Class* __jsb_cocos2d_EaseRateAction_class = nullptr;

static bool js_cocos2dx_EaseRateAction_setRate(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_setRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_setRate : Error processing arguments");
        cobj->setRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_setRate)

static bool js_cocos2dx_EaseRateAction_initWithAction(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_initWithAction)

static bool js_cocos2dx_EaseRateAction_getRate(se::State& s)
{
    cocos2d::EaseRateAction* cobj = (cocos2d::EaseRateAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseRateAction_getRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRate();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_getRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_getRate)

static bool js_cocos2dx_EaseRateAction_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseRateAction_create : Error processing arguments");
        auto result = cocos2d::EaseRateAction::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseRateAction_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseRateAction_create)


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseRateAction(se::Object* obj)
{
    auto cls = se::Class::create("EaseRateAction", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->defineFunction("setRate", _SE(js_cocos2dx_EaseRateAction_setRate));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_EaseRateAction_initWithAction));
    cls->defineFunction("getRate", _SE(js_cocos2dx_EaseRateAction_getRate));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseRateAction_create));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseRateAction>(cls);

    __jsb_cocos2d_EaseRateAction_proto = cls->getProto();
    __jsb_cocos2d_EaseRateAction_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseIn_class = nullptr;

static bool js_cocos2dx_EaseIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseIn_create : Error processing arguments");
        auto result = cocos2d::EaseIn::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseIn_finalize)

static bool js_cocos2dx_EaseIn_constructor(se::State& s)
{
    cocos2d::EaseIn* cobj = new (std::nothrow) cocos2d::EaseIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseIn_constructor, __jsb_cocos2d_EaseIn_class, js_cocos2d_EaseIn_finalize)

static bool js_cocos2dx_EaseIn_ctor(se::State& s)
{
    cocos2d::EaseIn* cobj = new (std::nothrow) cocos2d::EaseIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseIn_ctor, __jsb_cocos2d_EaseIn_class, js_cocos2d_EaseIn_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

static bool js_cocos2d_EaseIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseIn)", s.nativeThisObject());
    cocos2d::EaseIn* cobj = (cocos2d::EaseIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseIn_finalize)

bool js_register_cocos2dx_EaseIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseIn", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseIn>(cls);

    __jsb_cocos2d_EaseIn_proto = cls->getProto();
    __jsb_cocos2d_EaseIn_class = cls;

    jsb_set_extend_property("cc", "EaseIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseOut_class = nullptr;

static bool js_cocos2dx_EaseOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseOut_create : Error processing arguments");
        auto result = cocos2d::EaseOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseOut_finalize)

static bool js_cocos2dx_EaseOut_constructor(se::State& s)
{
    cocos2d::EaseOut* cobj = new (std::nothrow) cocos2d::EaseOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseOut_constructor, __jsb_cocos2d_EaseOut_class, js_cocos2d_EaseOut_finalize)

static bool js_cocos2dx_EaseOut_ctor(se::State& s)
{
    cocos2d::EaseOut* cobj = new (std::nothrow) cocos2d::EaseOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseOut_ctor, __jsb_cocos2d_EaseOut_class, js_cocos2d_EaseOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

static bool js_cocos2d_EaseOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseOut)", s.nativeThisObject());
    cocos2d::EaseOut* cobj = (cocos2d::EaseOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseOut_finalize)

bool js_register_cocos2dx_EaseOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseOut", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseOut>(cls);

    __jsb_cocos2d_EaseOut_proto = cls->getProto();
    __jsb_cocos2d_EaseOut_class = cls;

    jsb_set_extend_property("cc", "EaseOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseInOut_class = nullptr;

static bool js_cocos2dx_EaseInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseInOut_create : Error processing arguments");
        auto result = cocos2d::EaseInOut::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseInOut_finalize)

static bool js_cocos2dx_EaseInOut_constructor(se::State& s)
{
    cocos2d::EaseInOut* cobj = new (std::nothrow) cocos2d::EaseInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseInOut_constructor, __jsb_cocos2d_EaseInOut_class, js_cocos2d_EaseInOut_finalize)

static bool js_cocos2dx_EaseInOut_ctor(se::State& s)
{
    cocos2d::EaseInOut* cobj = new (std::nothrow) cocos2d::EaseInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseInOut_ctor, __jsb_cocos2d_EaseInOut_class, js_cocos2d_EaseInOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseRateAction_proto;

static bool js_cocos2d_EaseInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseInOut)", s.nativeThisObject());
    cocos2d::EaseInOut* cobj = (cocos2d::EaseInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseInOut_finalize)

bool js_register_cocos2dx_EaseInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseInOut", obj, __jsb_cocos2d_EaseRateAction_proto, _SE(js_cocos2dx_EaseInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseInOut>(cls);

    __jsb_cocos2d_EaseInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseInOut_class = cls;

    jsb_set_extend_property("cc", "EaseInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialIn_class = nullptr;

static bool js_cocos2dx_EaseExponentialIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialIn_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialIn_finalize)

static bool js_cocos2dx_EaseExponentialIn_constructor(se::State& s)
{
    cocos2d::EaseExponentialIn* cobj = new (std::nothrow) cocos2d::EaseExponentialIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialIn_constructor, __jsb_cocos2d_EaseExponentialIn_class, js_cocos2d_EaseExponentialIn_finalize)

static bool js_cocos2dx_EaseExponentialIn_ctor(se::State& s)
{
    cocos2d::EaseExponentialIn* cobj = new (std::nothrow) cocos2d::EaseExponentialIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialIn_ctor, __jsb_cocos2d_EaseExponentialIn_class, js_cocos2d_EaseExponentialIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseExponentialIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialIn)", s.nativeThisObject());
    cocos2d::EaseExponentialIn* cobj = (cocos2d::EaseExponentialIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialIn_finalize)

bool js_register_cocos2dx_EaseExponentialIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseExponentialIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialIn>(cls);

    __jsb_cocos2d_EaseExponentialIn_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialIn_class = cls;

    jsb_set_extend_property("cc", "EaseExponentialIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialOut_class = nullptr;

static bool js_cocos2dx_EaseExponentialOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialOut_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialOut_finalize)

static bool js_cocos2dx_EaseExponentialOut_constructor(se::State& s)
{
    cocos2d::EaseExponentialOut* cobj = new (std::nothrow) cocos2d::EaseExponentialOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialOut_constructor, __jsb_cocos2d_EaseExponentialOut_class, js_cocos2d_EaseExponentialOut_finalize)

static bool js_cocos2dx_EaseExponentialOut_ctor(se::State& s)
{
    cocos2d::EaseExponentialOut* cobj = new (std::nothrow) cocos2d::EaseExponentialOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialOut_ctor, __jsb_cocos2d_EaseExponentialOut_class, js_cocos2d_EaseExponentialOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseExponentialOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialOut)", s.nativeThisObject());
    cocos2d::EaseExponentialOut* cobj = (cocos2d::EaseExponentialOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialOut_finalize)

bool js_register_cocos2dx_EaseExponentialOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseExponentialOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialOut>(cls);

    __jsb_cocos2d_EaseExponentialOut_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialOut_class = cls;

    jsb_set_extend_property("cc", "EaseExponentialOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseExponentialInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseExponentialInOut_class = nullptr;

static bool js_cocos2dx_EaseExponentialInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseExponentialInOut_create : Error processing arguments");
        auto result = cocos2d::EaseExponentialInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseExponentialInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseExponentialInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseExponentialInOut_finalize)

static bool js_cocos2dx_EaseExponentialInOut_constructor(se::State& s)
{
    cocos2d::EaseExponentialInOut* cobj = new (std::nothrow) cocos2d::EaseExponentialInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseExponentialInOut_constructor, __jsb_cocos2d_EaseExponentialInOut_class, js_cocos2d_EaseExponentialInOut_finalize)

static bool js_cocos2dx_EaseExponentialInOut_ctor(se::State& s)
{
    cocos2d::EaseExponentialInOut* cobj = new (std::nothrow) cocos2d::EaseExponentialInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseExponentialInOut_ctor, __jsb_cocos2d_EaseExponentialInOut_class, js_cocos2d_EaseExponentialInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseExponentialInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseExponentialInOut)", s.nativeThisObject());
    cocos2d::EaseExponentialInOut* cobj = (cocos2d::EaseExponentialInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseExponentialInOut_finalize)

bool js_register_cocos2dx_EaseExponentialInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseExponentialInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseExponentialInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseExponentialInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseExponentialInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseExponentialInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseExponentialInOut>(cls);

    __jsb_cocos2d_EaseExponentialInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseExponentialInOut_class = cls;

    jsb_set_extend_property("cc", "EaseExponentialInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseSineIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineIn_class = nullptr;

static bool js_cocos2dx_EaseSineIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineIn_create : Error processing arguments");
        auto result = cocos2d::EaseSineIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineIn_finalize)

static bool js_cocos2dx_EaseSineIn_constructor(se::State& s)
{
    cocos2d::EaseSineIn* cobj = new (std::nothrow) cocos2d::EaseSineIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineIn_constructor, __jsb_cocos2d_EaseSineIn_class, js_cocos2d_EaseSineIn_finalize)

static bool js_cocos2dx_EaseSineIn_ctor(se::State& s)
{
    cocos2d::EaseSineIn* cobj = new (std::nothrow) cocos2d::EaseSineIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineIn_ctor, __jsb_cocos2d_EaseSineIn_class, js_cocos2d_EaseSineIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseSineIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseSineIn)", s.nativeThisObject());
    cocos2d::EaseSineIn* cobj = (cocos2d::EaseSineIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineIn_finalize)

bool js_register_cocos2dx_EaseSineIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseSineIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineIn>(cls);

    __jsb_cocos2d_EaseSineIn_proto = cls->getProto();
    __jsb_cocos2d_EaseSineIn_class = cls;

    jsb_set_extend_property("cc", "EaseSineIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseSineOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineOut_class = nullptr;

static bool js_cocos2dx_EaseSineOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineOut_create : Error processing arguments");
        auto result = cocos2d::EaseSineOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineOut_finalize)

static bool js_cocos2dx_EaseSineOut_constructor(se::State& s)
{
    cocos2d::EaseSineOut* cobj = new (std::nothrow) cocos2d::EaseSineOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineOut_constructor, __jsb_cocos2d_EaseSineOut_class, js_cocos2d_EaseSineOut_finalize)

static bool js_cocos2dx_EaseSineOut_ctor(se::State& s)
{
    cocos2d::EaseSineOut* cobj = new (std::nothrow) cocos2d::EaseSineOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineOut_ctor, __jsb_cocos2d_EaseSineOut_class, js_cocos2d_EaseSineOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseSineOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseSineOut)", s.nativeThisObject());
    cocos2d::EaseSineOut* cobj = (cocos2d::EaseSineOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineOut_finalize)

bool js_register_cocos2dx_EaseSineOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseSineOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineOut>(cls);

    __jsb_cocos2d_EaseSineOut_proto = cls->getProto();
    __jsb_cocos2d_EaseSineOut_class = cls;

    jsb_set_extend_property("cc", "EaseSineOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseSineInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseSineInOut_class = nullptr;

static bool js_cocos2dx_EaseSineInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseSineInOut_create : Error processing arguments");
        auto result = cocos2d::EaseSineInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseSineInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseSineInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseSineInOut_finalize)

static bool js_cocos2dx_EaseSineInOut_constructor(se::State& s)
{
    cocos2d::EaseSineInOut* cobj = new (std::nothrow) cocos2d::EaseSineInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseSineInOut_constructor, __jsb_cocos2d_EaseSineInOut_class, js_cocos2d_EaseSineInOut_finalize)

static bool js_cocos2dx_EaseSineInOut_ctor(se::State& s)
{
    cocos2d::EaseSineInOut* cobj = new (std::nothrow) cocos2d::EaseSineInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseSineInOut_ctor, __jsb_cocos2d_EaseSineInOut_class, js_cocos2d_EaseSineInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseSineInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseSineInOut)", s.nativeThisObject());
    cocos2d::EaseSineInOut* cobj = (cocos2d::EaseSineInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseSineInOut_finalize)

bool js_register_cocos2dx_EaseSineInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseSineInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseSineInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseSineInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseSineInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseSineInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseSineInOut>(cls);

    __jsb_cocos2d_EaseSineInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseSineInOut_class = cls;

    jsb_set_extend_property("cc", "EaseSineInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseElastic_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElastic_class = nullptr;

static bool js_cocos2dx_EaseElastic_setPeriod(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_setPeriod : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_setPeriod : Error processing arguments");
        cobj->setPeriod(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_setPeriod)

static bool js_cocos2dx_EaseElastic_initWithAction(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_initWithAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::ActionInterval* arg0 = nullptr;
        float arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        bool result = cobj->initWithAction(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_initWithAction : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_initWithAction)

static bool js_cocos2dx_EaseElastic_getPeriod(se::State& s)
{
    cocos2d::EaseElastic* cobj = (cocos2d::EaseElastic*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseElastic_getPeriod : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getPeriod();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElastic_getPeriod : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElastic_getPeriod)


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseElastic(se::Object* obj)
{
    auto cls = se::Class::create("EaseElastic", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->defineFunction("setPeriod", _SE(js_cocos2dx_EaseElastic_setPeriod));
    cls->defineFunction("initWithAction", _SE(js_cocos2dx_EaseElastic_initWithAction));
    cls->defineFunction("getPeriod", _SE(js_cocos2dx_EaseElastic_getPeriod));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElastic>(cls);

    __jsb_cocos2d_EaseElastic_proto = cls->getProto();
    __jsb_cocos2d_EaseElastic_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseElasticIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticIn_class = nullptr;

static bool js_cocos2dx_EaseElasticIn_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticIn* result = cocos2d::EaseElasticIn::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticIn>((cocos2d::EaseElasticIn*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticIn_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticIn* result = cocos2d::EaseElasticIn::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticIn>((cocos2d::EaseElasticIn*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticIn_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticIn_finalize)

static bool js_cocos2dx_EaseElasticIn_constructor(se::State& s)
{
    cocos2d::EaseElasticIn* cobj = new (std::nothrow) cocos2d::EaseElasticIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticIn_constructor, __jsb_cocos2d_EaseElasticIn_class, js_cocos2d_EaseElasticIn_finalize)

static bool js_cocos2dx_EaseElasticIn_ctor(se::State& s)
{
    cocos2d::EaseElasticIn* cobj = new (std::nothrow) cocos2d::EaseElasticIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticIn_ctor, __jsb_cocos2d_EaseElasticIn_class, js_cocos2d_EaseElasticIn_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

static bool js_cocos2d_EaseElasticIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseElasticIn)", s.nativeThisObject());
    cocos2d::EaseElasticIn* cobj = (cocos2d::EaseElasticIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticIn_finalize)

bool js_register_cocos2dx_EaseElasticIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticIn", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseElasticIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticIn>(cls);

    __jsb_cocos2d_EaseElasticIn_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticIn_class = cls;

    jsb_set_extend_property("cc", "EaseElasticIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseElasticOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticOut_class = nullptr;

static bool js_cocos2dx_EaseElasticOut_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticOut* result = cocos2d::EaseElasticOut::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticOut>((cocos2d::EaseElasticOut*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticOut_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticOut* result = cocos2d::EaseElasticOut::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticOut>((cocos2d::EaseElasticOut*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticOut_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticOut_finalize)

static bool js_cocos2dx_EaseElasticOut_constructor(se::State& s)
{
    cocos2d::EaseElasticOut* cobj = new (std::nothrow) cocos2d::EaseElasticOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticOut_constructor, __jsb_cocos2d_EaseElasticOut_class, js_cocos2d_EaseElasticOut_finalize)

static bool js_cocos2dx_EaseElasticOut_ctor(se::State& s)
{
    cocos2d::EaseElasticOut* cobj = new (std::nothrow) cocos2d::EaseElasticOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticOut_ctor, __jsb_cocos2d_EaseElasticOut_class, js_cocos2d_EaseElasticOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

static bool js_cocos2d_EaseElasticOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseElasticOut)", s.nativeThisObject());
    cocos2d::EaseElasticOut* cobj = (cocos2d::EaseElasticOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticOut_finalize)

bool js_register_cocos2dx_EaseElasticOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticOut", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseElasticOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticOut>(cls);

    __jsb_cocos2d_EaseElasticOut_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticOut_class = cls;

    jsb_set_extend_property("cc", "EaseElasticOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseElasticInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseElasticInOut_class = nullptr;

static bool js_cocos2dx_EaseElasticInOut_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticInOut* result = cocos2d::EaseElasticInOut::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticInOut>((cocos2d::EaseElasticInOut*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticInOut_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            cocos2d::ActionInterval* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::EaseElasticInOut* result = cocos2d::EaseElasticInOut::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::EaseElasticInOut>((cocos2d::EaseElasticInOut*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseElasticInOut_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseElasticInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseElasticInOut_finalize)

static bool js_cocos2dx_EaseElasticInOut_constructor(se::State& s)
{
    cocos2d::EaseElasticInOut* cobj = new (std::nothrow) cocos2d::EaseElasticInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseElasticInOut_constructor, __jsb_cocos2d_EaseElasticInOut_class, js_cocos2d_EaseElasticInOut_finalize)

static bool js_cocos2dx_EaseElasticInOut_ctor(se::State& s)
{
    cocos2d::EaseElasticInOut* cobj = new (std::nothrow) cocos2d::EaseElasticInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseElasticInOut_ctor, __jsb_cocos2d_EaseElasticInOut_class, js_cocos2d_EaseElasticInOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseElastic_proto;

static bool js_cocos2d_EaseElasticInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseElasticInOut)", s.nativeThisObject());
    cocos2d::EaseElasticInOut* cobj = (cocos2d::EaseElasticInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseElasticInOut_finalize)

bool js_register_cocos2dx_EaseElasticInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseElasticInOut", obj, __jsb_cocos2d_EaseElastic_proto, _SE(js_cocos2dx_EaseElasticInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseElasticInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseElasticInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseElasticInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseElasticInOut>(cls);

    __jsb_cocos2d_EaseElasticInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseElasticInOut_class = cls;

    jsb_set_extend_property("cc", "EaseElasticInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBounce_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounce_class = nullptr;


extern se::Object* __jsb_cocos2d_ActionEase_proto;


bool js_register_cocos2dx_EaseBounce(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounce", obj, __jsb_cocos2d_ActionEase_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounce>(cls);

    __jsb_cocos2d_EaseBounce_proto = cls->getProto();
    __jsb_cocos2d_EaseBounce_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBounceIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceIn_class = nullptr;

static bool js_cocos2dx_EaseBounceIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceIn_create : Error processing arguments");
        auto result = cocos2d::EaseBounceIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceIn_finalize)

static bool js_cocos2dx_EaseBounceIn_constructor(se::State& s)
{
    cocos2d::EaseBounceIn* cobj = new (std::nothrow) cocos2d::EaseBounceIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceIn_constructor, __jsb_cocos2d_EaseBounceIn_class, js_cocos2d_EaseBounceIn_finalize)

static bool js_cocos2dx_EaseBounceIn_ctor(se::State& s)
{
    cocos2d::EaseBounceIn* cobj = new (std::nothrow) cocos2d::EaseBounceIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceIn_ctor, __jsb_cocos2d_EaseBounceIn_class, js_cocos2d_EaseBounceIn_finalize)


    

extern se::Object* __jsb_cocos2d_EaseBounce_proto;

static bool js_cocos2d_EaseBounceIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBounceIn)", s.nativeThisObject());
    cocos2d::EaseBounceIn* cobj = (cocos2d::EaseBounceIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceIn_finalize)

bool js_register_cocos2dx_EaseBounceIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceIn", obj, __jsb_cocos2d_EaseBounce_proto, _SE(js_cocos2dx_EaseBounceIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBounceIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceIn>(cls);

    __jsb_cocos2d_EaseBounceIn_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceIn_class = cls;

    jsb_set_extend_property("cc", "EaseBounceIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBounceOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceOut_class = nullptr;

static bool js_cocos2dx_EaseBounceOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceOut_create : Error processing arguments");
        auto result = cocos2d::EaseBounceOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceOut_finalize)

static bool js_cocos2dx_EaseBounceOut_constructor(se::State& s)
{
    cocos2d::EaseBounceOut* cobj = new (std::nothrow) cocos2d::EaseBounceOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceOut_constructor, __jsb_cocos2d_EaseBounceOut_class, js_cocos2d_EaseBounceOut_finalize)

static bool js_cocos2dx_EaseBounceOut_ctor(se::State& s)
{
    cocos2d::EaseBounceOut* cobj = new (std::nothrow) cocos2d::EaseBounceOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceOut_ctor, __jsb_cocos2d_EaseBounceOut_class, js_cocos2d_EaseBounceOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseBounce_proto;

static bool js_cocos2d_EaseBounceOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBounceOut)", s.nativeThisObject());
    cocos2d::EaseBounceOut* cobj = (cocos2d::EaseBounceOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceOut_finalize)

bool js_register_cocos2dx_EaseBounceOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceOut", obj, __jsb_cocos2d_EaseBounce_proto, _SE(js_cocos2dx_EaseBounceOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBounceOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceOut>(cls);

    __jsb_cocos2d_EaseBounceOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceOut_class = cls;

    jsb_set_extend_property("cc", "EaseBounceOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBounceInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBounceInOut_class = nullptr;

static bool js_cocos2dx_EaseBounceInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBounceInOut_create : Error processing arguments");
        auto result = cocos2d::EaseBounceInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBounceInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBounceInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBounceInOut_finalize)

static bool js_cocos2dx_EaseBounceInOut_constructor(se::State& s)
{
    cocos2d::EaseBounceInOut* cobj = new (std::nothrow) cocos2d::EaseBounceInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBounceInOut_constructor, __jsb_cocos2d_EaseBounceInOut_class, js_cocos2d_EaseBounceInOut_finalize)

static bool js_cocos2dx_EaseBounceInOut_ctor(se::State& s)
{
    cocos2d::EaseBounceInOut* cobj = new (std::nothrow) cocos2d::EaseBounceInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBounceInOut_ctor, __jsb_cocos2d_EaseBounceInOut_class, js_cocos2d_EaseBounceInOut_finalize)


    

extern se::Object* __jsb_cocos2d_EaseBounce_proto;

static bool js_cocos2d_EaseBounceInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBounceInOut)", s.nativeThisObject());
    cocos2d::EaseBounceInOut* cobj = (cocos2d::EaseBounceInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBounceInOut_finalize)

bool js_register_cocos2dx_EaseBounceInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBounceInOut", obj, __jsb_cocos2d_EaseBounce_proto, _SE(js_cocos2dx_EaseBounceInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBounceInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBounceInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBounceInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBounceInOut>(cls);

    __jsb_cocos2d_EaseBounceInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBounceInOut_class = cls;

    jsb_set_extend_property("cc", "EaseBounceInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBackIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackIn_class = nullptr;

static bool js_cocos2dx_EaseBackIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackIn_create : Error processing arguments");
        auto result = cocos2d::EaseBackIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackIn_finalize)

static bool js_cocos2dx_EaseBackIn_constructor(se::State& s)
{
    cocos2d::EaseBackIn* cobj = new (std::nothrow) cocos2d::EaseBackIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackIn_constructor, __jsb_cocos2d_EaseBackIn_class, js_cocos2d_EaseBackIn_finalize)

static bool js_cocos2dx_EaseBackIn_ctor(se::State& s)
{
    cocos2d::EaseBackIn* cobj = new (std::nothrow) cocos2d::EaseBackIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackIn_ctor, __jsb_cocos2d_EaseBackIn_class, js_cocos2d_EaseBackIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseBackIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBackIn)", s.nativeThisObject());
    cocos2d::EaseBackIn* cobj = (cocos2d::EaseBackIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackIn_finalize)

bool js_register_cocos2dx_EaseBackIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBackIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackIn>(cls);

    __jsb_cocos2d_EaseBackIn_proto = cls->getProto();
    __jsb_cocos2d_EaseBackIn_class = cls;

    jsb_set_extend_property("cc", "EaseBackIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBackOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackOut_class = nullptr;

static bool js_cocos2dx_EaseBackOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackOut_create : Error processing arguments");
        auto result = cocos2d::EaseBackOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackOut_finalize)

static bool js_cocos2dx_EaseBackOut_constructor(se::State& s)
{
    cocos2d::EaseBackOut* cobj = new (std::nothrow) cocos2d::EaseBackOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackOut_constructor, __jsb_cocos2d_EaseBackOut_class, js_cocos2d_EaseBackOut_finalize)

static bool js_cocos2dx_EaseBackOut_ctor(se::State& s)
{
    cocos2d::EaseBackOut* cobj = new (std::nothrow) cocos2d::EaseBackOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackOut_ctor, __jsb_cocos2d_EaseBackOut_class, js_cocos2d_EaseBackOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseBackOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBackOut)", s.nativeThisObject());
    cocos2d::EaseBackOut* cobj = (cocos2d::EaseBackOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackOut_finalize)

bool js_register_cocos2dx_EaseBackOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBackOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackOut>(cls);

    __jsb_cocos2d_EaseBackOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBackOut_class = cls;

    jsb_set_extend_property("cc", "EaseBackOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBackInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBackInOut_class = nullptr;

static bool js_cocos2dx_EaseBackInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBackInOut_create : Error processing arguments");
        auto result = cocos2d::EaseBackInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBackInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBackInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBackInOut_finalize)

static bool js_cocos2dx_EaseBackInOut_constructor(se::State& s)
{
    cocos2d::EaseBackInOut* cobj = new (std::nothrow) cocos2d::EaseBackInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBackInOut_constructor, __jsb_cocos2d_EaseBackInOut_class, js_cocos2d_EaseBackInOut_finalize)

static bool js_cocos2dx_EaseBackInOut_ctor(se::State& s)
{
    cocos2d::EaseBackInOut* cobj = new (std::nothrow) cocos2d::EaseBackInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBackInOut_ctor, __jsb_cocos2d_EaseBackInOut_class, js_cocos2d_EaseBackInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseBackInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBackInOut)", s.nativeThisObject());
    cocos2d::EaseBackInOut* cobj = (cocos2d::EaseBackInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBackInOut_finalize)

bool js_register_cocos2dx_EaseBackInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseBackInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBackInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBackInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBackInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBackInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBackInOut>(cls);

    __jsb_cocos2d_EaseBackInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseBackInOut_class = cls;

    jsb_set_extend_property("cc", "EaseBackInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseBezierAction_proto = nullptr;
se::Class* __jsb_cocos2d_EaseBezierAction_class = nullptr;

static bool js_cocos2dx_EaseBezierAction_setBezierParamer(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = (cocos2d::EaseBezierAction*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_EaseBezierAction_setBezierParamer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBezierAction_setBezierParamer : Error processing arguments");
        cobj->setBezierParamer(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBezierAction_setBezierParamer)

static bool js_cocos2dx_EaseBezierAction_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseBezierAction_create : Error processing arguments");
        auto result = cocos2d::EaseBezierAction::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseBezierAction_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseBezierAction_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseBezierAction_finalize)

static bool js_cocos2dx_EaseBezierAction_constructor(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = new (std::nothrow) cocos2d::EaseBezierAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseBezierAction_constructor, __jsb_cocos2d_EaseBezierAction_class, js_cocos2d_EaseBezierAction_finalize)

static bool js_cocos2dx_EaseBezierAction_ctor(se::State& s)
{
    cocos2d::EaseBezierAction* cobj = new (std::nothrow) cocos2d::EaseBezierAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseBezierAction_ctor, __jsb_cocos2d_EaseBezierAction_class, js_cocos2d_EaseBezierAction_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseBezierAction_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseBezierAction)", s.nativeThisObject());
    cocos2d::EaseBezierAction* cobj = (cocos2d::EaseBezierAction*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseBezierAction_finalize)

bool js_register_cocos2dx_EaseBezierAction(se::Object* obj)
{
    auto cls = se::Class::create("EaseBezierAction", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseBezierAction_constructor));

    cls->defineFunction("setBezierParamer", _SE(js_cocos2dx_EaseBezierAction_setBezierParamer));
    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseBezierAction_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseBezierAction_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseBezierAction_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseBezierAction>(cls);

    __jsb_cocos2d_EaseBezierAction_proto = cls->getProto();
    __jsb_cocos2d_EaseBezierAction_class = cls;

    jsb_set_extend_property("cc", "EaseBezierAction");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionIn_finalize)

static bool js_cocos2dx_EaseQuadraticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionIn_constructor, __jsb_cocos2d_EaseQuadraticActionIn_class, js_cocos2d_EaseQuadraticActionIn_finalize)

static bool js_cocos2dx_EaseQuadraticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionIn_ctor, __jsb_cocos2d_EaseQuadraticActionIn_class, js_cocos2d_EaseQuadraticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuadraticActionIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionIn)", s.nativeThisObject());
    cocos2d::EaseQuadraticActionIn* cobj = (cocos2d::EaseQuadraticActionIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionIn_finalize)

bool js_register_cocos2dx_EaseQuadraticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuadraticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionIn>(cls);

    __jsb_cocos2d_EaseQuadraticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionIn_class = cls;

    jsb_set_extend_property("cc", "EaseQuadraticActionIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionOut_constructor, __jsb_cocos2d_EaseQuadraticActionOut_class, js_cocos2d_EaseQuadraticActionOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionOut_ctor, __jsb_cocos2d_EaseQuadraticActionOut_class, js_cocos2d_EaseQuadraticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuadraticActionOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionOut)", s.nativeThisObject());
    cocos2d::EaseQuadraticActionOut* cobj = (cocos2d::EaseQuadraticActionOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionOut_finalize)

bool js_register_cocos2dx_EaseQuadraticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuadraticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionOut>(cls);

    __jsb_cocos2d_EaseQuadraticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuadraticActionOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuadraticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuadraticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuadraticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuadraticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuadraticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuadraticActionInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuadraticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionInOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuadraticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuadraticActionInOut_constructor, __jsb_cocos2d_EaseQuadraticActionInOut_class, js_cocos2d_EaseQuadraticActionInOut_finalize)

static bool js_cocos2dx_EaseQuadraticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuadraticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuadraticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuadraticActionInOut_ctor, __jsb_cocos2d_EaseQuadraticActionInOut_class, js_cocos2d_EaseQuadraticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuadraticActionInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuadraticActionInOut)", s.nativeThisObject());
    cocos2d::EaseQuadraticActionInOut* cobj = (cocos2d::EaseQuadraticActionInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuadraticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuadraticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuadraticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuadraticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuadraticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuadraticActionInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuadraticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuadraticActionInOut>(cls);

    __jsb_cocos2d_EaseQuadraticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuadraticActionInOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuadraticActionInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionIn_finalize)

static bool js_cocos2dx_EaseQuarticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuarticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionIn_constructor, __jsb_cocos2d_EaseQuarticActionIn_class, js_cocos2d_EaseQuarticActionIn_finalize)

static bool js_cocos2dx_EaseQuarticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuarticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionIn_ctor, __jsb_cocos2d_EaseQuarticActionIn_class, js_cocos2d_EaseQuarticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuarticActionIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionIn)", s.nativeThisObject());
    cocos2d::EaseQuarticActionIn* cobj = (cocos2d::EaseQuarticActionIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionIn_finalize)

bool js_register_cocos2dx_EaseQuarticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuarticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionIn>(cls);

    __jsb_cocos2d_EaseQuarticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionIn_class = cls;

    jsb_set_extend_property("cc", "EaseQuarticActionIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionOut_finalize)

static bool js_cocos2dx_EaseQuarticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionOut_constructor, __jsb_cocos2d_EaseQuarticActionOut_class, js_cocos2d_EaseQuarticActionOut_finalize)

static bool js_cocos2dx_EaseQuarticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionOut_ctor, __jsb_cocos2d_EaseQuarticActionOut_class, js_cocos2d_EaseQuarticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuarticActionOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionOut)", s.nativeThisObject());
    cocos2d::EaseQuarticActionOut* cobj = (cocos2d::EaseQuarticActionOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionOut_finalize)

bool js_register_cocos2dx_EaseQuarticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuarticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionOut>(cls);

    __jsb_cocos2d_EaseQuarticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuarticActionOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuarticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuarticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuarticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuarticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuarticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuarticActionInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuarticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionInOut_finalize)

static bool js_cocos2dx_EaseQuarticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuarticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuarticActionInOut_constructor, __jsb_cocos2d_EaseQuarticActionInOut_class, js_cocos2d_EaseQuarticActionInOut_finalize)

static bool js_cocos2dx_EaseQuarticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuarticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuarticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuarticActionInOut_ctor, __jsb_cocos2d_EaseQuarticActionInOut_class, js_cocos2d_EaseQuarticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuarticActionInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuarticActionInOut)", s.nativeThisObject());
    cocos2d::EaseQuarticActionInOut* cobj = (cocos2d::EaseQuarticActionInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuarticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuarticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuarticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuarticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuarticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuarticActionInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuarticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuarticActionInOut>(cls);

    __jsb_cocos2d_EaseQuarticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuarticActionInOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuarticActionInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionIn_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionIn_finalize)

static bool js_cocos2dx_EaseQuinticActionIn_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuinticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionIn_constructor, __jsb_cocos2d_EaseQuinticActionIn_class, js_cocos2d_EaseQuinticActionIn_finalize)

static bool js_cocos2dx_EaseQuinticActionIn_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionIn* cobj = new (std::nothrow) cocos2d::EaseQuinticActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionIn_ctor, __jsb_cocos2d_EaseQuinticActionIn_class, js_cocos2d_EaseQuinticActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuinticActionIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionIn)", s.nativeThisObject());
    cocos2d::EaseQuinticActionIn* cobj = (cocos2d::EaseQuinticActionIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionIn_finalize)

bool js_register_cocos2dx_EaseQuinticActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuinticActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionIn>(cls);

    __jsb_cocos2d_EaseQuinticActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionIn_class = cls;

    jsb_set_extend_property("cc", "EaseQuinticActionIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionOut_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionOut_finalize)

static bool js_cocos2dx_EaseQuinticActionOut_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionOut_constructor, __jsb_cocos2d_EaseQuinticActionOut_class, js_cocos2d_EaseQuinticActionOut_finalize)

static bool js_cocos2dx_EaseQuinticActionOut_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionOut_ctor, __jsb_cocos2d_EaseQuinticActionOut_class, js_cocos2d_EaseQuinticActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuinticActionOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionOut)", s.nativeThisObject());
    cocos2d::EaseQuinticActionOut* cobj = (cocos2d::EaseQuinticActionOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionOut_finalize)

bool js_register_cocos2dx_EaseQuinticActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuinticActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionOut>(cls);

    __jsb_cocos2d_EaseQuinticActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuinticActionOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseQuinticActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseQuinticActionInOut_class = nullptr;

static bool js_cocos2dx_EaseQuinticActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseQuinticActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseQuinticActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseQuinticActionInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseQuinticActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionInOut_finalize)

static bool js_cocos2dx_EaseQuinticActionInOut_constructor(se::State& s)
{
    cocos2d::EaseQuinticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseQuinticActionInOut_constructor, __jsb_cocos2d_EaseQuinticActionInOut_class, js_cocos2d_EaseQuinticActionInOut_finalize)

static bool js_cocos2dx_EaseQuinticActionInOut_ctor(se::State& s)
{
    cocos2d::EaseQuinticActionInOut* cobj = new (std::nothrow) cocos2d::EaseQuinticActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseQuinticActionInOut_ctor, __jsb_cocos2d_EaseQuinticActionInOut_class, js_cocos2d_EaseQuinticActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseQuinticActionInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseQuinticActionInOut)", s.nativeThisObject());
    cocos2d::EaseQuinticActionInOut* cobj = (cocos2d::EaseQuinticActionInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseQuinticActionInOut_finalize)

bool js_register_cocos2dx_EaseQuinticActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseQuinticActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseQuinticActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseQuinticActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseQuinticActionInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseQuinticActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseQuinticActionInOut>(cls);

    __jsb_cocos2d_EaseQuinticActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseQuinticActionInOut_class = cls;

    jsb_set_extend_property("cc", "EaseQuinticActionInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionIn_class = nullptr;

static bool js_cocos2dx_EaseCircleActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionIn_finalize)

static bool js_cocos2dx_EaseCircleActionIn_constructor(se::State& s)
{
    cocos2d::EaseCircleActionIn* cobj = new (std::nothrow) cocos2d::EaseCircleActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionIn_constructor, __jsb_cocos2d_EaseCircleActionIn_class, js_cocos2d_EaseCircleActionIn_finalize)

static bool js_cocos2dx_EaseCircleActionIn_ctor(se::State& s)
{
    cocos2d::EaseCircleActionIn* cobj = new (std::nothrow) cocos2d::EaseCircleActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionIn_ctor, __jsb_cocos2d_EaseCircleActionIn_class, js_cocos2d_EaseCircleActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCircleActionIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionIn)", s.nativeThisObject());
    cocos2d::EaseCircleActionIn* cobj = (cocos2d::EaseCircleActionIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionIn_finalize)

bool js_register_cocos2dx_EaseCircleActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCircleActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionIn>(cls);

    __jsb_cocos2d_EaseCircleActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionIn_class = cls;

    jsb_set_extend_property("cc", "EaseCircleActionIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionOut_class = nullptr;

static bool js_cocos2dx_EaseCircleActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionOut_finalize)

static bool js_cocos2dx_EaseCircleActionOut_constructor(se::State& s)
{
    cocos2d::EaseCircleActionOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionOut_constructor, __jsb_cocos2d_EaseCircleActionOut_class, js_cocos2d_EaseCircleActionOut_finalize)

static bool js_cocos2dx_EaseCircleActionOut_ctor(se::State& s)
{
    cocos2d::EaseCircleActionOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionOut_ctor, __jsb_cocos2d_EaseCircleActionOut_class, js_cocos2d_EaseCircleActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCircleActionOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionOut)", s.nativeThisObject());
    cocos2d::EaseCircleActionOut* cobj = (cocos2d::EaseCircleActionOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionOut_finalize)

bool js_register_cocos2dx_EaseCircleActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCircleActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionOut>(cls);

    __jsb_cocos2d_EaseCircleActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionOut_class = cls;

    jsb_set_extend_property("cc", "EaseCircleActionOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCircleActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCircleActionInOut_class = nullptr;

static bool js_cocos2dx_EaseCircleActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCircleActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseCircleActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCircleActionInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCircleActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCircleActionInOut_finalize)

static bool js_cocos2dx_EaseCircleActionInOut_constructor(se::State& s)
{
    cocos2d::EaseCircleActionInOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCircleActionInOut_constructor, __jsb_cocos2d_EaseCircleActionInOut_class, js_cocos2d_EaseCircleActionInOut_finalize)

static bool js_cocos2dx_EaseCircleActionInOut_ctor(se::State& s)
{
    cocos2d::EaseCircleActionInOut* cobj = new (std::nothrow) cocos2d::EaseCircleActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCircleActionInOut_ctor, __jsb_cocos2d_EaseCircleActionInOut_class, js_cocos2d_EaseCircleActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCircleActionInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCircleActionInOut)", s.nativeThisObject());
    cocos2d::EaseCircleActionInOut* cobj = (cocos2d::EaseCircleActionInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCircleActionInOut_finalize)

bool js_register_cocos2dx_EaseCircleActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCircleActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCircleActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCircleActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCircleActionInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCircleActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCircleActionInOut>(cls);

    __jsb_cocos2d_EaseCircleActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCircleActionInOut_class = cls;

    jsb_set_extend_property("cc", "EaseCircleActionInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionIn_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionIn_class = nullptr;

static bool js_cocos2dx_EaseCubicActionIn_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionIn_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionIn::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionIn_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionIn_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionIn_finalize)

static bool js_cocos2dx_EaseCubicActionIn_constructor(se::State& s)
{
    cocos2d::EaseCubicActionIn* cobj = new (std::nothrow) cocos2d::EaseCubicActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionIn_constructor, __jsb_cocos2d_EaseCubicActionIn_class, js_cocos2d_EaseCubicActionIn_finalize)

static bool js_cocos2dx_EaseCubicActionIn_ctor(se::State& s)
{
    cocos2d::EaseCubicActionIn* cobj = new (std::nothrow) cocos2d::EaseCubicActionIn();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionIn_ctor, __jsb_cocos2d_EaseCubicActionIn_class, js_cocos2d_EaseCubicActionIn_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCubicActionIn_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionIn)", s.nativeThisObject());
    cocos2d::EaseCubicActionIn* cobj = (cocos2d::EaseCubicActionIn*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionIn_finalize)

bool js_register_cocos2dx_EaseCubicActionIn(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionIn", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionIn_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionIn_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionIn_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCubicActionIn_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionIn>(cls);

    __jsb_cocos2d_EaseCubicActionIn_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionIn_class = cls;

    jsb_set_extend_property("cc", "EaseCubicActionIn");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionOut_class = nullptr;

static bool js_cocos2dx_EaseCubicActionOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionOut_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionOut_finalize)

static bool js_cocos2dx_EaseCubicActionOut_constructor(se::State& s)
{
    cocos2d::EaseCubicActionOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionOut_constructor, __jsb_cocos2d_EaseCubicActionOut_class, js_cocos2d_EaseCubicActionOut_finalize)

static bool js_cocos2dx_EaseCubicActionOut_ctor(se::State& s)
{
    cocos2d::EaseCubicActionOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionOut_ctor, __jsb_cocos2d_EaseCubicActionOut_class, js_cocos2d_EaseCubicActionOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCubicActionOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionOut)", s.nativeThisObject());
    cocos2d::EaseCubicActionOut* cobj = (cocos2d::EaseCubicActionOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionOut_finalize)

bool js_register_cocos2dx_EaseCubicActionOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCubicActionOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionOut>(cls);

    __jsb_cocos2d_EaseCubicActionOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionOut_class = cls;

    jsb_set_extend_property("cc", "EaseCubicActionOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_EaseCubicActionInOut_proto = nullptr;
se::Class* __jsb_cocos2d_EaseCubicActionInOut_class = nullptr;

static bool js_cocos2dx_EaseCubicActionInOut_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ActionInterval* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_EaseCubicActionInOut_create : Error processing arguments");
        auto result = cocos2d::EaseCubicActionInOut::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_EaseCubicActionInOut_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_EaseCubicActionInOut_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_EaseCubicActionInOut_finalize)

static bool js_cocos2dx_EaseCubicActionInOut_constructor(se::State& s)
{
    cocos2d::EaseCubicActionInOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_EaseCubicActionInOut_constructor, __jsb_cocos2d_EaseCubicActionInOut_class, js_cocos2d_EaseCubicActionInOut_finalize)

static bool js_cocos2dx_EaseCubicActionInOut_ctor(se::State& s)
{
    cocos2d::EaseCubicActionInOut* cobj = new (std::nothrow) cocos2d::EaseCubicActionInOut();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_EaseCubicActionInOut_ctor, __jsb_cocos2d_EaseCubicActionInOut_class, js_cocos2d_EaseCubicActionInOut_finalize)


    

extern se::Object* __jsb_cocos2d_ActionEase_proto;

static bool js_cocos2d_EaseCubicActionInOut_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::EaseCubicActionInOut)", s.nativeThisObject());
    cocos2d::EaseCubicActionInOut* cobj = (cocos2d::EaseCubicActionInOut*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_EaseCubicActionInOut_finalize)

bool js_register_cocos2dx_EaseCubicActionInOut(se::Object* obj)
{
    auto cls = se::Class::create("EaseCubicActionInOut", obj, __jsb_cocos2d_ActionEase_proto, _SE(js_cocos2dx_EaseCubicActionInOut_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_EaseCubicActionInOut_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_EaseCubicActionInOut_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_EaseCubicActionInOut_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::EaseCubicActionInOut>(cls);

    __jsb_cocos2d_EaseCubicActionInOut_proto = cls->getProto();
    __jsb_cocos2d_EaseCubicActionInOut_class = cls;

    jsb_set_extend_property("cc", "EaseCubicActionInOut");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ActionInstant_proto = nullptr;
se::Class* __jsb_cocos2d_ActionInstant_class = nullptr;


extern se::Object* __jsb_cocos2d_FiniteTimeAction_proto;


bool js_register_cocos2dx_ActionInstant(se::Object* obj)
{
    auto cls = se::Class::create("ActionInstant", obj, __jsb_cocos2d_FiniteTimeAction_proto, nullptr);

    cls->install();
    JSBClassType::registerClass<cocos2d::ActionInstant>(cls);

    __jsb_cocos2d_ActionInstant_proto = cls->getProto();
    __jsb_cocos2d_ActionInstant_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Show_proto = nullptr;
se::Class* __jsb_cocos2d_Show_class = nullptr;

static bool js_cocos2dx_Show_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Show::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Show_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Show_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Show_finalize)

static bool js_cocos2dx_Show_constructor(se::State& s)
{
    cocos2d::Show* cobj = new (std::nothrow) cocos2d::Show();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Show_constructor, __jsb_cocos2d_Show_class, js_cocos2d_Show_finalize)

static bool js_cocos2dx_Show_ctor(se::State& s)
{
    cocos2d::Show* cobj = new (std::nothrow) cocos2d::Show();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Show_ctor, __jsb_cocos2d_Show_class, js_cocos2d_Show_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_Show_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Show)", s.nativeThisObject());
    cocos2d::Show* cobj = (cocos2d::Show*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Show_finalize)

bool js_register_cocos2dx_Show(se::Object* obj)
{
    auto cls = se::Class::create("Show", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Show_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Show_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Show_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Show_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Show>(cls);

    __jsb_cocos2d_Show_proto = cls->getProto();
    __jsb_cocos2d_Show_class = cls;

    jsb_set_extend_property("cc", "Show");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Hide_proto = nullptr;
se::Class* __jsb_cocos2d_Hide_class = nullptr;

static bool js_cocos2dx_Hide_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Hide::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Hide_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Hide_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Hide_finalize)

static bool js_cocos2dx_Hide_constructor(se::State& s)
{
    cocos2d::Hide* cobj = new (std::nothrow) cocos2d::Hide();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Hide_constructor, __jsb_cocos2d_Hide_class, js_cocos2d_Hide_finalize)

static bool js_cocos2dx_Hide_ctor(se::State& s)
{
    cocos2d::Hide* cobj = new (std::nothrow) cocos2d::Hide();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Hide_ctor, __jsb_cocos2d_Hide_class, js_cocos2d_Hide_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_Hide_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Hide)", s.nativeThisObject());
    cocos2d::Hide* cobj = (cocos2d::Hide*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Hide_finalize)

bool js_register_cocos2dx_Hide(se::Object* obj)
{
    auto cls = se::Class::create("Hide", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Hide_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Hide_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Hide_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Hide_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Hide>(cls);

    __jsb_cocos2d_Hide_proto = cls->getProto();
    __jsb_cocos2d_Hide_class = cls;

    jsb_set_extend_property("cc", "Hide");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ToggleVisibility_proto = nullptr;
se::Class* __jsb_cocos2d_ToggleVisibility_class = nullptr;

static bool js_cocos2dx_ToggleVisibility_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ToggleVisibility::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ToggleVisibility_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ToggleVisibility_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ToggleVisibility_finalize)

static bool js_cocos2dx_ToggleVisibility_constructor(se::State& s)
{
    cocos2d::ToggleVisibility* cobj = new (std::nothrow) cocos2d::ToggleVisibility();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ToggleVisibility_constructor, __jsb_cocos2d_ToggleVisibility_class, js_cocos2d_ToggleVisibility_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_ToggleVisibility_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ToggleVisibility)", s.nativeThisObject());
    cocos2d::ToggleVisibility* cobj = (cocos2d::ToggleVisibility*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ToggleVisibility_finalize)

bool js_register_cocos2dx_ToggleVisibility(se::Object* obj)
{
    auto cls = se::Class::create("ToggleVisibility", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_ToggleVisibility_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_ToggleVisibility_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ToggleVisibility_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ToggleVisibility>(cls);

    __jsb_cocos2d_ToggleVisibility_proto = cls->getProto();
    __jsb_cocos2d_ToggleVisibility_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_RemoveSelf_proto = nullptr;
se::Class* __jsb_cocos2d_RemoveSelf_class = nullptr;

static bool js_cocos2dx_RemoveSelf_init(se::State& s)
{
    cocos2d::RemoveSelf* cobj = (cocos2d::RemoveSelf*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RemoveSelf_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RemoveSelf_init)

static bool js_cocos2dx_RemoveSelf_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::RemoveSelf::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_RemoveSelf_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RemoveSelf_create : Error processing arguments");
        auto result = cocos2d::RemoveSelf::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_RemoveSelf_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RemoveSelf_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RemoveSelf_finalize)

static bool js_cocos2dx_RemoveSelf_constructor(se::State& s)
{
    cocos2d::RemoveSelf* cobj = new (std::nothrow) cocos2d::RemoveSelf();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RemoveSelf_constructor, __jsb_cocos2d_RemoveSelf_class, js_cocos2d_RemoveSelf_finalize)



extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_RemoveSelf_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::RemoveSelf)", s.nativeThisObject());
    cocos2d::RemoveSelf* cobj = (cocos2d::RemoveSelf*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RemoveSelf_finalize)

bool js_register_cocos2dx_RemoveSelf(se::Object* obj)
{
    auto cls = se::Class::create("RemoveSelf", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_RemoveSelf_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_RemoveSelf_init));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RemoveSelf_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_RemoveSelf_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RemoveSelf>(cls);

    __jsb_cocos2d_RemoveSelf_proto = cls->getProto();
    __jsb_cocos2d_RemoveSelf_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FlipX_proto = nullptr;
se::Class* __jsb_cocos2d_FlipX_class = nullptr;

static bool js_cocos2dx_FlipX_initWithFlipX(se::State& s)
{
    cocos2d::FlipX* cobj = (cocos2d::FlipX*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FlipX_initWithFlipX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_initWithFlipX : Error processing arguments");
        bool result = cobj->initWithFlipX(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_initWithFlipX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX_initWithFlipX)

static bool js_cocos2dx_FlipX_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipX_create : Error processing arguments");
        auto result = cocos2d::FlipX::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipX_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipX_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipX_finalize)

static bool js_cocos2dx_FlipX_constructor(se::State& s)
{
    cocos2d::FlipX* cobj = new (std::nothrow) cocos2d::FlipX();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipX_constructor, __jsb_cocos2d_FlipX_class, js_cocos2d_FlipX_finalize)

static bool js_cocos2dx_FlipX_ctor(se::State& s)
{
    cocos2d::FlipX* cobj = new (std::nothrow) cocos2d::FlipX();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipX_ctor, __jsb_cocos2d_FlipX_class, js_cocos2d_FlipX_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_FlipX_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::FlipX)", s.nativeThisObject());
    cocos2d::FlipX* cobj = (cocos2d::FlipX*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipX_finalize)

bool js_register_cocos2dx_FlipX(se::Object* obj)
{
    auto cls = se::Class::create("FlipX", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_FlipX_constructor));

    cls->defineFunction("initWithFlipX", _SE(js_cocos2dx_FlipX_initWithFlipX));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipX_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipX_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_FlipX_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipX>(cls);

    __jsb_cocos2d_FlipX_proto = cls->getProto();
    __jsb_cocos2d_FlipX_class = cls;

    jsb_set_extend_property("cc", "FlipX");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_FlipY_proto = nullptr;
se::Class* __jsb_cocos2d_FlipY_class = nullptr;

static bool js_cocos2dx_FlipY_initWithFlipY(se::State& s)
{
    cocos2d::FlipY* cobj = (cocos2d::FlipY*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_FlipY_initWithFlipY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_initWithFlipY : Error processing arguments");
        bool result = cobj->initWithFlipY(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_initWithFlipY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipY_initWithFlipY)

static bool js_cocos2dx_FlipY_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_FlipY_create : Error processing arguments");
        auto result = cocos2d::FlipY::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_FlipY_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_FlipY_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_FlipY_finalize)

static bool js_cocos2dx_FlipY_constructor(se::State& s)
{
    cocos2d::FlipY* cobj = new (std::nothrow) cocos2d::FlipY();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_FlipY_constructor, __jsb_cocos2d_FlipY_class, js_cocos2d_FlipY_finalize)

static bool js_cocos2dx_FlipY_ctor(se::State& s)
{
    cocos2d::FlipY* cobj = new (std::nothrow) cocos2d::FlipY();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_FlipY_ctor, __jsb_cocos2d_FlipY_class, js_cocos2d_FlipY_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_FlipY_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::FlipY)", s.nativeThisObject());
    cocos2d::FlipY* cobj = (cocos2d::FlipY*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_FlipY_finalize)

bool js_register_cocos2dx_FlipY(se::Object* obj)
{
    auto cls = se::Class::create("FlipY", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_FlipY_constructor));

    cls->defineFunction("initWithFlipY", _SE(js_cocos2dx_FlipY_initWithFlipY));
    cls->defineFunction("ctor", _SE(js_cocos2dx_FlipY_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_FlipY_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_FlipY_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::FlipY>(cls);

    __jsb_cocos2d_FlipY_proto = cls->getProto();
    __jsb_cocos2d_FlipY_class = cls;

    jsb_set_extend_property("cc", "FlipY");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Place_proto = nullptr;
se::Class* __jsb_cocos2d_Place_class = nullptr;

static bool js_cocos2dx_Place_initWithPosition(se::State& s)
{
    cocos2d::Place* cobj = (cocos2d::Place*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Place_initWithPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Place_initWithPosition : Error processing arguments");
        bool result = cobj->initWithPosition(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Place_initWithPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Place_initWithPosition)

static bool js_cocos2dx_Place_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Place_create : Error processing arguments");
        auto result = cocos2d::Place::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Place_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Place_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Place_finalize)

static bool js_cocos2dx_Place_constructor(se::State& s)
{
    cocos2d::Place* cobj = new (std::nothrow) cocos2d::Place();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Place_constructor, __jsb_cocos2d_Place_class, js_cocos2d_Place_finalize)

static bool js_cocos2dx_Place_ctor(se::State& s)
{
    cocos2d::Place* cobj = new (std::nothrow) cocos2d::Place();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Place_ctor, __jsb_cocos2d_Place_class, js_cocos2d_Place_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_Place_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Place)", s.nativeThisObject());
    cocos2d::Place* cobj = (cocos2d::Place*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Place_finalize)

bool js_register_cocos2dx_Place(se::Object* obj)
{
    auto cls = se::Class::create("Place", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_Place_constructor));

    cls->defineFunction("initWithPosition", _SE(js_cocos2dx_Place_initWithPosition));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Place_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Place_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Place_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Place>(cls);

    __jsb_cocos2d_Place_proto = cls->getProto();
    __jsb_cocos2d_Place_class = cls;

    jsb_set_extend_property("cc", "Place");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CallFunc_proto = nullptr;
se::Class* __jsb_cocos2d_CallFunc_class = nullptr;

static bool js_cocos2dx_CallFunc_execute(se::State& s)
{
    cocos2d::CallFunc* cobj = (cocos2d::CallFunc*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_CallFunc_execute : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->execute();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_CallFunc_execute)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CallFunc_finalize)

static bool js_cocos2dx_CallFunc_constructor(se::State& s)
{
    cocos2d::CallFunc* cobj = new (std::nothrow) cocos2d::CallFunc();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CallFunc_constructor, __jsb_cocos2d_CallFunc_class, js_cocos2d_CallFunc_finalize)

static bool js_cocos2dx_CallFunc_ctor(se::State& s)
{
    cocos2d::CallFunc* cobj = new (std::nothrow) cocos2d::CallFunc();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_CallFunc_ctor, __jsb_cocos2d_CallFunc_class, js_cocos2d_CallFunc_finalize)


    

extern se::Object* __jsb_cocos2d_ActionInstant_proto;

static bool js_cocos2d_CallFunc_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CallFunc)", s.nativeThisObject());
    cocos2d::CallFunc* cobj = (cocos2d::CallFunc*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CallFunc_finalize)

bool js_register_cocos2dx_CallFunc(se::Object* obj)
{
    auto cls = se::Class::create("_CallFunc", obj, __jsb_cocos2d_ActionInstant_proto, _SE(js_cocos2dx_CallFunc_constructor));

    cls->defineFunction("execute", _SE(js_cocos2dx_CallFunc_execute));
    cls->defineFunction("ctor", _SE(js_cocos2dx_CallFunc_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_CallFunc_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CallFunc>(cls);

    __jsb_cocos2d_CallFunc_proto = cls->getProto();
    __jsb_cocos2d_CallFunc_class = cls;

    jsb_set_extend_property("cc", "_CallFunc");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_CallFuncN_proto = nullptr;
se::Class* __jsb_cocos2d_CallFuncN_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_CallFuncN_finalize)

static bool js_cocos2dx_CallFuncN_constructor(se::State& s)
{
    cocos2d::CallFuncN* cobj = new (std::nothrow) cocos2d::CallFuncN();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_CallFuncN_constructor, __jsb_cocos2d_CallFuncN_class, js_cocos2d_CallFuncN_finalize)

static bool js_cocos2dx_CallFuncN_ctor(se::State& s)
{
    cocos2d::CallFuncN* cobj = new (std::nothrow) cocos2d::CallFuncN();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_CallFuncN_ctor, __jsb_cocos2d_CallFuncN_class, js_cocos2d_CallFuncN_finalize)


    

extern se::Object* __jsb_cocos2d_CallFunc_proto;

static bool js_cocos2d_CallFuncN_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::CallFuncN)", s.nativeThisObject());
    cocos2d::CallFuncN* cobj = (cocos2d::CallFuncN*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_CallFuncN_finalize)

bool js_register_cocos2dx_CallFuncN(se::Object* obj)
{
    auto cls = se::Class::create("CallFunc", obj, __jsb_cocos2d_CallFunc_proto, _SE(js_cocos2dx_CallFuncN_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_CallFuncN_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_CallFuncN_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::CallFuncN>(cls);

    __jsb_cocos2d_CallFuncN_proto = cls->getProto();
    __jsb_cocos2d_CallFuncN_class = cls;

    jsb_set_extend_property("cc", "CallFunc");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ActionManager_proto = nullptr;
se::Class* __jsb_cocos2d_ActionManager_class = nullptr;

static bool js_cocos2dx_ActionManager_getActionByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_getActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        const cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getActionByTag : Error processing arguments");
        cocos2d::Action* result = cobj->getActionByTag(arg0, arg1);
        ok &= native_ptr_to_seval<cocos2d::Action>((cocos2d::Action*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getActionByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_getActionByTag)

static bool js_cocos2dx_ActionManager_removeActionByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeActionByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeActionByTag : Error processing arguments");
        cobj->removeActionByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeActionByTag)

static bool js_cocos2dx_ActionManager_removeActionsByFlags(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeActionsByFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        unsigned int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeActionsByFlags : Error processing arguments");
        cobj->removeActionsByFlags(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeActionsByFlags)

static bool js_cocos2dx_ActionManager_removeAllActions(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllActions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActions)

static bool js_cocos2dx_ActionManager_addAction(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_addAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Action* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        bool arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_boolean(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_addAction : Error processing arguments");
        cobj->addAction(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_addAction)

static bool js_cocos2dx_ActionManager_resumeTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_resumeTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_resumeTarget : Error processing arguments");
        cobj->resumeTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_resumeTarget)

static bool js_cocos2dx_ActionManager_update(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_update : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_update : Error processing arguments");
        cobj->update(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_update)

static bool js_cocos2dx_ActionManager_pauseTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_pauseTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_pauseTarget : Error processing arguments");
        cobj->pauseTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_pauseTarget)

static bool js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Error processing arguments");
        ssize_t result = cobj->getNumberOfRunningActionsInTarget(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget)

static bool js_cocos2dx_ActionManager_removeAllActionsFromTarget(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActionsFromTarget : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAllActionsFromTarget : Error processing arguments");
        cobj->removeAllActionsFromTarget(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActionsFromTarget)

static bool js_cocos2dx_ActionManager_resumeTargets(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_resumeTargets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::Node *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_resumeTargets : Error processing arguments");
        cobj->resumeTargets(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_resumeTargets)

static bool js_cocos2dx_ActionManager_removeAction(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAction : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Action* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAction : Error processing arguments");
        cobj->removeAction(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAction)

static bool js_cocos2dx_ActionManager_removeAllActionsByTag(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_removeAllActionsByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        cocos2d::Node* arg1 = nullptr;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_removeAllActionsByTag : Error processing arguments");
        cobj->removeAllActionsByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_removeAllActionsByTag)

static bool js_cocos2dx_ActionManager_pauseAllRunningActions(se::State& s)
{
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ActionManager_pauseAllRunningActions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vector<cocos2d::Node *> result = cobj->pauseAllRunningActions();
        ok &= Vector_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ActionManager_pauseAllRunningActions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ActionManager_pauseAllRunningActions)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ActionManager_finalize)

static bool js_cocos2dx_ActionManager_constructor(se::State& s)
{
    cocos2d::ActionManager* cobj = new (std::nothrow) cocos2d::ActionManager();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ActionManager_constructor, __jsb_cocos2d_ActionManager_class, js_cocos2d_ActionManager_finalize)

static bool js_cocos2dx_ActionManager_ctor(se::State& s)
{
    cocos2d::ActionManager* cobj = new (std::nothrow) cocos2d::ActionManager();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ActionManager_ctor, __jsb_cocos2d_ActionManager_class, js_cocos2d_ActionManager_finalize)


    


static bool js_cocos2d_ActionManager_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ActionManager)", s.nativeThisObject());
    cocos2d::ActionManager* cobj = (cocos2d::ActionManager*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ActionManager_finalize)

bool js_register_cocos2dx_ActionManager(se::Object* obj)
{
    auto cls = se::Class::create("ActionManager", obj, nullptr, _SE(js_cocos2dx_ActionManager_constructor));

    cls->defineFunction("getActionByTag", _SE(js_cocos2dx_ActionManager_getActionByTag));
    cls->defineFunction("removeActionByTag", _SE(js_cocos2dx_ActionManager_removeActionByTag));
    cls->defineFunction("removeActionsByFlags", _SE(js_cocos2dx_ActionManager_removeActionsByFlags));
    cls->defineFunction("removeAllActions", _SE(js_cocos2dx_ActionManager_removeAllActions));
    cls->defineFunction("addAction", _SE(js_cocos2dx_ActionManager_addAction));
    cls->defineFunction("resumeTarget", _SE(js_cocos2dx_ActionManager_resumeTarget));
    cls->defineFunction("update", _SE(js_cocos2dx_ActionManager_update));
    cls->defineFunction("pauseTarget", _SE(js_cocos2dx_ActionManager_pauseTarget));
    cls->defineFunction("getNumberOfRunningActionsInTarget", _SE(js_cocos2dx_ActionManager_getNumberOfRunningActionsInTarget));
    cls->defineFunction("removeAllActionsFromTarget", _SE(js_cocos2dx_ActionManager_removeAllActionsFromTarget));
    cls->defineFunction("resumeTargets", _SE(js_cocos2dx_ActionManager_resumeTargets));
    cls->defineFunction("removeAction", _SE(js_cocos2dx_ActionManager_removeAction));
    cls->defineFunction("removeAllActionsByTag", _SE(js_cocos2dx_ActionManager_removeAllActionsByTag));
    cls->defineFunction("pauseAllRunningActions", _SE(js_cocos2dx_ActionManager_pauseAllRunningActions));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ActionManager_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ActionManager_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ActionManager>(cls);

    __jsb_cocos2d_ActionManager_proto = cls->getProto();
    __jsb_cocos2d_ActionManager_class = cls;

    jsb_set_extend_property("cc", "ActionManager");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_AtlasNode_proto = nullptr;
se::Class* __jsb_cocos2d_AtlasNode_class = nullptr;

static bool js_cocos2dx_AtlasNode_updateAtlasValues(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_updateAtlasValues : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateAtlasValues();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_updateAtlasValues)

static bool js_cocos2dx_AtlasNode_initWithTileFile(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_initWithTileFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTileFile : Error processing arguments");
        bool result = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTileFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_initWithTileFile)

static bool js_cocos2dx_AtlasNode_getTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getTexture)

static bool js_cocos2dx_AtlasNode_setTextureAtlas(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setTextureAtlas)

static bool js_cocos2dx_AtlasNode_setBlendFunc(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setBlendFunc)

static bool js_cocos2dx_AtlasNode_getBlendFunc(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getBlendFunc)

static bool js_cocos2dx_AtlasNode_getQuadsToDraw(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_getQuadsToDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getQuadsToDraw();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_getQuadsToDraw : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_getQuadsToDraw)

static bool js_cocos2dx_AtlasNode_setTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setTexture)

static bool js_cocos2dx_AtlasNode_initWithTexture(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_initWithTexture)

static bool js_cocos2dx_AtlasNode_setQuadsToDraw(se::State& s)
{
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_AtlasNode_setQuadsToDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_setQuadsToDraw : Error processing arguments");
        cobj->setQuadsToDraw(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_setQuadsToDraw)

static bool js_cocos2dx_AtlasNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        int arg1 = 0;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_AtlasNode_create : Error processing arguments");
        auto result = cocos2d::AtlasNode::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_AtlasNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_AtlasNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_AtlasNode_finalize)

static bool js_cocos2dx_AtlasNode_constructor(se::State& s)
{
    cocos2d::AtlasNode* cobj = new (std::nothrow) cocos2d::AtlasNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_AtlasNode_constructor, __jsb_cocos2d_AtlasNode_class, js_cocos2d_AtlasNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_AtlasNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::AtlasNode)", s.nativeThisObject());
    cocos2d::AtlasNode* cobj = (cocos2d::AtlasNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_AtlasNode_finalize)

bool js_register_cocos2dx_AtlasNode(se::Object* obj)
{
    auto cls = se::Class::create("AtlasNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_AtlasNode_constructor));

    cls->defineFunction("updateAtlasValues", _SE(js_cocos2dx_AtlasNode_updateAtlasValues));
    cls->defineFunction("initWithTileFile", _SE(js_cocos2dx_AtlasNode_initWithTileFile));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_AtlasNode_getTexture));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_AtlasNode_setTextureAtlas));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_AtlasNode_setBlendFunc));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_AtlasNode_getBlendFunc));
    cls->defineFunction("getQuadsToDraw", _SE(js_cocos2dx_AtlasNode_getQuadsToDraw));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_AtlasNode_setTexture));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_AtlasNode_initWithTexture));
    cls->defineFunction("setQuadsToDraw", _SE(js_cocos2dx_AtlasNode_setQuadsToDraw));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_AtlasNode_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_AtlasNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::AtlasNode>(cls);

    __jsb_cocos2d_AtlasNode_proto = cls->getProto();
    __jsb_cocos2d_AtlasNode_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ClippingNode_proto = nullptr;
se::Class* __jsb_cocos2d_ClippingNode_class = nullptr;

static bool js_cocos2dx_ClippingNode_hasContent(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_hasContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->hasContent();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_hasContent : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_hasContent)

static bool js_cocos2dx_ClippingNode_setInverted(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setInverted : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setInverted : Error processing arguments");
        cobj->setInverted(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setInverted)

static bool js_cocos2dx_ClippingNode_setStencil(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setStencil : Error processing arguments");
        cobj->setStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setStencil)

static bool js_cocos2dx_ClippingNode_getAlphaThreshold(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_getAlphaThreshold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAlphaThreshold();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_getAlphaThreshold : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_getAlphaThreshold)

static bool js_cocos2dx_ClippingNode_init(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ClippingNode_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->init(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_init : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            bool result = cobj->init();
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_init : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_init)

static bool js_cocos2dx_ClippingNode_getStencil(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_getStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getStencil();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_getStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_getStencil)

static bool js_cocos2dx_ClippingNode_setAlphaThreshold(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_setAlphaThreshold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_setAlphaThreshold : Error processing arguments");
        cobj->setAlphaThreshold(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_setAlphaThreshold)

static bool js_cocos2dx_ClippingNode_isInverted(se::State& s)
{
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ClippingNode_isInverted : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isInverted();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_isInverted : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_isInverted)

static bool js_cocos2dx_ClippingNode_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ClippingNode* result = cocos2d::ClippingNode::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ClippingNode>((cocos2d::ClippingNode*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::ClippingNode* result = cocos2d::ClippingNode::create();
            ok &= native_ptr_to_seval<cocos2d::ClippingNode>((cocos2d::ClippingNode*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ClippingNode_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ClippingNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ClippingNode_finalize)

static bool js_cocos2dx_ClippingNode_constructor(se::State& s)
{
    cocos2d::ClippingNode* cobj = new (std::nothrow) cocos2d::ClippingNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ClippingNode_constructor, __jsb_cocos2d_ClippingNode_class, js_cocos2d_ClippingNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_ClippingNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ClippingNode)", s.nativeThisObject());
    cocos2d::ClippingNode* cobj = (cocos2d::ClippingNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ClippingNode_finalize)

bool js_register_cocos2dx_ClippingNode(se::Object* obj)
{
    auto cls = se::Class::create("ClippingNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ClippingNode_constructor));

    cls->defineFunction("hasContent", _SE(js_cocos2dx_ClippingNode_hasContent));
    cls->defineFunction("setInverted", _SE(js_cocos2dx_ClippingNode_setInverted));
    cls->defineFunction("setStencil", _SE(js_cocos2dx_ClippingNode_setStencil));
    cls->defineFunction("getAlphaThreshold", _SE(js_cocos2dx_ClippingNode_getAlphaThreshold));
    cls->defineFunction("init", _SE(js_cocos2dx_ClippingNode_init));
    cls->defineFunction("getStencil", _SE(js_cocos2dx_ClippingNode_getStencil));
    cls->defineFunction("setAlphaThreshold", _SE(js_cocos2dx_ClippingNode_setAlphaThreshold));
    cls->defineFunction("isInverted", _SE(js_cocos2dx_ClippingNode_isInverted));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ClippingNode_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ClippingNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ClippingNode>(cls);

    __jsb_cocos2d_ClippingNode_proto = cls->getProto();
    __jsb_cocos2d_ClippingNode_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_DrawNode_proto = nullptr;
se::Class* __jsb_cocos2d_DrawNode_class = nullptr;

static bool js_cocos2dx_DrawNode_drawLine(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawLine : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawLine : Error processing arguments");
        cobj->drawLine(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawLine)

static bool js_cocos2dx_DrawNode_drawPoints(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawPoints : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            const cocos2d::Vec2* arg0 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg3;
            ok &= seval_to_Color4F(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->drawPoints(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            const cocos2d::Vec2* arg0 = nullptr;
            std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
            if (!ok) { ok = true; break; }
            unsigned int arg1 = 0;
            ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg2;
            ok &= seval_to_Color4F(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->drawPoints(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPoints)

static bool js_cocos2dx_DrawNode_drawRect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg4;
            ok &= seval_to_Color4F(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->drawRect(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg2;
            ok &= seval_to_Color4F(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->drawRect(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawRect)

static bool js_cocos2dx_DrawNode_drawSolidCircle(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawSolidCircle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg4;
            ok &= seval_to_Color4F(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 7) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            float arg5 = 0;
            ok &= seval_to_float(args[5], &arg5);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg6;
            ok &= seval_to_Color4F(args[6], &arg6);
            if (!ok) { ok = true; break; }
            cobj->drawSolidCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidCircle)

static bool js_cocos2dx_DrawNode_setLineWidth(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_setLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_setLineWidth : Error processing arguments");
        cobj->setLineWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_setLineWidth)

static bool js_cocos2dx_DrawNode_onDrawGLPoint(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDrawGLPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDrawGLPoint : Error processing arguments");
        cobj->onDrawGLPoint(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDrawGLPoint)

static bool js_cocos2dx_DrawNode_drawPolygon(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawPolygon : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        const cocos2d::Vec2* arg0 = nullptr;
        int arg1 = 0;
        cocos2d::Color4F arg2;
        float arg3 = 0;
        cocos2d::Color4F arg4;
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        ok &= seval_to_Color4F(args[4], &arg4);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawPolygon : Error processing arguments");
        cobj->drawPolygon(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPolygon)

static bool js_cocos2dx_DrawNode_drawDot(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawDot : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        float arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawDot : Error processing arguments");
        cobj->drawDot(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawDot)

static bool js_cocos2dx_DrawNode_drawCatmullRom(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCatmullRom : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::PointArray* arg0 = nullptr;
        unsigned int arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCatmullRom : Error processing arguments");
        cobj->drawCatmullRom(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCatmullRom)

static bool js_cocos2dx_DrawNode_drawSegment(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSegment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        float arg2 = 0;
        cocos2d::Color4F arg3;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSegment : Error processing arguments");
        cobj->drawSegment(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSegment)

static bool js_cocos2dx_DrawNode_getBlendFunc(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_getBlendFunc)

static bool js_cocos2dx_DrawNode_onDraw(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDraw : Error processing arguments");
        cobj->onDraw(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDraw)

static bool js_cocos2dx_DrawNode_drawCircle(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_DrawNode_drawCircle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 6) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool arg4;
            ok &= seval_to_boolean(args[4], &arg4);
            cocos2d::Color4F arg5;
            ok &= seval_to_Color4F(args[5], &arg5);
            if (!ok) { ok = true; break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5);
            return true;
        }
    } while(false);

    do {
        if (argc == 8) {
            cocos2d::Vec2 arg0;
            ok &= seval_to_Vec2(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool arg4;
            ok &= seval_to_boolean(args[4], &arg4);
            float arg5 = 0;
            ok &= seval_to_float(args[5], &arg5);
            if (!ok) { ok = true; break; }
            float arg6 = 0;
            ok &= seval_to_float(args[6], &arg6);
            if (!ok) { ok = true; break; }
            cocos2d::Color4F arg7;
            ok &= seval_to_Color4F(args[7], &arg7);
            if (!ok) { ok = true; break; }
            cobj->drawCircle(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCircle)

static bool js_cocos2dx_DrawNode_drawQuadBezier(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawQuadBezier : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 5) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        unsigned int arg3 = 0;
        cocos2d::Color4F arg4;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
        ok &= seval_to_Color4F(args[4], &arg4);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawQuadBezier : Error processing arguments");
        cobj->drawQuadBezier(arg0, arg1, arg2, arg3, arg4);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 5);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawQuadBezier)

static bool js_cocos2dx_DrawNode_onDrawGLLine(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_onDrawGLLine : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Mat4 arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_Mat4(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_onDrawGLLine : Error processing arguments");
        cobj->onDrawGLLine(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_onDrawGLLine)

static bool js_cocos2dx_DrawNode_drawSolidPoly(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSolidPoly : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        const cocos2d::Vec2* arg0 = nullptr;
        unsigned int arg1 = 0;
        cocos2d::Color4F arg2;
        std::vector<cocos2d::Vec2> tempData;ok &= seval_to_std_vector_Vec2(args[0], &tempData);arg0=tempData.data();
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSolidPoly : Error processing arguments");
        cobj->drawSolidPoly(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidPoly)

static bool js_cocos2dx_DrawNode_drawTriangle(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawTriangle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        cocos2d::Color4F arg3;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawTriangle : Error processing arguments");
        cobj->drawTriangle(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawTriangle)

static bool js_cocos2dx_DrawNode_setBlendFunc(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_setBlendFunc)

static bool js_cocos2dx_DrawNode_clear(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_clear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->clear();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_clear)

static bool js_cocos2dx_DrawNode_drawCardinalSpline(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCardinalSpline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::PointArray* arg0 = nullptr;
        float arg1 = 0;
        unsigned int arg2 = 0;
        cocos2d::Color4F arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_uint32(args[2], (uint32_t*)&arg2);
        ok &= seval_to_Color4F(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCardinalSpline : Error processing arguments");
        cobj->drawCardinalSpline(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCardinalSpline)

static bool js_cocos2dx_DrawNode_drawSolidRect(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawSolidRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawSolidRect : Error processing arguments");
        cobj->drawSolidRect(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawSolidRect)

static bool js_cocos2dx_DrawNode_getLineWidth(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_getLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineWidth();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_getLineWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_getLineWidth)

static bool js_cocos2dx_DrawNode_drawPoint(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        float arg1 = 0;
        cocos2d::Color4F arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_Color4F(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawPoint : Error processing arguments");
        cobj->drawPoint(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawPoint)

static bool js_cocos2dx_DrawNode_drawCubicBezier(se::State& s)
{
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_DrawNode_drawCubicBezier : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        cocos2d::Vec2 arg0;
        cocos2d::Vec2 arg1;
        cocos2d::Vec2 arg2;
        cocos2d::Vec2 arg3;
        unsigned int arg4 = 0;
        cocos2d::Color4F arg5;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_Vec2(args[3], &arg3);
        ok &= seval_to_uint32(args[4], (uint32_t*)&arg4);
        ok &= seval_to_Color4F(args[5], &arg5);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_drawCubicBezier : Error processing arguments");
        cobj->drawCubicBezier(arg0, arg1, arg2, arg3, arg4, arg5);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_drawCubicBezier)

static bool js_cocos2dx_DrawNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::DrawNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DrawNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_DrawNode_create : Error processing arguments");
        auto result = cocos2d::DrawNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_DrawNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_DrawNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_DrawNode_finalize)

static bool js_cocos2dx_DrawNode_constructor(se::State& s)
{
    cocos2d::DrawNode* cobj = new (std::nothrow) cocos2d::DrawNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_DrawNode_constructor, __jsb_cocos2d_DrawNode_class, js_cocos2d_DrawNode_finalize)

static bool js_cocos2dx_DrawNode_ctor(se::State& s)
{
    cocos2d::DrawNode* cobj = new (std::nothrow) cocos2d::DrawNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_DrawNode_ctor, __jsb_cocos2d_DrawNode_class, js_cocos2d_DrawNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_DrawNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::DrawNode)", s.nativeThisObject());
    cocos2d::DrawNode* cobj = (cocos2d::DrawNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_DrawNode_finalize)

bool js_register_cocos2dx_DrawNode(se::Object* obj)
{
    auto cls = se::Class::create("DrawNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_DrawNode_constructor));

    cls->defineFunction("drawLine", _SE(js_cocos2dx_DrawNode_drawLine));
    cls->defineFunction("drawPoints", _SE(js_cocos2dx_DrawNode_drawPoints));
    cls->defineFunction("drawRect", _SE(js_cocos2dx_DrawNode_drawRect));
    cls->defineFunction("drawSolidCircle", _SE(js_cocos2dx_DrawNode_drawSolidCircle));
    cls->defineFunction("setLineWidth", _SE(js_cocos2dx_DrawNode_setLineWidth));
    cls->defineFunction("onDrawGLPoint", _SE(js_cocos2dx_DrawNode_onDrawGLPoint));
    cls->defineFunction("drawPolygon", _SE(js_cocos2dx_DrawNode_drawPolygon));
    cls->defineFunction("drawDot", _SE(js_cocos2dx_DrawNode_drawDot));
    cls->defineFunction("drawCatmullRom", _SE(js_cocos2dx_DrawNode_drawCatmullRom));
    cls->defineFunction("drawSegment", _SE(js_cocos2dx_DrawNode_drawSegment));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_DrawNode_getBlendFunc));
    cls->defineFunction("onDraw", _SE(js_cocos2dx_DrawNode_onDraw));
    cls->defineFunction("drawCircle", _SE(js_cocos2dx_DrawNode_drawCircle));
    cls->defineFunction("drawQuadBezier", _SE(js_cocos2dx_DrawNode_drawQuadBezier));
    cls->defineFunction("onDrawGLLine", _SE(js_cocos2dx_DrawNode_onDrawGLLine));
    cls->defineFunction("drawSolidPoly", _SE(js_cocos2dx_DrawNode_drawSolidPoly));
    cls->defineFunction("drawTriangle", _SE(js_cocos2dx_DrawNode_drawTriangle));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_DrawNode_setBlendFunc));
    cls->defineFunction("clear", _SE(js_cocos2dx_DrawNode_clear));
    cls->defineFunction("drawCardinalSpline", _SE(js_cocos2dx_DrawNode_drawCardinalSpline));
    cls->defineFunction("drawSolidRect", _SE(js_cocos2dx_DrawNode_drawSolidRect));
    cls->defineFunction("getLineWidth", _SE(js_cocos2dx_DrawNode_getLineWidth));
    cls->defineFunction("drawPoint", _SE(js_cocos2dx_DrawNode_drawPoint));
    cls->defineFunction("drawCubicBezier", _SE(js_cocos2dx_DrawNode_drawCubicBezier));
    cls->defineFunction("ctor", _SE(js_cocos2dx_DrawNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_DrawNode_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_DrawNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::DrawNode>(cls);

    __jsb_cocos2d_DrawNode_proto = cls->getProto();
    __jsb_cocos2d_DrawNode_class = cls;

    jsb_set_extend_property("cc", "DrawNode");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Label_proto = nullptr;
se::Class* __jsb_cocos2d_Label_class = nullptr;

static bool js_cocos2dx_Label_isClipMarginEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isClipMarginEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isClipMarginEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_isClipMarginEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isClipMarginEnabled)

static bool js_cocos2dx_Label_enableShadow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableShadow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cobj->enableShadow();
        return true;
    }
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Color4B arg0;
        cocos2d::Size arg1;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1);
        return true;
    }
    if (argc == 3) {
        cocos2d::Color4B arg0;
        cocos2d::Size arg1;
        int arg2 = 0;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_Size(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableShadow : Error processing arguments");
        cobj->enableShadow(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableShadow)

static bool js_cocos2dx_Label_setDimensions(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setDimensions : Error processing arguments");
        cobj->setDimensions(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setDimensions)

static bool js_cocos2dx_Label_getWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getWidth();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getWidth)

static bool js_cocos2dx_Label_getString(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getString)

static bool js_cocos2dx_Label_getHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getHeight();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getHeight)

static bool js_cocos2dx_Label_disableEffect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Label_disableEffect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::LabelEffect arg0;
            ok &= seval_to_int8(args[0], (int8_t*)&arg0);
            if (!ok) { ok = true; break; }
            cobj->disableEffect(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            cobj->disableEffect();
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_disableEffect)

static bool js_cocos2dx_Label_setTTFConfig(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setTTFConfig : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TTFConfig arg0;
        ok &= seval_to_TTFConfig(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setTTFConfig : Error processing arguments");
        bool result = cobj->setTTFConfig(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setTTFConfig : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setTTFConfig)

static bool js_cocos2dx_Label_getTextColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTextColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4B& result = cobj->getTextColor();
        ok &= Color4B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTextColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTextColor)

static bool js_cocos2dx_Label_getBlendFunc(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBlendFunc)

static bool js_cocos2dx_Label_enableWrap(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableWrap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableWrap : Error processing arguments");
        cobj->enableWrap(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableWrap)

static bool js_cocos2dx_Label_setWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setWidth : Error processing arguments");
        cobj->setWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setWidth)

static bool js_cocos2dx_Label_getAdditionalKerning(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getAdditionalKerning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAdditionalKerning();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getAdditionalKerning : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getAdditionalKerning)

static bool js_cocos2dx_Label_getBMFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBMFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getBMFontSize();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBMFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBMFontSize)

static bool js_cocos2dx_Label_getMaxLineWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getMaxLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMaxLineWidth();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getMaxLineWidth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getMaxLineWidth)

static bool js_cocos2dx_Label_getHorizontalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        char result = (char)cobj->getHorizontalAlignment();
        ok &= int8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getHorizontalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getHorizontalAlignment)

static bool js_cocos2dx_Label_getShadowOffset(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getShadowOffset();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowOffset)

static bool js_cocos2dx_Label_getLineSpacing(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLineSpacing : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineSpacing();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLineSpacing : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLineSpacing)

static bool js_cocos2dx_Label_setClipMarginEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setClipMarginEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setClipMarginEnabled : Error processing arguments");
        cobj->setClipMarginEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setClipMarginEnabled)

static bool js_cocos2dx_Label_setString(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setString)

static bool js_cocos2dx_Label_setSystemFontName(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setSystemFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setSystemFontName : Error processing arguments");
        cobj->setSystemFontName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setSystemFontName)

static bool js_cocos2dx_Label_isWrapEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isWrapEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isWrapEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_isWrapEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isWrapEnabled)

static bool js_cocos2dx_Label_getOutlineSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getOutlineSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getOutlineSize();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getOutlineSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getOutlineSize)

static bool js_cocos2dx_Label_setBMFontFilePath(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBMFontFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::SpriteFrame* arg1 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    if (argc == 3) {
        std::string arg0;
        cocos2d::SpriteFrame* arg1 = nullptr;
        cocos2d::Vec2 arg2;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        cocos2d::SpriteFrame* arg1 = nullptr;
        cocos2d::Vec2 arg2;
        float arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_Vec2(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        bool result = cobj->setBMFontFilePath(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBMFontFilePath)

static bool js_cocos2dx_Label_initWithTTF(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Label_initWithTTF : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int8(args[5], (int8_t*)&arg5);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTTF(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_initWithTTF : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_initWithTTF)

static bool js_cocos2dx_Label_setLineHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineHeight : Error processing arguments");
        cobj->setLineHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineHeight)

static bool js_cocos2dx_Label_setSystemFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setSystemFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setSystemFontSize : Error processing arguments");
        cobj->setSystemFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setSystemFontSize)

static bool js_cocos2dx_Label_setOverflow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setOverflow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Label::Overflow arg0;
        ok &= seval_to_int8(args[0], (int8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setOverflow : Error processing arguments");
        cobj->setOverflow(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setOverflow)

static bool js_cocos2dx_Label_enableStrikethrough(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableStrikethrough : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableStrikethrough();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableStrikethrough)

static bool js_cocos2dx_Label_updateContent(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_updateContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateContent();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_updateContent)

static bool js_cocos2dx_Label_getStringLength(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getStringLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStringLength();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getStringLength : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getStringLength)

static bool js_cocos2dx_Label_setLineBreakWithoutSpace(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineBreakWithoutSpace : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineBreakWithoutSpace : Error processing arguments");
        cobj->setLineBreakWithoutSpace(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineBreakWithoutSpace)

static bool js_cocos2dx_Label_getStringNumLines(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getStringNumLines : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStringNumLines();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getStringNumLines : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getStringNumLines)

static bool js_cocos2dx_Label_enableOutline(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableOutline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableOutline : Error processing arguments");
        cobj->enableOutline(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Color4B arg0;
        int arg1 = 0;
        ok &= seval_to_Color4B(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableOutline : Error processing arguments");
        cobj->enableOutline(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableOutline)

static bool js_cocos2dx_Label_getShadowBlurRadius(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowBlurRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getShadowBlurRadius();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowBlurRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowBlurRadius)

static bool js_cocos2dx_Label_getEffectColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getEffectColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Color4F result = cobj->getEffectColor();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getEffectColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getEffectColor)

static bool js_cocos2dx_Label_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Label_setCharMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Label_setCharMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->setCharMap(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setCharMap : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setCharMap)

static bool js_cocos2dx_Label_getFontDefinition(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getFontDefinition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::FontDefinition result = cobj->getFontDefinition();
        ok &= FontDefinition_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getFontDefinition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getFontDefinition)

static bool js_cocos2dx_Label_getDimensions(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getDimensions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getDimensions();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getDimensions : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getDimensions)

static bool js_cocos2dx_Label_setMaxLineWidth(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setMaxLineWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setMaxLineWidth : Error processing arguments");
        cobj->setMaxLineWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setMaxLineWidth)

static bool js_cocos2dx_Label_getSystemFontName(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getSystemFontName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getSystemFontName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getSystemFontName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getSystemFontName)

static bool js_cocos2dx_Label_setVerticalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextVAlignment arg0;
        ok &= seval_to_int8(args[0], (int8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setVerticalAlignment : Error processing arguments");
        cobj->setVerticalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setVerticalAlignment)

static bool js_cocos2dx_Label_setLineSpacing(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setLineSpacing : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setLineSpacing : Error processing arguments");
        cobj->setLineSpacing(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setLineSpacing)

static bool js_cocos2dx_Label_getLineHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLineHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLineHeight();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLineHeight : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLineHeight)

static bool js_cocos2dx_Label_getShadowColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getShadowColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Color4F result = cobj->getShadowColor();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getShadowColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getShadowColor)

static bool js_cocos2dx_Label_getTTFConfig(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTTFConfig : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::TTFConfig& result = cobj->getTTFConfig();
        #pragma warning NO CONVERSION FROM NATIVE FOR _ttfConfig;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTTFConfig : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTTFConfig)

static bool js_cocos2dx_Label_enableItalics(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableItalics : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableItalics();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableItalics)

static bool js_cocos2dx_Label_setTextColor(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setTextColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setTextColor : Error processing arguments");
        cobj->setTextColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setTextColor)

static bool js_cocos2dx_Label_getLetter(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLetter : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLetter : Error processing arguments");
        cocos2d::Sprite* result = cobj->getLetter(arg0);
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLetter : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLetter)

static bool js_cocos2dx_Label_setHeight(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setHeight : Error processing arguments");
        cobj->setHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setHeight)

static bool js_cocos2dx_Label_isShadowEnabled(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_isShadowEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isShadowEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_isShadowEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_isShadowEnabled)

static bool js_cocos2dx_Label_enableGlow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableGlow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4B arg0;
        ok &= seval_to_Color4B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_enableGlow : Error processing arguments");
        cobj->enableGlow(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableGlow)

static bool js_cocos2dx_Label_getOverflow(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getOverflow : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        char result = (char)cobj->getOverflow();
        ok &= int8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getOverflow : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getOverflow)

static bool js_cocos2dx_Label_getVerticalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getVerticalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        char result = (char)cobj->getVerticalAlignment();
        ok &= int8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getVerticalAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getVerticalAlignment)

static bool js_cocos2dx_Label_setAdditionalKerning(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setAdditionalKerning : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setAdditionalKerning : Error processing arguments");
        cobj->setAdditionalKerning(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setAdditionalKerning)

static bool js_cocos2dx_Label_getSystemFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getSystemFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSystemFontSize();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getSystemFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getSystemFontSize)

static bool js_cocos2dx_Label_setBlendFunc(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBlendFunc)

static bool js_cocos2dx_Label_getTextAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getTextAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        char result = (char)cobj->getTextAlignment();
        ok &= int8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getTextAlignment : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getTextAlignment)

static bool js_cocos2dx_Label_getBMFontFilePath(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getBMFontFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getBMFontFilePath();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getBMFontFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getBMFontFilePath)

static bool js_cocos2dx_Label_setHorizontalAlignment(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setHorizontalAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextHAlignment arg0;
        ok &= seval_to_int8(args[0], (int8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setHorizontalAlignment : Error processing arguments");
        cobj->setHorizontalAlignment(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setHorizontalAlignment)

static bool js_cocos2dx_Label_enableBold(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableBold : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableBold();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableBold)

static bool js_cocos2dx_Label_enableUnderline(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_enableUnderline : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->enableUnderline();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_enableUnderline)

static bool js_cocos2dx_Label_getLabelEffectType(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_getLabelEffectType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        char result = (char)cobj->getLabelEffectType();
        ok &= int8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_getLabelEffectType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_getLabelEffectType)

static bool js_cocos2dx_Label_setFontDefinition(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setFontDefinition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::FontDefinition arg0;
        ok &= seval_to_FontDefinition(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setFontDefinition : Error processing arguments");
        cobj->setFontDefinition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setFontDefinition)

static bool js_cocos2dx_Label_setAlignment(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Label_setAlignment : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::TextHAlignment arg0;
            ok &= seval_to_int8(args[0], (int8_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg1;
            ok &= seval_to_int8(args[1], (int8_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setAlignment(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::TextHAlignment arg0;
            ok &= seval_to_int8(args[0], (int8_t*)&arg0);
            if (!ok) { ok = true; break; }
            cobj->setAlignment(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setAlignment)

static bool js_cocos2dx_Label_requestSystemFontRefresh(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_requestSystemFontRefresh : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->requestSystemFontRefresh();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_requestSystemFontRefresh)

static bool js_cocos2dx_Label_setBMFontSize(se::State& s)
{
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Label_setBMFontSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_setBMFontSize : Error processing arguments");
        cobj->setBMFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_setBMFontSize)

static bool js_cocos2dx_Label_createWithBMFont(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        cocos2d::SpriteFrame* arg2 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        cocos2d::SpriteFrame* arg2 = nullptr;
        cocos2d::TextHAlignment arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        ok &= seval_to_int8(args[3], (int8_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        cocos2d::SpriteFrame* arg2 = nullptr;
        cocos2d::TextHAlignment arg3;
        int arg4 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        ok &= seval_to_int8(args[3], (int8_t*)&arg3);
        ok &= seval_to_int32(args[4], (int32_t*)&arg4);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        cocos2d::SpriteFrame* arg2 = nullptr;
        cocos2d::TextHAlignment arg3;
        int arg4 = 0;
        cocos2d::Vec2 arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        ok &= seval_to_int8(args[3], (int8_t*)&arg3);
        ok &= seval_to_int32(args[4], (int32_t*)&arg4);
        ok &= seval_to_Vec2(args[5], &arg5);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithBMFont : Error processing arguments");
        auto result = cocos2d::Label::createWithBMFont(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithBMFont)

static bool js_cocos2dx_Label_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Label::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_create)

static bool js_cocos2dx_Label_createWithCharMap(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithCharMap(arg0);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithCharMap : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithCharMap)

static bool js_cocos2dx_Label_createWithSystemFont(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 5) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int8(args[4], (int8_t*)&arg4);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        float arg2 = 0;
        cocos2d::Size arg3;
        cocos2d::TextHAlignment arg4;
        cocos2d::TextVAlignment arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_Size(args[3], &arg3);
        ok &= seval_to_int8(args[4], (int8_t*)&arg4);
        ok &= seval_to_int8(args[5], (int8_t*)&arg5);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithSystemFont : Error processing arguments");
        auto result = cocos2d::Label::createWithSystemFont(arg0, arg1, arg2, arg3, arg4, arg5);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Label_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithSystemFont)

static bool js_cocos2dx_Label_createWithTTF(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            cocos2d::TTFConfig arg0;
            ok &= seval_to_TTFConfig(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 6) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg3;
            ok &= seval_to_Size(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg4;
            ok &= seval_to_int8(args[4], (int8_t*)&arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextVAlignment arg5;
            ok &= seval_to_int8(args[5], (int8_t*)&arg5);
            if (!ok) { ok = true; break; }
            cocos2d::Label* result = cocos2d::Label::createWithTTF(arg0, arg1, arg2, arg3, arg4, arg5);
            ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Label_createWithTTF : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Label_createWithTTF)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Label_finalize)

static bool js_cocos2dx_Label_constructor(se::State& s)
{
    cocos2d::Label* cobj = new (std::nothrow) cocos2d::Label();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Label_constructor, __jsb_cocos2d_Label_class, js_cocos2d_Label_finalize)

static bool js_cocos2dx_Label_ctor(se::State& s)
{
    cocos2d::Label* cobj = new (std::nothrow) cocos2d::Label();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Label_ctor, __jsb_cocos2d_Label_class, js_cocos2d_Label_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_Label_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Label)", s.nativeThisObject());
    cocos2d::Label* cobj = (cocos2d::Label*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Label_finalize)

bool js_register_cocos2dx_Label(se::Object* obj)
{
    auto cls = se::Class::create("Label", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Label_constructor));

    cls->defineFunction("isClipMarginEnabled", _SE(js_cocos2dx_Label_isClipMarginEnabled));
    cls->defineFunction("enableShadow", _SE(js_cocos2dx_Label_enableShadow));
    cls->defineFunction("setDimensions", _SE(js_cocos2dx_Label_setDimensions));
    cls->defineFunction("getWidth", _SE(js_cocos2dx_Label_getWidth));
    cls->defineFunction("getString", _SE(js_cocos2dx_Label_getString));
    cls->defineFunction("getHeight", _SE(js_cocos2dx_Label_getHeight));
    cls->defineFunction("disableEffect", _SE(js_cocos2dx_Label_disableEffect));
    cls->defineFunction("setTTFConfig", _SE(js_cocos2dx_Label_setTTFConfig));
    cls->defineFunction("getTextColor", _SE(js_cocos2dx_Label_getTextColor));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_Label_getBlendFunc));
    cls->defineFunction("enableWrap", _SE(js_cocos2dx_Label_enableWrap));
    cls->defineFunction("setWidth", _SE(js_cocos2dx_Label_setWidth));
    cls->defineFunction("getAdditionalKerning", _SE(js_cocos2dx_Label_getAdditionalKerning));
    cls->defineFunction("getBMFontSize", _SE(js_cocos2dx_Label_getBMFontSize));
    cls->defineFunction("getMaxLineWidth", _SE(js_cocos2dx_Label_getMaxLineWidth));
    cls->defineFunction("getHorizontalAlignment", _SE(js_cocos2dx_Label_getHorizontalAlignment));
    cls->defineFunction("getShadowOffset", _SE(js_cocos2dx_Label_getShadowOffset));
    cls->defineFunction("getLineSpacing", _SE(js_cocos2dx_Label_getLineSpacing));
    cls->defineFunction("setClipMarginEnabled", _SE(js_cocos2dx_Label_setClipMarginEnabled));
    cls->defineFunction("setString", _SE(js_cocos2dx_Label_setString));
    cls->defineFunction("setSystemFontName", _SE(js_cocos2dx_Label_setSystemFontName));
    cls->defineFunction("isWrapEnabled", _SE(js_cocos2dx_Label_isWrapEnabled));
    cls->defineFunction("getOutlineSize", _SE(js_cocos2dx_Label_getOutlineSize));
    cls->defineFunction("setBMFontFilePath", _SE(js_cocos2dx_Label_setBMFontFilePath));
    cls->defineFunction("initWithTTF", _SE(js_cocos2dx_Label_initWithTTF));
    cls->defineFunction("setLineHeight", _SE(js_cocos2dx_Label_setLineHeight));
    cls->defineFunction("setSystemFontSize", _SE(js_cocos2dx_Label_setSystemFontSize));
    cls->defineFunction("setOverflow", _SE(js_cocos2dx_Label_setOverflow));
    cls->defineFunction("enableStrikethrough", _SE(js_cocos2dx_Label_enableStrikethrough));
    cls->defineFunction("updateContent", _SE(js_cocos2dx_Label_updateContent));
    cls->defineFunction("getStringLength", _SE(js_cocos2dx_Label_getStringLength));
    cls->defineFunction("setLineBreakWithoutSpace", _SE(js_cocos2dx_Label_setLineBreakWithoutSpace));
    cls->defineFunction("getStringNumLines", _SE(js_cocos2dx_Label_getStringNumLines));
    cls->defineFunction("enableOutline", _SE(js_cocos2dx_Label_enableOutline));
    cls->defineFunction("getShadowBlurRadius", _SE(js_cocos2dx_Label_getShadowBlurRadius));
    cls->defineFunction("getEffectColor", _SE(js_cocos2dx_Label_getEffectColor));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_Label_removeAllChildrenWithCleanup));
    cls->defineFunction("setCharMap", _SE(js_cocos2dx_Label_setCharMap));
    cls->defineFunction("getFontDefinition", _SE(js_cocos2dx_Label_getFontDefinition));
    cls->defineFunction("getDimensions", _SE(js_cocos2dx_Label_getDimensions));
    cls->defineFunction("setMaxLineWidth", _SE(js_cocos2dx_Label_setMaxLineWidth));
    cls->defineFunction("getSystemFontName", _SE(js_cocos2dx_Label_getSystemFontName));
    cls->defineFunction("setVerticalAlignment", _SE(js_cocos2dx_Label_setVerticalAlignment));
    cls->defineFunction("setLineSpacing", _SE(js_cocos2dx_Label_setLineSpacing));
    cls->defineFunction("getLineHeight", _SE(js_cocos2dx_Label_getLineHeight));
    cls->defineFunction("getShadowColor", _SE(js_cocos2dx_Label_getShadowColor));
    cls->defineFunction("getTTFConfig", _SE(js_cocos2dx_Label_getTTFConfig));
    cls->defineFunction("enableItalics", _SE(js_cocos2dx_Label_enableItalics));
    cls->defineFunction("setTextColor", _SE(js_cocos2dx_Label_setTextColor));
    cls->defineFunction("getLetter", _SE(js_cocos2dx_Label_getLetter));
    cls->defineFunction("setHeight", _SE(js_cocos2dx_Label_setHeight));
    cls->defineFunction("isShadowEnabled", _SE(js_cocos2dx_Label_isShadowEnabled));
    cls->defineFunction("enableGlow", _SE(js_cocos2dx_Label_enableGlow));
    cls->defineFunction("getOverflow", _SE(js_cocos2dx_Label_getOverflow));
    cls->defineFunction("getVerticalAlignment", _SE(js_cocos2dx_Label_getVerticalAlignment));
    cls->defineFunction("setAdditionalKerning", _SE(js_cocos2dx_Label_setAdditionalKerning));
    cls->defineFunction("getSystemFontSize", _SE(js_cocos2dx_Label_getSystemFontSize));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_Label_setBlendFunc));
    cls->defineFunction("getTextAlignment", _SE(js_cocos2dx_Label_getTextAlignment));
    cls->defineFunction("getBMFontFilePath", _SE(js_cocos2dx_Label_getBMFontFilePath));
    cls->defineFunction("setHorizontalAlignment", _SE(js_cocos2dx_Label_setHorizontalAlignment));
    cls->defineFunction("enableBold", _SE(js_cocos2dx_Label_enableBold));
    cls->defineFunction("enableUnderline", _SE(js_cocos2dx_Label_enableUnderline));
    cls->defineFunction("getLabelEffectType", _SE(js_cocos2dx_Label_getLabelEffectType));
    cls->defineFunction("setFontDefinition", _SE(js_cocos2dx_Label_setFontDefinition));
    cls->defineFunction("setAlignment", _SE(js_cocos2dx_Label_setAlignment));
    cls->defineFunction("requestSystemFontRefresh", _SE(js_cocos2dx_Label_requestSystemFontRefresh));
    cls->defineFunction("setBMFontSize", _SE(js_cocos2dx_Label_setBMFontSize));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Label_ctor));
    cls->defineStaticFunction("createWithBMFont", _SE(js_cocos2dx_Label_createWithBMFont));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Label_create));
    cls->defineStaticFunction("createWithCharMap", _SE(js_cocos2dx_Label_createWithCharMap));
    cls->defineStaticFunction("createWithSystemFont", _SE(js_cocos2dx_Label_createWithSystemFont));
    cls->defineStaticFunction("createWithTTF", _SE(js_cocos2dx_Label_createWithTTF));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Label_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Label>(cls);

    __jsb_cocos2d_Label_proto = cls->getProto();
    __jsb_cocos2d_Label_class = cls;

    jsb_set_extend_property("cc", "Label");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_LabelTTF_proto = nullptr;
se::Class* __jsb_cocos2d_LabelTTF_class = nullptr;

static bool js_cocos2dx_LabelTTF_getRenderLabel(se::State& s)
{
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LabelTTF_getRenderLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Label* result = cobj->getRenderLabel();
        ok &= native_ptr_to_seval<cocos2d::Label>((cocos2d::Label*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LabelTTF_getRenderLabel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LabelTTF_getRenderLabel)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LabelTTF_finalize)

static bool js_cocos2dx_LabelTTF_constructor(se::State& s)
{
    cocos2d::LabelTTF* cobj = new (std::nothrow) cocos2d::LabelTTF();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LabelTTF_constructor, __jsb_cocos2d_LabelTTF_class, js_cocos2d_LabelTTF_finalize)

static bool js_cocos2dx_LabelTTF_ctor(se::State& s)
{
    cocos2d::LabelTTF* cobj = new (std::nothrow) cocos2d::LabelTTF();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LabelTTF_ctor, __jsb_cocos2d_LabelTTF_class, js_cocos2d_LabelTTF_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_LabelTTF_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::LabelTTF)", s.nativeThisObject());
    cocos2d::LabelTTF* cobj = (cocos2d::LabelTTF*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LabelTTF_finalize)

bool js_register_cocos2dx_LabelTTF(se::Object* obj)
{
    auto cls = se::Class::create("LabelTTF", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_LabelTTF_constructor));

    cls->defineFunction("getRenderLabel", _SE(js_cocos2dx_LabelTTF_getRenderLabel));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LabelTTF_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_LabelTTF_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LabelTTF>(cls);

    __jsb_cocos2d_LabelTTF_proto = cls->getProto();
    __jsb_cocos2d_LabelTTF_class = cls;

    jsb_set_extend_property("cc", "LabelTTF");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Layer_proto = nullptr;
se::Class* __jsb_cocos2d_Layer_class = nullptr;

static bool js_cocos2dx_Layer_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::Layer::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_Layer_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Layer_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Layer_finalize)

static bool js_cocos2dx_Layer_constructor(se::State& s)
{
    cocos2d::Layer* cobj = new (std::nothrow) cocos2d::Layer();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Layer_constructor, __jsb_cocos2d_Layer_class, js_cocos2d_Layer_finalize)

static bool js_cocos2dx_Layer_ctor(se::State& s)
{
    cocos2d::Layer* cobj = new (std::nothrow) cocos2d::Layer();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Layer_ctor, __jsb_cocos2d_Layer_class, js_cocos2d_Layer_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_Layer_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Layer)", s.nativeThisObject());
    cocos2d::Layer* cobj = (cocos2d::Layer*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Layer_finalize)

bool js_register_cocos2dx_Layer(se::Object* obj)
{
    auto cls = se::Class::create("Layer", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Layer_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_Layer_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_Layer_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Layer_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Layer>(cls);

    __jsb_cocos2d_Layer_proto = cls->getProto();
    __jsb_cocos2d_Layer_class = cls;

    jsb_set_extend_property("cc", "Layer");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_LayerColor_proto = nullptr;
se::Class* __jsb_cocos2d_LayerColor_class = nullptr;

static bool js_cocos2dx_LayerColor_changeWidthAndHeight(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeWidthAndHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        float arg0 = 0;
        float arg1 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeWidthAndHeight : Error processing arguments");
        cobj->changeWidthAndHeight(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeWidthAndHeight)

static bool js_cocos2dx_LayerColor_getBlendFunc(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_getBlendFunc)

static bool js_cocos2dx_LayerColor_setBlendFunc(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_setBlendFunc)

static bool js_cocos2dx_LayerColor_changeWidth(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeWidth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeWidth : Error processing arguments");
        cobj->changeWidth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeWidth)

static bool js_cocos2dx_LayerColor_initWithColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_LayerColor_initWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            bool result = cobj->init();
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_initWithColor)

static bool js_cocos2dx_LayerColor_changeHeight(se::State& s)
{
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerColor_changeHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_changeHeight : Error processing arguments");
        cobj->changeHeight(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_changeHeight)

static bool js_cocos2dx_LayerColor_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LayerColor* result = cocos2d::LayerColor::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::LayerColor* result = cocos2d::LayerColor::create();
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::LayerColor* result = cocos2d::LayerColor::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::LayerColor>((cocos2d::LayerColor*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerColor_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerColor_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerColor_finalize)

static bool js_cocos2dx_LayerColor_constructor(se::State& s)
{
    cocos2d::LayerColor* cobj = new (std::nothrow) cocos2d::LayerColor();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerColor_constructor, __jsb_cocos2d_LayerColor_class, js_cocos2d_LayerColor_finalize)

static bool js_cocos2dx_LayerColor_ctor(se::State& s)
{
    cocos2d::LayerColor* cobj = new (std::nothrow) cocos2d::LayerColor();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerColor_ctor, __jsb_cocos2d_LayerColor_class, js_cocos2d_LayerColor_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

static bool js_cocos2d_LayerColor_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::LayerColor)", s.nativeThisObject());
    cocos2d::LayerColor* cobj = (cocos2d::LayerColor*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerColor_finalize)

bool js_register_cocos2dx_LayerColor(se::Object* obj)
{
    auto cls = se::Class::create("LayerColor", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_LayerColor_constructor));

    cls->defineFunction("changeWidthAndHeight", _SE(js_cocos2dx_LayerColor_changeWidthAndHeight));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_LayerColor_getBlendFunc));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_LayerColor_setBlendFunc));
    cls->defineFunction("changeWidth", _SE(js_cocos2dx_LayerColor_changeWidth));
    cls->defineFunction("init", _SE(js_cocos2dx_LayerColor_initWithColor));
    cls->defineFunction("changeHeight", _SE(js_cocos2dx_LayerColor_changeHeight));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerColor_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LayerColor_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_LayerColor_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerColor>(cls);

    __jsb_cocos2d_LayerColor_proto = cls->getProto();
    __jsb_cocos2d_LayerColor_class = cls;

    jsb_set_extend_property("cc", "LayerColor");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_LayerGradient_proto = nullptr;
se::Class* __jsb_cocos2d_LayerGradient_class = nullptr;

static bool js_cocos2dx_LayerGradient_getStartColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getStartColor();
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getStartColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getStartColor)

static bool js_cocos2dx_LayerGradient_isCompressedInterpolation(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_isCompressedInterpolation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isCompressedInterpolation();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_isCompressedInterpolation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_isCompressedInterpolation)

static bool js_cocos2dx_LayerGradient_getStartOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getStartOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getStartOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getStartOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getStartOpacity)

static bool js_cocos2dx_LayerGradient_setVector(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setVector : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setVector : Error processing arguments");
        cobj->setVector(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setVector)

static bool js_cocos2dx_LayerGradient_setStartOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setStartOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], (uint8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setStartOpacity : Error processing arguments");
        cobj->setStartOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setStartOpacity)

static bool js_cocos2dx_LayerGradient_setCompressedInterpolation(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setCompressedInterpolation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setCompressedInterpolation : Error processing arguments");
        cobj->setCompressedInterpolation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setCompressedInterpolation)

static bool js_cocos2dx_LayerGradient_setEndOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setEndOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], (uint8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setEndOpacity : Error processing arguments");
        cobj->setEndOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setEndOpacity)

static bool js_cocos2dx_LayerGradient_getVector(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getVector : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getVector();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getVector : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getVector)

static bool js_cocos2dx_LayerGradient_setEndColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setEndColor : Error processing arguments");
        cobj->setEndColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setEndColor)

static bool js_cocos2dx_LayerGradient_initWithColor(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_LayerGradient_initWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithColor(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_initWithColor : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_initWithColor)

static bool js_cocos2dx_LayerGradient_getEndColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getEndColor();
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getEndColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getEndColor)

static bool js_cocos2dx_LayerGradient_getEndOpacity(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_getEndOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        uint8_t result = cobj->getEndOpacity();
        ok &= uint8_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_getEndOpacity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_getEndOpacity)

static bool js_cocos2dx_LayerGradient_setStartColor(se::State& s)
{
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerGradient_setStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_setStartColor : Error processing arguments");
        cobj->setStartColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_setStartColor)

static bool js_cocos2dx_LayerGradient_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create();
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 3) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Color4B arg1;
            ok &= seval_to_Color4B(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::LayerGradient* result = cocos2d::LayerGradient::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::LayerGradient>((cocos2d::LayerGradient*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerGradient_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerGradient_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerGradient_finalize)

static bool js_cocos2dx_LayerGradient_constructor(se::State& s)
{
    cocos2d::LayerGradient* cobj = new (std::nothrow) cocos2d::LayerGradient();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerGradient_constructor, __jsb_cocos2d_LayerGradient_class, js_cocos2d_LayerGradient_finalize)

static bool js_cocos2dx_LayerGradient_ctor(se::State& s)
{
    cocos2d::LayerGradient* cobj = new (std::nothrow) cocos2d::LayerGradient();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerGradient_ctor, __jsb_cocos2d_LayerGradient_class, js_cocos2d_LayerGradient_finalize)


    

extern se::Object* __jsb_cocos2d_LayerColor_proto;

static bool js_cocos2d_LayerGradient_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::LayerGradient)", s.nativeThisObject());
    cocos2d::LayerGradient* cobj = (cocos2d::LayerGradient*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerGradient_finalize)

bool js_register_cocos2dx_LayerGradient(se::Object* obj)
{
    auto cls = se::Class::create("LayerGradient", obj, __jsb_cocos2d_LayerColor_proto, _SE(js_cocos2dx_LayerGradient_constructor));

    cls->defineFunction("getStartColor", _SE(js_cocos2dx_LayerGradient_getStartColor));
    cls->defineFunction("isCompressedInterpolation", _SE(js_cocos2dx_LayerGradient_isCompressedInterpolation));
    cls->defineFunction("getStartOpacity", _SE(js_cocos2dx_LayerGradient_getStartOpacity));
    cls->defineFunction("setVector", _SE(js_cocos2dx_LayerGradient_setVector));
    cls->defineFunction("setStartOpacity", _SE(js_cocos2dx_LayerGradient_setStartOpacity));
    cls->defineFunction("setCompressedInterpolation", _SE(js_cocos2dx_LayerGradient_setCompressedInterpolation));
    cls->defineFunction("setEndOpacity", _SE(js_cocos2dx_LayerGradient_setEndOpacity));
    cls->defineFunction("getVector", _SE(js_cocos2dx_LayerGradient_getVector));
    cls->defineFunction("setEndColor", _SE(js_cocos2dx_LayerGradient_setEndColor));
    cls->defineFunction("initWithColor", _SE(js_cocos2dx_LayerGradient_initWithColor));
    cls->defineFunction("getEndColor", _SE(js_cocos2dx_LayerGradient_getEndColor));
    cls->defineFunction("getEndOpacity", _SE(js_cocos2dx_LayerGradient_getEndOpacity));
    cls->defineFunction("setStartColor", _SE(js_cocos2dx_LayerGradient_setStartColor));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerGradient_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_LayerGradient_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_LayerGradient_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerGradient>(cls);

    __jsb_cocos2d_LayerGradient_proto = cls->getProto();
    __jsb_cocos2d_LayerGradient_class = cls;

    jsb_set_extend_property("cc", "LayerGradient");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_LayerMultiplex_proto = nullptr;
se::Class* __jsb_cocos2d_LayerMultiplex_class = nullptr;

static bool js_cocos2dx_LayerMultiplex_initWithArray(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_initWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::Layer *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_initWithArray : Error processing arguments");
        bool result = cobj->initWithArray(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_initWithArray : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_initWithArray)

static bool js_cocos2dx_LayerMultiplex_switchToAndReleaseMe(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_switchToAndReleaseMe : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_switchToAndReleaseMe : Error processing arguments");
        cobj->switchToAndReleaseMe(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_switchToAndReleaseMe)

static bool js_cocos2dx_LayerMultiplex_addLayer(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_addLayer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Layer* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_addLayer : Error processing arguments");
        cobj->addLayer(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_addLayer)

static bool js_cocos2dx_LayerMultiplex_switchTo(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_LayerMultiplex_switchTo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_LayerMultiplex_switchTo : Error processing arguments");
        cobj->switchTo(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_LayerMultiplex_switchTo)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_LayerMultiplex_finalize)

static bool js_cocos2dx_LayerMultiplex_constructor(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = new (std::nothrow) cocos2d::LayerMultiplex();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_LayerMultiplex_constructor, __jsb_cocos2d_LayerMultiplex_class, js_cocos2d_LayerMultiplex_finalize)

static bool js_cocos2dx_LayerMultiplex_ctor(se::State& s)
{
    cocos2d::LayerMultiplex* cobj = new (std::nothrow) cocos2d::LayerMultiplex();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_LayerMultiplex_ctor, __jsb_cocos2d_LayerMultiplex_class, js_cocos2d_LayerMultiplex_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

static bool js_cocos2d_LayerMultiplex_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::LayerMultiplex)", s.nativeThisObject());
    cocos2d::LayerMultiplex* cobj = (cocos2d::LayerMultiplex*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_LayerMultiplex_finalize)

bool js_register_cocos2dx_LayerMultiplex(se::Object* obj)
{
    auto cls = se::Class::create("LayerMultiplex", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_LayerMultiplex_constructor));

    cls->defineFunction("initWithArray", _SE(js_cocos2dx_LayerMultiplex_initWithArray));
    cls->defineFunction("switchToAndReleaseMe", _SE(js_cocos2dx_LayerMultiplex_switchToAndReleaseMe));
    cls->defineFunction("addLayer", _SE(js_cocos2dx_LayerMultiplex_addLayer));
    cls->defineFunction("switchTo", _SE(js_cocos2dx_LayerMultiplex_switchTo));
    cls->defineFunction("ctor", _SE(js_cocos2dx_LayerMultiplex_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_LayerMultiplex_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::LayerMultiplex>(cls);

    __jsb_cocos2d_LayerMultiplex_proto = cls->getProto();
    __jsb_cocos2d_LayerMultiplex_class = cls;

    jsb_set_extend_property("cc", "LayerMultiplex");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItem_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItem_class = nullptr;

static bool js_cocos2dx_MenuItem_setEnabled(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_setEnabled)

static bool js_cocos2dx_MenuItem_activate(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_activate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->activate();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_activate)

static bool js_cocos2dx_MenuItem_initWithCallback(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_initWithCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Ref *)> arg0;
        do {
            if (args[0].isObject() && args[0].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[0]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg0 = lambda;
            }
            else
            {
                arg0 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_initWithCallback : Error processing arguments");
        bool result = cobj->initWithCallback(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_initWithCallback : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_initWithCallback)

static bool js_cocos2dx_MenuItem_isEnabled(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_isEnabled)

static bool js_cocos2dx_MenuItem_selected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_selected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->selected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_selected)

static bool js_cocos2dx_MenuItem_isSelected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_isSelected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSelected();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_isSelected : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_isSelected)

static bool js_cocos2dx_MenuItem_setCallback(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_setCallback : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::function<void (cocos2d::Ref *)> arg0;
        do {
            if (args[0].isObject() && args[0].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[0]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg0 = lambda;
            }
            else
            {
                arg0 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_setCallback : Error processing arguments");
        cobj->setCallback(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_setCallback)

static bool js_cocos2dx_MenuItem_unselected(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_unselected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unselected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_unselected)

static bool js_cocos2dx_MenuItem_rect(se::State& s)
{
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItem_rect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Rect result = cobj->rect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItem_rect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItem_rect)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItem_finalize)

static bool js_cocos2dx_MenuItem_constructor(se::State& s)
{
    cocos2d::MenuItem* cobj = new (std::nothrow) cocos2d::MenuItem();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItem_constructor, __jsb_cocos2d_MenuItem_class, js_cocos2d_MenuItem_finalize)

static bool js_cocos2dx_MenuItem_ctor(se::State& s)
{
    cocos2d::MenuItem* cobj = new (std::nothrow) cocos2d::MenuItem();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItem_ctor, __jsb_cocos2d_MenuItem_class, js_cocos2d_MenuItem_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_MenuItem_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItem)", s.nativeThisObject());
    cocos2d::MenuItem* cobj = (cocos2d::MenuItem*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItem_finalize)

bool js_register_cocos2dx_MenuItem(se::Object* obj)
{
    auto cls = se::Class::create("MenuItem", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_MenuItem_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_MenuItem_setEnabled));
    cls->defineFunction("activate", _SE(js_cocos2dx_MenuItem_activate));
    cls->defineFunction("initWithCallback", _SE(js_cocos2dx_MenuItem_initWithCallback));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_MenuItem_isEnabled));
    cls->defineFunction("selected", _SE(js_cocos2dx_MenuItem_selected));
    cls->defineFunction("isSelected", _SE(js_cocos2dx_MenuItem_isSelected));
    cls->defineFunction("setCallback", _SE(js_cocos2dx_MenuItem_setCallback));
    cls->defineFunction("unselected", _SE(js_cocos2dx_MenuItem_unselected));
    cls->defineFunction("rect", _SE(js_cocos2dx_MenuItem_rect));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItem_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItem_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItem>(cls);

    __jsb_cocos2d_MenuItem_proto = cls->getProto();
    __jsb_cocos2d_MenuItem_class = cls;

    jsb_set_extend_property("cc", "MenuItem");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemLabel_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemLabel_class = nullptr;

static bool js_cocos2dx_MenuItemLabel_setLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setLabel : Error processing arguments");
        cobj->setLabel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setLabel)

static bool js_cocos2dx_MenuItemLabel_getString(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getString();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getString)

static bool js_cocos2dx_MenuItemLabel_getDisabledColor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getDisabledColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color3B& result = cobj->getDisabledColor();
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getDisabledColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getDisabledColor)

static bool js_cocos2dx_MenuItemLabel_setString(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setString : Error processing arguments");
        cobj->setString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setString)

static bool js_cocos2dx_MenuItemLabel_initWithLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        std::function<void (cocos2d::Ref *)> arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Error processing arguments");
        bool result = cobj->initWithLabel(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_initWithLabel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_initWithLabel)

static bool js_cocos2dx_MenuItemLabel_setDisabledColor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_setDisabledColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_setDisabledColor : Error processing arguments");
        cobj->setDisabledColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_setDisabledColor)

static bool js_cocos2dx_MenuItemLabel_getLabel(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemLabel_getLabel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getLabel();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemLabel_getLabel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemLabel_getLabel)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemLabel_finalize)

static bool js_cocos2dx_MenuItemLabel_constructor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = new (std::nothrow) cocos2d::MenuItemLabel();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemLabel_constructor, __jsb_cocos2d_MenuItemLabel_class, js_cocos2d_MenuItemLabel_finalize)

static bool js_cocos2dx_MenuItemLabel_ctor(se::State& s)
{
    cocos2d::MenuItemLabel* cobj = new (std::nothrow) cocos2d::MenuItemLabel();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemLabel_ctor, __jsb_cocos2d_MenuItemLabel_class, js_cocos2d_MenuItemLabel_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

static bool js_cocos2d_MenuItemLabel_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemLabel)", s.nativeThisObject());
    cocos2d::MenuItemLabel* cobj = (cocos2d::MenuItemLabel*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemLabel_finalize)

bool js_register_cocos2dx_MenuItemLabel(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemLabel", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemLabel_constructor));

    cls->defineFunction("setLabel", _SE(js_cocos2dx_MenuItemLabel_setLabel));
    cls->defineFunction("getString", _SE(js_cocos2dx_MenuItemLabel_getString));
    cls->defineFunction("getDisabledColor", _SE(js_cocos2dx_MenuItemLabel_getDisabledColor));
    cls->defineFunction("setString", _SE(js_cocos2dx_MenuItemLabel_setString));
    cls->defineFunction("initWithLabel", _SE(js_cocos2dx_MenuItemLabel_initWithLabel));
    cls->defineFunction("setDisabledColor", _SE(js_cocos2dx_MenuItemLabel_setDisabledColor));
    cls->defineFunction("getLabel", _SE(js_cocos2dx_MenuItemLabel_getLabel));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemLabel_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemLabel_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemLabel>(cls);

    __jsb_cocos2d_MenuItemLabel_proto = cls->getProto();
    __jsb_cocos2d_MenuItemLabel_class = cls;

    jsb_set_extend_property("cc", "MenuItemLabel");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemAtlasFont_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemAtlasFont_class = nullptr;

static bool js_cocos2dx_MenuItemAtlasFont_initWithString(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = (cocos2d::MenuItemAtlasFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 6) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        int8_t arg4;
        std::function<void (cocos2d::Ref *)> arg5;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        ok &= seval_to_int8(args[4], (int8_t*)&arg4);
        do {
            if (args[5].isObject() && args[5].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[5]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg5 = lambda;
            }
            else
            {
                arg5 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1, arg2, arg3, arg4, arg5);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemAtlasFont_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 6);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemAtlasFont_initWithString)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemAtlasFont_finalize)

static bool js_cocos2dx_MenuItemAtlasFont_constructor(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = new (std::nothrow) cocos2d::MenuItemAtlasFont();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemAtlasFont_constructor, __jsb_cocos2d_MenuItemAtlasFont_class, js_cocos2d_MenuItemAtlasFont_finalize)

static bool js_cocos2dx_MenuItemAtlasFont_ctor(se::State& s)
{
    cocos2d::MenuItemAtlasFont* cobj = new (std::nothrow) cocos2d::MenuItemAtlasFont();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemAtlasFont_ctor, __jsb_cocos2d_MenuItemAtlasFont_class, js_cocos2d_MenuItemAtlasFont_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemLabel_proto;

static bool js_cocos2d_MenuItemAtlasFont_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemAtlasFont)", s.nativeThisObject());
    cocos2d::MenuItemAtlasFont* cobj = (cocos2d::MenuItemAtlasFont*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemAtlasFont_finalize)

bool js_register_cocos2dx_MenuItemAtlasFont(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemAtlasFont", obj, __jsb_cocos2d_MenuItemLabel_proto, _SE(js_cocos2dx_MenuItemAtlasFont_constructor));

    cls->defineFunction("initWithString", _SE(js_cocos2dx_MenuItemAtlasFont_initWithString));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemAtlasFont_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemAtlasFont_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemAtlasFont>(cls);

    __jsb_cocos2d_MenuItemAtlasFont_proto = cls->getProto();
    __jsb_cocos2d_MenuItemAtlasFont_class = cls;

    jsb_set_extend_property("cc", "MenuItemAtlasFont");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemFont_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemFont_class = nullptr;

static bool js_cocos2dx_MenuItemFont_setFontNameObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_setFontNameObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontNameObj : Error processing arguments");
        cobj->setFontNameObj(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontNameObj)

static bool js_cocos2dx_MenuItemFont_getFontSizeObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_getFontSizeObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getFontSizeObj();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontSizeObj : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontSizeObj)

static bool js_cocos2dx_MenuItemFont_setFontSizeObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_setFontSizeObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontSizeObj : Error processing arguments");
        cobj->setFontSizeObj(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontSizeObj)

static bool js_cocos2dx_MenuItemFont_initWithString(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_initWithString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::Ref *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_initWithString : Error processing arguments");
        bool result = cobj->initWithString(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_initWithString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_initWithString)

static bool js_cocos2dx_MenuItemFont_getFontNameObj(se::State& s)
{
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemFont_getFontNameObj : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getFontNameObj();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontNameObj : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontNameObj)

static bool js_cocos2dx_MenuItemFont_setFontName(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontName : Error processing arguments");
        cocos2d::MenuItemFont::setFontName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontName)

static bool js_cocos2dx_MenuItemFont_getFontSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cocos2d::MenuItemFont::getFontSize();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontSize)

static bool js_cocos2dx_MenuItemFont_getFontName(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cocos2d::MenuItemFont::getFontName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_getFontName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_getFontName)

static bool js_cocos2dx_MenuItemFont_setFontSize(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemFont_setFontSize : Error processing arguments");
        cocos2d::MenuItemFont::setFontSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemFont_setFontSize)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemFont_finalize)

static bool js_cocos2dx_MenuItemFont_constructor(se::State& s)
{
    cocos2d::MenuItemFont* cobj = new (std::nothrow) cocos2d::MenuItemFont();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemFont_constructor, __jsb_cocos2d_MenuItemFont_class, js_cocos2d_MenuItemFont_finalize)

static bool js_cocos2dx_MenuItemFont_ctor(se::State& s)
{
    cocos2d::MenuItemFont* cobj = new (std::nothrow) cocos2d::MenuItemFont();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemFont_ctor, __jsb_cocos2d_MenuItemFont_class, js_cocos2d_MenuItemFont_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemLabel_proto;

static bool js_cocos2d_MenuItemFont_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemFont)", s.nativeThisObject());
    cocos2d::MenuItemFont* cobj = (cocos2d::MenuItemFont*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemFont_finalize)

bool js_register_cocos2dx_MenuItemFont(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemFont", obj, __jsb_cocos2d_MenuItemLabel_proto, _SE(js_cocos2dx_MenuItemFont_constructor));

    cls->defineFunction("setFontName", _SE(js_cocos2dx_MenuItemFont_setFontNameObj));
    cls->defineFunction("getFontSize", _SE(js_cocos2dx_MenuItemFont_getFontSizeObj));
    cls->defineFunction("setFontSize", _SE(js_cocos2dx_MenuItemFont_setFontSizeObj));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_MenuItemFont_initWithString));
    cls->defineFunction("getFontName", _SE(js_cocos2dx_MenuItemFont_getFontNameObj));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemFont_ctor));
    cls->defineStaticFunction("setFontName", _SE(js_cocos2dx_MenuItemFont_setFontName));
    cls->defineStaticFunction("getFontSize", _SE(js_cocos2dx_MenuItemFont_getFontSize));
    cls->defineStaticFunction("getFontName", _SE(js_cocos2dx_MenuItemFont_getFontName));
    cls->defineStaticFunction("setFontSize", _SE(js_cocos2dx_MenuItemFont_setFontSize));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemFont_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemFont>(cls);

    __jsb_cocos2d_MenuItemFont_proto = cls->getProto();
    __jsb_cocos2d_MenuItemFont_class = cls;

    jsb_set_extend_property("cc", "MenuItemFont");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemSprite_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemSprite_class = nullptr;

static bool js_cocos2dx_MenuItemSprite_setEnabled(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setEnabled)

static bool js_cocos2dx_MenuItemSprite_selected(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_selected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->selected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_selected)

static bool js_cocos2dx_MenuItemSprite_setNormalImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setNormalImage : Error processing arguments");
        cobj->setNormalImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setNormalImage)

static bool js_cocos2dx_MenuItemSprite_setDisabledImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setDisabledImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setDisabledImage : Error processing arguments");
        cobj->setDisabledImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setDisabledImage)

static bool js_cocos2dx_MenuItemSprite_initWithNormalSprite(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        cocos2d::Node* arg0 = nullptr;
        cocos2d::Node* arg1 = nullptr;
        cocos2d::Node* arg2 = nullptr;
        std::function<void (cocos2d::Ref *)> arg3;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        do {
            if (args[3].isObject() && args[3].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[3]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg3 = lambda;
            }
            else
            {
                arg3 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Error processing arguments");
        bool result = cobj->initWithNormalSprite(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_initWithNormalSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_initWithNormalSprite)

static bool js_cocos2dx_MenuItemSprite_setSelectedImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_setSelectedImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_setSelectedImage : Error processing arguments");
        cobj->setSelectedImage(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_setSelectedImage)

static bool js_cocos2dx_MenuItemSprite_getDisabledImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getDisabledImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getDisabledImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getDisabledImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getDisabledImage)

static bool js_cocos2dx_MenuItemSprite_getSelectedImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getSelectedImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getSelectedImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getSelectedImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getSelectedImage)

static bool js_cocos2dx_MenuItemSprite_getNormalImage(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_getNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNormalImage();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemSprite_getNormalImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_getNormalImage)

static bool js_cocos2dx_MenuItemSprite_unselected(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemSprite_unselected : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unselected();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemSprite_unselected)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemSprite_finalize)

static bool js_cocos2dx_MenuItemSprite_constructor(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = new (std::nothrow) cocos2d::MenuItemSprite();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemSprite_constructor, __jsb_cocos2d_MenuItemSprite_class, js_cocos2d_MenuItemSprite_finalize)

static bool js_cocos2dx_MenuItemSprite_ctor(se::State& s)
{
    cocos2d::MenuItemSprite* cobj = new (std::nothrow) cocos2d::MenuItemSprite();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemSprite_ctor, __jsb_cocos2d_MenuItemSprite_class, js_cocos2d_MenuItemSprite_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

static bool js_cocos2d_MenuItemSprite_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemSprite)", s.nativeThisObject());
    cocos2d::MenuItemSprite* cobj = (cocos2d::MenuItemSprite*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemSprite_finalize)

bool js_register_cocos2dx_MenuItemSprite(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemSprite", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemSprite_constructor));

    cls->defineFunction("setEnabled", _SE(js_cocos2dx_MenuItemSprite_setEnabled));
    cls->defineFunction("selected", _SE(js_cocos2dx_MenuItemSprite_selected));
    cls->defineFunction("setNormalImage", _SE(js_cocos2dx_MenuItemSprite_setNormalImage));
    cls->defineFunction("setDisabledImage", _SE(js_cocos2dx_MenuItemSprite_setDisabledImage));
    cls->defineFunction("initWithNormalSprite", _SE(js_cocos2dx_MenuItemSprite_initWithNormalSprite));
    cls->defineFunction("setSelectedImage", _SE(js_cocos2dx_MenuItemSprite_setSelectedImage));
    cls->defineFunction("getDisabledImage", _SE(js_cocos2dx_MenuItemSprite_getDisabledImage));
    cls->defineFunction("getSelectedImage", _SE(js_cocos2dx_MenuItemSprite_getSelectedImage));
    cls->defineFunction("getNormalImage", _SE(js_cocos2dx_MenuItemSprite_getNormalImage));
    cls->defineFunction("unselected", _SE(js_cocos2dx_MenuItemSprite_unselected));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemSprite_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemSprite_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemSprite>(cls);

    __jsb_cocos2d_MenuItemSprite_proto = cls->getProto();
    __jsb_cocos2d_MenuItemSprite_class = cls;

    jsb_set_extend_property("cc", "MenuItemSprite");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemImage_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemImage_class = nullptr;

static bool js_cocos2dx_MenuItemImage_setDisabledSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setDisabledSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setDisabledSpriteFrame : Error processing arguments");
        cobj->setDisabledSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setDisabledSpriteFrame)

static bool js_cocos2dx_MenuItemImage_setSelectedSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setSelectedSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setSelectedSpriteFrame : Error processing arguments");
        cobj->setSelectedSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setSelectedSpriteFrame)

static bool js_cocos2dx_MenuItemImage_setNormalSpriteFrame(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_setNormalSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_setNormalSpriteFrame : Error processing arguments");
        cobj->setNormalSpriteFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_setNormalSpriteFrame)

static bool js_cocos2dx_MenuItemImage_init(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_init)

static bool js_cocos2dx_MenuItemImage_initWithNormalImage(se::State& s)
{
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        std::string arg2;
        std::function<void (cocos2d::Ref *)> arg3;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_std_string(args[2], &arg2);
        do {
            if (args[3].isObject() && args[3].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[3]);
                jsThis.toObject()->attachObject(jsFunc.toObject());
                auto lambda = [=](cocos2d::Ref* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Ref>((cocos2d::Ref*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg3 = lambda;
            }
            else
            {
                arg3 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Error processing arguments");
        bool result = cobj->initWithNormalImage(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemImage_initWithNormalImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemImage_initWithNormalImage)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemImage_finalize)

static bool js_cocos2dx_MenuItemImage_constructor(se::State& s)
{
    cocos2d::MenuItemImage* cobj = new (std::nothrow) cocos2d::MenuItemImage();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemImage_constructor, __jsb_cocos2d_MenuItemImage_class, js_cocos2d_MenuItemImage_finalize)

static bool js_cocos2dx_MenuItemImage_ctor(se::State& s)
{
    cocos2d::MenuItemImage* cobj = new (std::nothrow) cocos2d::MenuItemImage();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemImage_ctor, __jsb_cocos2d_MenuItemImage_class, js_cocos2d_MenuItemImage_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItemSprite_proto;

static bool js_cocos2d_MenuItemImage_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemImage)", s.nativeThisObject());
    cocos2d::MenuItemImage* cobj = (cocos2d::MenuItemImage*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemImage_finalize)

bool js_register_cocos2dx_MenuItemImage(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemImage", obj, __jsb_cocos2d_MenuItemSprite_proto, _SE(js_cocos2dx_MenuItemImage_constructor));

    cls->defineFunction("setDisabledSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setDisabledSpriteFrame));
    cls->defineFunction("setSelectedSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setSelectedSpriteFrame));
    cls->defineFunction("setNormalSpriteFrame", _SE(js_cocos2dx_MenuItemImage_setNormalSpriteFrame));
    cls->defineFunction("init", _SE(js_cocos2dx_MenuItemImage_init));
    cls->defineFunction("initWithNormalImage", _SE(js_cocos2dx_MenuItemImage_initWithNormalImage));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemImage_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemImage_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemImage>(cls);

    __jsb_cocos2d_MenuItemImage_proto = cls->getProto();
    __jsb_cocos2d_MenuItemImage_class = cls;

    jsb_set_extend_property("cc", "MenuItemImage");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MenuItemToggle_proto = nullptr;
se::Class* __jsb_cocos2d_MenuItemToggle_class = nullptr;

static bool js_cocos2dx_MenuItemToggle_setSubItems(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_setSubItems : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::MenuItem *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_setSubItems : Error processing arguments");
        cobj->setSubItems(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_setSubItems)

static bool js_cocos2dx_MenuItemToggle_initWithItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_initWithItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MenuItem* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_initWithItem : Error processing arguments");
        bool result = cobj->initWithItem(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_initWithItem : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_initWithItem)

static bool js_cocos2dx_MenuItemToggle_getSubItems(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_MenuItemToggle_getSubItems : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::MenuItem *>& result = cobj->getSubItems();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSubItems : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::MenuItem *>& result = cobj->getSubItems();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSubItems : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_getSubItems)

static bool js_cocos2dx_MenuItemToggle_getSelectedIndex(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_getSelectedIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getSelectedIndex();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSelectedIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_getSelectedIndex)

static bool js_cocos2dx_MenuItemToggle_addSubItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_addSubItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::MenuItem* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_addSubItem : Error processing arguments");
        cobj->addSubItem(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_addSubItem)

static bool js_cocos2dx_MenuItemToggle_getSelectedItem(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_getSelectedItem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::MenuItem* result = cobj->getSelectedItem();
        ok &= native_ptr_to_seval<cocos2d::MenuItem>((cocos2d::MenuItem*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_getSelectedItem : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_getSelectedItem)

static bool js_cocos2dx_MenuItemToggle_setSelectedIndex(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MenuItemToggle_setSelectedIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MenuItemToggle_setSelectedIndex : Error processing arguments");
        cobj->setSelectedIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MenuItemToggle_setSelectedIndex)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MenuItemToggle_finalize)

static bool js_cocos2dx_MenuItemToggle_constructor(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = new (std::nothrow) cocos2d::MenuItemToggle();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MenuItemToggle_constructor, __jsb_cocos2d_MenuItemToggle_class, js_cocos2d_MenuItemToggle_finalize)

static bool js_cocos2dx_MenuItemToggle_ctor(se::State& s)
{
    cocos2d::MenuItemToggle* cobj = new (std::nothrow) cocos2d::MenuItemToggle();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MenuItemToggle_ctor, __jsb_cocos2d_MenuItemToggle_class, js_cocos2d_MenuItemToggle_finalize)


    

extern se::Object* __jsb_cocos2d_MenuItem_proto;

static bool js_cocos2d_MenuItemToggle_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MenuItemToggle)", s.nativeThisObject());
    cocos2d::MenuItemToggle* cobj = (cocos2d::MenuItemToggle*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MenuItemToggle_finalize)

bool js_register_cocos2dx_MenuItemToggle(se::Object* obj)
{
    auto cls = se::Class::create("MenuItemToggle", obj, __jsb_cocos2d_MenuItem_proto, _SE(js_cocos2dx_MenuItemToggle_constructor));

    cls->defineFunction("setSubItems", _SE(js_cocos2dx_MenuItemToggle_setSubItems));
    cls->defineFunction("initWithItem", _SE(js_cocos2dx_MenuItemToggle_initWithItem));
    cls->defineFunction("getSubItems", _SE(js_cocos2dx_MenuItemToggle_getSubItems));
    cls->defineFunction("getSelectedIndex", _SE(js_cocos2dx_MenuItemToggle_getSelectedIndex));
    cls->defineFunction("addSubItem", _SE(js_cocos2dx_MenuItemToggle_addSubItem));
    cls->defineFunction("getSelectedItem", _SE(js_cocos2dx_MenuItemToggle_getSelectedItem));
    cls->defineFunction("setSelectedIndex", _SE(js_cocos2dx_MenuItemToggle_setSelectedIndex));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MenuItemToggle_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MenuItemToggle_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MenuItemToggle>(cls);

    __jsb_cocos2d_MenuItemToggle_proto = cls->getProto();
    __jsb_cocos2d_MenuItemToggle_class = cls;

    jsb_set_extend_property("cc", "MenuItemToggle");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Menu_proto = nullptr;
se::Class* __jsb_cocos2d_Menu_class = nullptr;

static bool js_cocos2dx_Menu_initWithArray(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_initWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::MenuItem *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_initWithArray : Error processing arguments");
        bool result = cobj->initWithArray(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_initWithArray : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_initWithArray)

static bool js_cocos2dx_Menu_setEnabled(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_setEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_setEnabled : Error processing arguments");
        cobj->setEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_setEnabled)

static bool js_cocos2dx_Menu_alignItemsVertically(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsVertically : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->alignItemsVertically();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsVertically)

static bool js_cocos2dx_Menu_isEnabled(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_isEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isEnabled();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_isEnabled : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_isEnabled)

static bool js_cocos2dx_Menu_alignItemsHorizontally(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsHorizontally : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->alignItemsHorizontally();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsHorizontally)

static bool js_cocos2dx_Menu_alignItemsHorizontallyWithPadding(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsHorizontallyWithPadding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsHorizontallyWithPadding : Error processing arguments");
        cobj->alignItemsHorizontallyWithPadding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsHorizontallyWithPadding)

static bool js_cocos2dx_Menu_alignItemsVerticallyWithPadding(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsVerticallyWithPadding : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsVerticallyWithPadding : Error processing arguments");
        cobj->alignItemsVerticallyWithPadding(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsVerticallyWithPadding)

static bool js_cocos2dx_Menu_alignItemsInRowsWithArray(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsInRowsWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueVector arg0;
        ok &= seval_to_ccvaluevector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsInRowsWithArray : Error processing arguments");
        cobj->alignItemsInRowsWithArray(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsInRowsWithArray)

static bool js_cocos2dx_Menu_alignItemsInColumnsWithArray(se::State& s)
{
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Menu_alignItemsInColumnsWithArray : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueVector arg0;
        ok &= seval_to_ccvaluevector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Menu_alignItemsInColumnsWithArray : Error processing arguments");
        cobj->alignItemsInColumnsWithArray(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Menu_alignItemsInColumnsWithArray)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Menu_finalize)

static bool js_cocos2dx_Menu_constructor(se::State& s)
{
    cocos2d::Menu* cobj = new (std::nothrow) cocos2d::Menu();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Menu_constructor, __jsb_cocos2d_Menu_class, js_cocos2d_Menu_finalize)

static bool js_cocos2dx_Menu_ctor(se::State& s)
{
    cocos2d::Menu* cobj = new (std::nothrow) cocos2d::Menu();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Menu_ctor, __jsb_cocos2d_Menu_class, js_cocos2d_Menu_finalize)


    

extern se::Object* __jsb_cocos2d_Layer_proto;

static bool js_cocos2d_Menu_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Menu)", s.nativeThisObject());
    cocos2d::Menu* cobj = (cocos2d::Menu*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Menu_finalize)

bool js_register_cocos2dx_Menu(se::Object* obj)
{
    auto cls = se::Class::create("Menu", obj, __jsb_cocos2d_Layer_proto, _SE(js_cocos2dx_Menu_constructor));

    cls->defineFunction("initWithArray", _SE(js_cocos2dx_Menu_initWithArray));
    cls->defineFunction("setEnabled", _SE(js_cocos2dx_Menu_setEnabled));
    cls->defineFunction("alignItemsVertically", _SE(js_cocos2dx_Menu_alignItemsVertically));
    cls->defineFunction("isEnabled", _SE(js_cocos2dx_Menu_isEnabled));
    cls->defineFunction("alignItemsHorizontally", _SE(js_cocos2dx_Menu_alignItemsHorizontally));
    cls->defineFunction("alignItemsHorizontallyWithPadding", _SE(js_cocos2dx_Menu_alignItemsHorizontallyWithPadding));
    cls->defineFunction("alignItemsVerticallyWithPadding", _SE(js_cocos2dx_Menu_alignItemsVerticallyWithPadding));
    cls->defineFunction("alignItemsInRows", _SE(js_cocos2dx_Menu_alignItemsInRowsWithArray));
    cls->defineFunction("alignItemsInColumns", _SE(js_cocos2dx_Menu_alignItemsInColumnsWithArray));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Menu_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Menu_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Menu>(cls);

    __jsb_cocos2d_Menu_proto = cls->getProto();
    __jsb_cocos2d_Menu_class = cls;

    jsb_set_extend_property("cc", "Menu");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_MotionStreak_proto = nullptr;
se::Class* __jsb_cocos2d_MotionStreak_class = nullptr;

static bool js_cocos2dx_MotionStreak_reset(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_reset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reset();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_reset)

static bool js_cocos2dx_MotionStreak_setTexture(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setTexture)

static bool js_cocos2dx_MotionStreak_setMinSeg(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setMinSeg : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setMinSeg : Error processing arguments");
        cobj->setMinSeg(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setMinSeg)

static bool js_cocos2dx_MotionStreak_getTexture(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getTexture)

static bool js_cocos2dx_MotionStreak_tintWithColor(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_tintWithColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color3B arg0;
        ok &= seval_to_Color3B(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_tintWithColor : Error processing arguments");
        cobj->tintWithColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_tintWithColor)

static bool js_cocos2dx_MotionStreak_getMinSeg(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getMinSeg : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getMinSeg();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getMinSeg : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getMinSeg)

static bool js_cocos2dx_MotionStreak_setBlendFunc(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setBlendFunc)

static bool js_cocos2dx_MotionStreak_setFadeTime(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setFadeTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setFadeTime : Error processing arguments");
        cobj->setFadeTime(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setFadeTime)

static bool js_cocos2dx_MotionStreak_setStartingPositionInitialized(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setStartingPositionInitialized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setStartingPositionInitialized : Error processing arguments");
        cobj->setStartingPositionInitialized(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setStartingPositionInitialized)

static bool js_cocos2dx_MotionStreak_getFadeTime(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getFadeTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getFadeTime();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getFadeTime : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getFadeTime)

static bool js_cocos2dx_MotionStreak_getBlendFunc(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getBlendFunc)

static bool js_cocos2dx_MotionStreak_isStartingPositionInitialized(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_isStartingPositionInitialized : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStartingPositionInitialized();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_isStartingPositionInitialized : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_isStartingPositionInitialized)

static bool js_cocos2dx_MotionStreak_isFastMode(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_isFastMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFastMode();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_isFastMode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_isFastMode)

static bool js_cocos2dx_MotionStreak_getStroke(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_getStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStroke();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_getStroke : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_getStroke)

static bool js_cocos2dx_MotionStreak_initWithFade(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_MotionStreak_initWithFade : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg4 = nullptr;
            ok &= seval_to_native_ptr(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_initWithFade : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            std::string arg4;
            ok &= seval_to_std_string(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFade(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_initWithFade : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_initWithFade)

static bool js_cocos2dx_MotionStreak_setFastMode(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setFastMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setFastMode : Error processing arguments");
        cobj->setFastMode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setFastMode)

static bool js_cocos2dx_MotionStreak_setStroke(se::State& s)
{
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_MotionStreak_setStroke : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_setStroke : Error processing arguments");
        cobj->setStroke(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_setStroke)

static bool js_cocos2dx_MotionStreak_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg4 = nullptr;
            ok &= seval_to_native_ptr(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::MotionStreak* result = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::MotionStreak>((cocos2d::MotionStreak*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Color3B arg3;
            ok &= seval_to_Color3B(args[3], &arg3);
            if (!ok) { ok = true; break; }
            std::string arg4;
            ok &= seval_to_std_string(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::MotionStreak* result = cocos2d::MotionStreak::create(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::MotionStreak>((cocos2d::MotionStreak*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_MotionStreak_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_MotionStreak_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_MotionStreak_finalize)

static bool js_cocos2dx_MotionStreak_constructor(se::State& s)
{
    cocos2d::MotionStreak* cobj = new (std::nothrow) cocos2d::MotionStreak();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_MotionStreak_constructor, __jsb_cocos2d_MotionStreak_class, js_cocos2d_MotionStreak_finalize)

static bool js_cocos2dx_MotionStreak_ctor(se::State& s)
{
    cocos2d::MotionStreak* cobj = new (std::nothrow) cocos2d::MotionStreak();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_MotionStreak_ctor, __jsb_cocos2d_MotionStreak_class, js_cocos2d_MotionStreak_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_MotionStreak_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::MotionStreak)", s.nativeThisObject());
    cocos2d::MotionStreak* cobj = (cocos2d::MotionStreak*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_MotionStreak_finalize)

bool js_register_cocos2dx_MotionStreak(se::Object* obj)
{
    auto cls = se::Class::create("MotionStreak", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_MotionStreak_constructor));

    cls->defineFunction("reset", _SE(js_cocos2dx_MotionStreak_reset));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_MotionStreak_setTexture));
    cls->defineFunction("setMinSeg", _SE(js_cocos2dx_MotionStreak_setMinSeg));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_MotionStreak_getTexture));
    cls->defineFunction("tintWithColor", _SE(js_cocos2dx_MotionStreak_tintWithColor));
    cls->defineFunction("getMinSeg", _SE(js_cocos2dx_MotionStreak_getMinSeg));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_MotionStreak_setBlendFunc));
    cls->defineFunction("setFadeTime", _SE(js_cocos2dx_MotionStreak_setFadeTime));
    cls->defineFunction("setStartingPositionInitialized", _SE(js_cocos2dx_MotionStreak_setStartingPositionInitialized));
    cls->defineFunction("getFadeTime", _SE(js_cocos2dx_MotionStreak_getFadeTime));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_MotionStreak_getBlendFunc));
    cls->defineFunction("isStartingPositionInitialized", _SE(js_cocos2dx_MotionStreak_isStartingPositionInitialized));
    cls->defineFunction("isFastMode", _SE(js_cocos2dx_MotionStreak_isFastMode));
    cls->defineFunction("getStroke", _SE(js_cocos2dx_MotionStreak_getStroke));
    cls->defineFunction("initWithFade", _SE(js_cocos2dx_MotionStreak_initWithFade));
    cls->defineFunction("setFastMode", _SE(js_cocos2dx_MotionStreak_setFastMode));
    cls->defineFunction("setStroke", _SE(js_cocos2dx_MotionStreak_setStroke));
    cls->defineFunction("ctor", _SE(js_cocos2dx_MotionStreak_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_MotionStreak_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_MotionStreak_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::MotionStreak>(cls);

    __jsb_cocos2d_MotionStreak_proto = cls->getProto();
    __jsb_cocos2d_MotionStreak_class = cls;

    jsb_set_extend_property("cc", "MotionStreak");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleBatchNode_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleBatchNode_class = nullptr;

static bool js_cocos2dx_ParticleBatchNode_setTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setTexture)

static bool js_cocos2dx_ParticleBatchNode_initWithTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_initWithTexture)

static bool js_cocos2dx_ParticleBatchNode_disableParticle(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_disableParticle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_disableParticle : Error processing arguments");
        cobj->disableParticle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_disableParticle)

static bool js_cocos2dx_ParticleBatchNode_getTexture(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_getTexture)

static bool js_cocos2dx_ParticleBatchNode_setTextureAtlas(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setTextureAtlas)

static bool js_cocos2dx_ParticleBatchNode_initWithFile(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_initWithFile)

static bool js_cocos2dx_ParticleBatchNode_setBlendFunc(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_setBlendFunc)

static bool js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup)

static bool js_cocos2dx_ParticleBatchNode_getBlendFunc(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_getBlendFunc)

static bool js_cocos2dx_ParticleBatchNode_insertChild(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_insertChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::ParticleSystem* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_insertChild : Error processing arguments");
        cobj->insertChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_insertChild)

static bool js_cocos2dx_ParticleBatchNode_removeChildAtIndex(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleBatchNode_removeChildAtIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_removeChildAtIndex : Error processing arguments");
        cobj->removeChildAtIndex(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_removeChildAtIndex)

static bool js_cocos2dx_ParticleBatchNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_create : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_create : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_create)

static bool js_cocos2dx_ParticleBatchNode_createWithTexture(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::createWithTexture(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::ParticleBatchNode::createWithTexture(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleBatchNode_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleBatchNode_finalize)

static bool js_cocos2dx_ParticleBatchNode_constructor(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = new (std::nothrow) cocos2d::ParticleBatchNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleBatchNode_constructor, __jsb_cocos2d_ParticleBatchNode_class, js_cocos2d_ParticleBatchNode_finalize)

static bool js_cocos2dx_ParticleBatchNode_ctor(se::State& s)
{
    cocos2d::ParticleBatchNode* cobj = new (std::nothrow) cocos2d::ParticleBatchNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParticleBatchNode_ctor, __jsb_cocos2d_ParticleBatchNode_class, js_cocos2d_ParticleBatchNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_ParticleBatchNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleBatchNode)", s.nativeThisObject());
    cocos2d::ParticleBatchNode* cobj = (cocos2d::ParticleBatchNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleBatchNode_finalize)

bool js_register_cocos2dx_ParticleBatchNode(se::Object* obj)
{
    auto cls = se::Class::create("ParticleBatchNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParticleBatchNode_constructor));

    cls->defineFunction("setTexture", _SE(js_cocos2dx_ParticleBatchNode_setTexture));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_ParticleBatchNode_initWithTexture));
    cls->defineFunction("disableParticle", _SE(js_cocos2dx_ParticleBatchNode_disableParticle));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_ParticleBatchNode_getTexture));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_ParticleBatchNode_setTextureAtlas));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_ParticleBatchNode_initWithFile));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_ParticleBatchNode_setBlendFunc));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_ParticleBatchNode_removeAllChildrenWithCleanup));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_ParticleBatchNode_getBlendFunc));
    cls->defineFunction("insertChild", _SE(js_cocos2dx_ParticleBatchNode_insertChild));
    cls->defineFunction("removeChildAtIndex", _SE(js_cocos2dx_ParticleBatchNode_removeChildAtIndex));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParticleBatchNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleBatchNode_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_ParticleBatchNode_createWithTexture));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleBatchNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleBatchNode>(cls);

    __jsb_cocos2d_ParticleBatchNode_proto = cls->getProto();
    __jsb_cocos2d_ParticleBatchNode_class = cls;

    jsb_set_extend_property("cc", "ParticleBatchNode");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSystem_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSystem_class = nullptr;

static bool js_cocos2dx_ParticleSystem_getStartSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSizeVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSizeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSizeVar)

static bool js_cocos2dx_ParticleSystem_getTexture(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTexture)

static bool js_cocos2dx_ParticleSystem_isFull(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isFull : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFull();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isFull : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isFull)

static bool js_cocos2dx_ParticleSystem_getBatchNode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ParticleBatchNode* result = cobj->getBatchNode();
        ok &= native_ptr_to_seval<cocos2d::ParticleBatchNode>((cocos2d::ParticleBatchNode*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getBatchNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getBatchNode)

static bool js_cocos2dx_ParticleSystem_getStartColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getStartColor();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartColor)

static bool js_cocos2dx_ParticleSystem_getPositionType(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getPositionType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getPositionType();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getPositionType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getPositionType)

static bool js_cocos2dx_ParticleSystem_setPosVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setPosVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setPosVar : Error processing arguments");
        cobj->setPosVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setPosVar)

static bool js_cocos2dx_ParticleSystem_getEndSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSpin();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSpin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSpin)

static bool js_cocos2dx_ParticleSystem_setRotatePerSecondVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotatePerSecondVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotatePerSecondVar : Error processing arguments");
        cobj->setRotatePerSecondVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotatePerSecondVar)

static bool js_cocos2dx_ParticleSystem_getStartSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSpinVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSpinVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSpinVar)

static bool js_cocos2dx_ParticleSystem_getRadialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRadialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRadialAccelVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRadialAccelVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRadialAccelVar)

static bool js_cocos2dx_ParticleSystem_getEndSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSizeVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSizeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSizeVar)

static bool js_cocos2dx_ParticleSystem_setTangentialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTangentialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTangentialAccel : Error processing arguments");
        cobj->setTangentialAccel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTangentialAccel)

static bool js_cocos2dx_ParticleSystem_getRadialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRadialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRadialAccel();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRadialAccel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRadialAccel)

static bool js_cocos2dx_ParticleSystem_setStartRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartRadius : Error processing arguments");
        cobj->setStartRadius(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartRadius)

static bool js_cocos2dx_ParticleSystem_setRotatePerSecond(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotatePerSecond : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotatePerSecond : Error processing arguments");
        cobj->setRotatePerSecond(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotatePerSecond)

static bool js_cocos2dx_ParticleSystem_setEndSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSize : Error processing arguments");
        cobj->setEndSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSize)

static bool js_cocos2dx_ParticleSystem_getGravity(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getGravity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getGravity();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getGravity : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getGravity)

static bool js_cocos2dx_ParticleSystem_resumeEmissions(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_resumeEmissions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resumeEmissions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_resumeEmissions)

static bool js_cocos2dx_ParticleSystem_getTangentialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTangentialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTangentialAccel();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTangentialAccel : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTangentialAccel)

static bool js_cocos2dx_ParticleSystem_setEndRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndRadius : Error processing arguments");
        cobj->setEndRadius(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndRadius)

static bool js_cocos2dx_ParticleSystem_getSpeed(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeed();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSpeed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSpeed)

static bool js_cocos2dx_ParticleSystem_pauseEmissions(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_pauseEmissions : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->pauseEmissions();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_pauseEmissions)

static bool js_cocos2dx_ParticleSystem_getAngle(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAngle();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAngle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAngle)

static bool js_cocos2dx_ParticleSystem_setEndColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndColor : Error processing arguments");
        cobj->setEndColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndColor)

static bool js_cocos2dx_ParticleSystem_setStartSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSpin : Error processing arguments");
        cobj->setStartSpin(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSpin)

static bool js_cocos2dx_ParticleSystem_setDuration(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setDuration : Error processing arguments");
        cobj->setDuration(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setDuration)

static bool js_cocos2dx_ParticleSystem_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithTotalParticles)

static bool js_cocos2dx_ParticleSystem_addParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_addParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_addParticles : Error processing arguments");
        cobj->addParticles(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_addParticles)

static bool js_cocos2dx_ParticleSystem_setTexture(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTexture)

static bool js_cocos2dx_ParticleSystem_getPosVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getPosVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPosVar();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getPosVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getPosVar)

static bool js_cocos2dx_ParticleSystem_updateWithNoTime(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_updateWithNoTime : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateWithNoTime();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_updateWithNoTime)

static bool js_cocos2dx_ParticleSystem_isBlendAdditive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isBlendAdditive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isBlendAdditive();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isBlendAdditive : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isBlendAdditive)

static bool js_cocos2dx_ParticleSystem_getSpeedVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSpeedVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getSpeedVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSpeedVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSpeedVar)

static bool js_cocos2dx_ParticleSystem_setPositionType(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setPositionType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleSystem::PositionType arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setPositionType : Error processing arguments");
        cobj->setPositionType(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setPositionType)

static bool js_cocos2dx_ParticleSystem_stopSystem(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_stopSystem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stopSystem();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_stopSystem)

static bool js_cocos2dx_ParticleSystem_getSourcePosition(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getSourcePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getSourcePosition();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getSourcePosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getSourcePosition)

static bool js_cocos2dx_ParticleSystem_setLifeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setLifeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setLifeVar : Error processing arguments");
        cobj->setLifeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setLifeVar)

static bool js_cocos2dx_ParticleSystem_setTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTotalParticles : Error processing arguments");
        cobj->setTotalParticles(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTotalParticles)

static bool js_cocos2dx_ParticleSystem_setEndColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndColorVar : Error processing arguments");
        cobj->setEndColorVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndColorVar)

static bool js_cocos2dx_ParticleSystem_getAtlasIndex(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getAtlasIndex();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAtlasIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAtlasIndex)

static bool js_cocos2dx_ParticleSystem_getStartSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSize();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSize)

static bool js_cocos2dx_ParticleSystem_setStartSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSpinVar : Error processing arguments");
        cobj->setStartSpinVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSpinVar)

static bool js_cocos2dx_ParticleSystem_resetSystem(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_resetSystem : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->resetSystem();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_resetSystem)

static bool js_cocos2dx_ParticleSystem_setAtlasIndex(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAtlasIndex : Error processing arguments");
        cobj->setAtlasIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAtlasIndex)

static bool js_cocos2dx_ParticleSystem_setTangentialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setTangentialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setTangentialAccelVar : Error processing arguments");
        cobj->setTangentialAccelVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setTangentialAccelVar)

static bool js_cocos2dx_ParticleSystem_setEndRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndRadiusVar : Error processing arguments");
        cobj->setEndRadiusVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndRadiusVar)

static bool js_cocos2dx_ParticleSystem_getEndRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndRadius();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndRadius)

static bool js_cocos2dx_ParticleSystem_isActive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isActive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isActive();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isActive : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isActive)

static bool js_cocos2dx_ParticleSystem_setRadialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRadialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRadialAccelVar : Error processing arguments");
        cobj->setRadialAccelVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRadialAccelVar)

static bool js_cocos2dx_ParticleSystem_setStartSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSize : Error processing arguments");
        cobj->setStartSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSize)

static bool js_cocos2dx_ParticleSystem_setSpeed(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSpeed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSpeed : Error processing arguments");
        cobj->setSpeed(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSpeed)

static bool js_cocos2dx_ParticleSystem_getStartSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartSpin();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartSpin : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartSpin)

static bool js_cocos2dx_ParticleSystem_getResourceFile(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getResourceFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceFile();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getResourceFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getResourceFile)

static bool js_cocos2dx_ParticleSystem_getRotatePerSecond(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotatePerSecond : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotatePerSecond();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotatePerSecond : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotatePerSecond)

static bool js_cocos2dx_ParticleSystem_setEmitterMode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEmitterMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleSystem::Mode arg0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEmitterMode : Error processing arguments");
        cobj->setEmitterMode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEmitterMode)

static bool js_cocos2dx_ParticleSystem_getDuration(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getDuration : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getDuration();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getDuration : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getDuration)

static bool js_cocos2dx_ParticleSystem_setSourcePosition(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSourcePosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSourcePosition : Error processing arguments");
        cobj->setSourcePosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSourcePosition)

static bool js_cocos2dx_ParticleSystem_stop(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_stop : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->stop();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_stop)

static bool js_cocos2dx_ParticleSystem_updateParticleQuads(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_updateParticleQuads : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateParticleQuads();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_updateParticleQuads)

static bool js_cocos2dx_ParticleSystem_getEndSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSpinVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSpinVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSpinVar)

static bool js_cocos2dx_ParticleSystem_setBlendAdditive(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBlendAdditive : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBlendAdditive : Error processing arguments");
        cobj->setBlendAdditive(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBlendAdditive)

static bool js_cocos2dx_ParticleSystem_setLife(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setLife : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setLife : Error processing arguments");
        cobj->setLife(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setLife)

static bool js_cocos2dx_ParticleSystem_setAngleVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAngleVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAngleVar : Error processing arguments");
        cobj->setAngleVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAngleVar)

static bool js_cocos2dx_ParticleSystem_setRotationIsDir(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRotationIsDir : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRotationIsDir : Error processing arguments");
        cobj->setRotationIsDir(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRotationIsDir)

static bool js_cocos2dx_ParticleSystem_start(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_start : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->start();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_start)

static bool js_cocos2dx_ParticleSystem_setEndSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSizeVar : Error processing arguments");
        cobj->setEndSizeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSizeVar)

static bool js_cocos2dx_ParticleSystem_setAngle(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAngle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAngle : Error processing arguments");
        cobj->setAngle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAngle)

static bool js_cocos2dx_ParticleSystem_setBatchNode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ParticleBatchNode* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBatchNode : Error processing arguments");
        cobj->setBatchNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBatchNode)

static bool js_cocos2dx_ParticleSystem_getTangentialAccelVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTangentialAccelVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getTangentialAccelVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTangentialAccelVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTangentialAccelVar)

static bool js_cocos2dx_ParticleSystem_getEmitterMode(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEmitterMode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getEmitterMode();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEmitterMode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEmitterMode)

static bool js_cocos2dx_ParticleSystem_setEndSpinVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSpinVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSpinVar : Error processing arguments");
        cobj->setEndSpinVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSpinVar)

static bool js_cocos2dx_ParticleSystem_initWithFile(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithFile)

static bool js_cocos2dx_ParticleSystem_getAngleVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getAngleVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getAngleVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getAngleVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getAngleVar)

static bool js_cocos2dx_ParticleSystem_setStartColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartColor : Error processing arguments");
        cobj->setStartColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartColor)

static bool js_cocos2dx_ParticleSystem_getRotatePerSecondVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotatePerSecondVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getRotatePerSecondVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotatePerSecondVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotatePerSecondVar)

static bool js_cocos2dx_ParticleSystem_getEndSize(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndSize();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndSize)

static bool js_cocos2dx_ParticleSystem_getLife(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getLife : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLife();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getLife : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getLife)

static bool js_cocos2dx_ParticleSystem_isPaused(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isPaused : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isPaused();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isPaused : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isPaused)

static bool js_cocos2dx_ParticleSystem_setSpeedVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setSpeedVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setSpeedVar : Error processing arguments");
        cobj->setSpeedVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setSpeedVar)

static bool js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish : Error processing arguments");
        cobj->setAutoRemoveOnFinish(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish)

static bool js_cocos2dx_ParticleSystem_setGravity(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setGravity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setGravity : Error processing arguments");
        cobj->setGravity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setGravity)

static bool js_cocos2dx_ParticleSystem_postStep(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_postStep : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->postStep();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_postStep)

static bool js_cocos2dx_ParticleSystem_setEmissionRate(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEmissionRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEmissionRate : Error processing arguments");
        cobj->setEmissionRate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEmissionRate)

static bool js_cocos2dx_ParticleSystem_getEndColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getEndColorVar();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndColorVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndColorVar)

static bool js_cocos2dx_ParticleSystem_getRotationIsDir(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getRotationIsDir : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->getRotationIsDir();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getRotationIsDir : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getRotationIsDir)

static bool js_cocos2dx_ParticleSystem_getEmissionRate(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEmissionRate : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEmissionRate();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEmissionRate : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEmissionRate)

static bool js_cocos2dx_ParticleSystem_getEndColor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getEndColor();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndColor)

static bool js_cocos2dx_ParticleSystem_getLifeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getLifeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getLifeVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getLifeVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getLifeVar)

static bool js_cocos2dx_ParticleSystem_setStartSizeVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartSizeVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartSizeVar : Error processing arguments");
        cobj->setStartSizeVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartSizeVar)

static bool js_cocos2dx_ParticleSystem_getStartRadius(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartRadius : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartRadius();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartRadius : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartRadius)

static bool js_cocos2dx_ParticleSystem_getParticleCount(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getParticleCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getParticleCount();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getParticleCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getParticleCount)

static bool js_cocos2dx_ParticleSystem_getStartRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getStartRadiusVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartRadiusVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartRadiusVar)

static bool js_cocos2dx_ParticleSystem_getBlendFunc(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getBlendFunc)

static bool js_cocos2dx_ParticleSystem_setStartColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartColorVar : Error processing arguments");
        cobj->setStartColorVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartColorVar)

static bool js_cocos2dx_ParticleSystem_setEndSpin(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setEndSpin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setEndSpin : Error processing arguments");
        cobj->setEndSpin(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setEndSpin)

static bool js_cocos2dx_ParticleSystem_setRadialAccel(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setRadialAccel : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setRadialAccel : Error processing arguments");
        cobj->setRadialAccel(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setRadialAccel)

static bool js_cocos2dx_ParticleSystem_initWithDictionary(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDictionary(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithDictionary(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_initWithDictionary : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_initWithDictionary)

static bool js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isAutoRemoveOnFinish();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish)

static bool js_cocos2dx_ParticleSystem_getTotalParticles(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getTotalParticles();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getTotalParticles)

static bool js_cocos2dx_ParticleSystem_setStartRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setStartRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setStartRadiusVar : Error processing arguments");
        cobj->setStartRadiusVar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setStartRadiusVar)

static bool js_cocos2dx_ParticleSystem_setBlendFunc(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_setBlendFunc)

static bool js_cocos2dx_ParticleSystem_getEndRadiusVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getEndRadiusVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getEndRadiusVar();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getEndRadiusVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getEndRadiusVar)

static bool js_cocos2dx_ParticleSystem_getStartColorVar(se::State& s)
{
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystem_getStartColorVar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getStartColorVar();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_getStartColorVar : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_getStartColorVar)

static bool js_cocos2dx_ParticleSystem_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_create : Error processing arguments");
        auto result = cocos2d::ParticleSystem::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystem_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_create)

static bool js_cocos2dx_ParticleSystem_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystem_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSystem::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystem_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystem_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSystem_finalize)

static bool js_cocos2dx_ParticleSystem_constructor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = new (std::nothrow) cocos2d::ParticleSystem();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSystem_constructor, __jsb_cocos2d_ParticleSystem_class, js_cocos2d_ParticleSystem_finalize)

static bool js_cocos2dx_ParticleSystem_ctor(se::State& s)
{
    cocos2d::ParticleSystem* cobj = new (std::nothrow) cocos2d::ParticleSystem();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParticleSystem_ctor, __jsb_cocos2d_ParticleSystem_class, js_cocos2d_ParticleSystem_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_ParticleSystem_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSystem)", s.nativeThisObject());
    cocos2d::ParticleSystem* cobj = (cocos2d::ParticleSystem*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSystem_finalize)

bool js_register_cocos2dx_ParticleSystem(se::Object* obj)
{
    auto cls = se::Class::create("_ParticleSystem", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParticleSystem_constructor));

    cls->defineFunction("getStartSizeVar", _SE(js_cocos2dx_ParticleSystem_getStartSizeVar));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_ParticleSystem_getTexture));
    cls->defineFunction("isFull", _SE(js_cocos2dx_ParticleSystem_isFull));
    cls->defineFunction("getBatchNode", _SE(js_cocos2dx_ParticleSystem_getBatchNode));
    cls->defineFunction("getStartColor", _SE(js_cocos2dx_ParticleSystem_getStartColor));
    cls->defineFunction("getPositionType", _SE(js_cocos2dx_ParticleSystem_getPositionType));
    cls->defineFunction("setPosVar", _SE(js_cocos2dx_ParticleSystem_setPosVar));
    cls->defineFunction("getEndSpin", _SE(js_cocos2dx_ParticleSystem_getEndSpin));
    cls->defineFunction("setRotatePerSecondVar", _SE(js_cocos2dx_ParticleSystem_setRotatePerSecondVar));
    cls->defineFunction("getStartSpinVar", _SE(js_cocos2dx_ParticleSystem_getStartSpinVar));
    cls->defineFunction("getRadialAccelVar", _SE(js_cocos2dx_ParticleSystem_getRadialAccelVar));
    cls->defineFunction("getEndSizeVar", _SE(js_cocos2dx_ParticleSystem_getEndSizeVar));
    cls->defineFunction("setTangentialAccel", _SE(js_cocos2dx_ParticleSystem_setTangentialAccel));
    cls->defineFunction("getRadialAccel", _SE(js_cocos2dx_ParticleSystem_getRadialAccel));
    cls->defineFunction("setStartRadius", _SE(js_cocos2dx_ParticleSystem_setStartRadius));
    cls->defineFunction("setRotatePerSecond", _SE(js_cocos2dx_ParticleSystem_setRotatePerSecond));
    cls->defineFunction("setEndSize", _SE(js_cocos2dx_ParticleSystem_setEndSize));
    cls->defineFunction("getGravity", _SE(js_cocos2dx_ParticleSystem_getGravity));
    cls->defineFunction("resumeEmissions", _SE(js_cocos2dx_ParticleSystem_resumeEmissions));
    cls->defineFunction("getTangentialAccel", _SE(js_cocos2dx_ParticleSystem_getTangentialAccel));
    cls->defineFunction("setEndRadius", _SE(js_cocos2dx_ParticleSystem_setEndRadius));
    cls->defineFunction("getSpeed", _SE(js_cocos2dx_ParticleSystem_getSpeed));
    cls->defineFunction("pauseEmissions", _SE(js_cocos2dx_ParticleSystem_pauseEmissions));
    cls->defineFunction("getAngle", _SE(js_cocos2dx_ParticleSystem_getAngle));
    cls->defineFunction("setEndColor", _SE(js_cocos2dx_ParticleSystem_setEndColor));
    cls->defineFunction("setStartSpin", _SE(js_cocos2dx_ParticleSystem_setStartSpin));
    cls->defineFunction("setDuration", _SE(js_cocos2dx_ParticleSystem_setDuration));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSystem_initWithTotalParticles));
    cls->defineFunction("addParticles", _SE(js_cocos2dx_ParticleSystem_addParticles));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_ParticleSystem_setTexture));
    cls->defineFunction("getPosVar", _SE(js_cocos2dx_ParticleSystem_getPosVar));
    cls->defineFunction("updateWithNoTime", _SE(js_cocos2dx_ParticleSystem_updateWithNoTime));
    cls->defineFunction("isBlendAdditive", _SE(js_cocos2dx_ParticleSystem_isBlendAdditive));
    cls->defineFunction("getSpeedVar", _SE(js_cocos2dx_ParticleSystem_getSpeedVar));
    cls->defineFunction("setPositionType", _SE(js_cocos2dx_ParticleSystem_setPositionType));
    cls->defineFunction("stopSystem", _SE(js_cocos2dx_ParticleSystem_stopSystem));
    cls->defineFunction("getSourcePosition", _SE(js_cocos2dx_ParticleSystem_getSourcePosition));
    cls->defineFunction("setLifeVar", _SE(js_cocos2dx_ParticleSystem_setLifeVar));
    cls->defineFunction("setTotalParticles", _SE(js_cocos2dx_ParticleSystem_setTotalParticles));
    cls->defineFunction("setEndColorVar", _SE(js_cocos2dx_ParticleSystem_setEndColorVar));
    cls->defineFunction("getAtlasIndex", _SE(js_cocos2dx_ParticleSystem_getAtlasIndex));
    cls->defineFunction("getStartSize", _SE(js_cocos2dx_ParticleSystem_getStartSize));
    cls->defineFunction("setStartSpinVar", _SE(js_cocos2dx_ParticleSystem_setStartSpinVar));
    cls->defineFunction("resetSystem", _SE(js_cocos2dx_ParticleSystem_resetSystem));
    cls->defineFunction("setAtlasIndex", _SE(js_cocos2dx_ParticleSystem_setAtlasIndex));
    cls->defineFunction("setTangentialAccelVar", _SE(js_cocos2dx_ParticleSystem_setTangentialAccelVar));
    cls->defineFunction("setEndRadiusVar", _SE(js_cocos2dx_ParticleSystem_setEndRadiusVar));
    cls->defineFunction("getEndRadius", _SE(js_cocos2dx_ParticleSystem_getEndRadius));
    cls->defineFunction("isActive", _SE(js_cocos2dx_ParticleSystem_isActive));
    cls->defineFunction("setRadialAccelVar", _SE(js_cocos2dx_ParticleSystem_setRadialAccelVar));
    cls->defineFunction("setStartSize", _SE(js_cocos2dx_ParticleSystem_setStartSize));
    cls->defineFunction("setSpeed", _SE(js_cocos2dx_ParticleSystem_setSpeed));
    cls->defineFunction("getStartSpin", _SE(js_cocos2dx_ParticleSystem_getStartSpin));
    cls->defineFunction("getResourceFile", _SE(js_cocos2dx_ParticleSystem_getResourceFile));
    cls->defineFunction("getRotatePerSecond", _SE(js_cocos2dx_ParticleSystem_getRotatePerSecond));
    cls->defineFunction("setEmitterMode", _SE(js_cocos2dx_ParticleSystem_setEmitterMode));
    cls->defineFunction("getDuration", _SE(js_cocos2dx_ParticleSystem_getDuration));
    cls->defineFunction("setSourcePosition", _SE(js_cocos2dx_ParticleSystem_setSourcePosition));
    cls->defineFunction("stop", _SE(js_cocos2dx_ParticleSystem_stop));
    cls->defineFunction("updateParticleQuads", _SE(js_cocos2dx_ParticleSystem_updateParticleQuads));
    cls->defineFunction("getEndSpinVar", _SE(js_cocos2dx_ParticleSystem_getEndSpinVar));
    cls->defineFunction("setBlendAdditive", _SE(js_cocos2dx_ParticleSystem_setBlendAdditive));
    cls->defineFunction("setLife", _SE(js_cocos2dx_ParticleSystem_setLife));
    cls->defineFunction("setAngleVar", _SE(js_cocos2dx_ParticleSystem_setAngleVar));
    cls->defineFunction("setRotationIsDir", _SE(js_cocos2dx_ParticleSystem_setRotationIsDir));
    cls->defineFunction("start", _SE(js_cocos2dx_ParticleSystem_start));
    cls->defineFunction("setEndSizeVar", _SE(js_cocos2dx_ParticleSystem_setEndSizeVar));
    cls->defineFunction("setAngle", _SE(js_cocos2dx_ParticleSystem_setAngle));
    cls->defineFunction("setBatchNode", _SE(js_cocos2dx_ParticleSystem_setBatchNode));
    cls->defineFunction("getTangentialAccelVar", _SE(js_cocos2dx_ParticleSystem_getTangentialAccelVar));
    cls->defineFunction("getEmitterMode", _SE(js_cocos2dx_ParticleSystem_getEmitterMode));
    cls->defineFunction("setEndSpinVar", _SE(js_cocos2dx_ParticleSystem_setEndSpinVar));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_ParticleSystem_initWithFile));
    cls->defineFunction("getAngleVar", _SE(js_cocos2dx_ParticleSystem_getAngleVar));
    cls->defineFunction("setStartColor", _SE(js_cocos2dx_ParticleSystem_setStartColor));
    cls->defineFunction("getRotatePerSecondVar", _SE(js_cocos2dx_ParticleSystem_getRotatePerSecondVar));
    cls->defineFunction("getEndSize", _SE(js_cocos2dx_ParticleSystem_getEndSize));
    cls->defineFunction("getLife", _SE(js_cocos2dx_ParticleSystem_getLife));
    cls->defineFunction("isPaused", _SE(js_cocos2dx_ParticleSystem_isPaused));
    cls->defineFunction("setSpeedVar", _SE(js_cocos2dx_ParticleSystem_setSpeedVar));
    cls->defineFunction("setAutoRemoveOnFinish", _SE(js_cocos2dx_ParticleSystem_setAutoRemoveOnFinish));
    cls->defineFunction("setGravity", _SE(js_cocos2dx_ParticleSystem_setGravity));
    cls->defineFunction("postStep", _SE(js_cocos2dx_ParticleSystem_postStep));
    cls->defineFunction("setEmissionRate", _SE(js_cocos2dx_ParticleSystem_setEmissionRate));
    cls->defineFunction("getEndColorVar", _SE(js_cocos2dx_ParticleSystem_getEndColorVar));
    cls->defineFunction("getRotationIsDir", _SE(js_cocos2dx_ParticleSystem_getRotationIsDir));
    cls->defineFunction("getEmissionRate", _SE(js_cocos2dx_ParticleSystem_getEmissionRate));
    cls->defineFunction("getEndColor", _SE(js_cocos2dx_ParticleSystem_getEndColor));
    cls->defineFunction("getLifeVar", _SE(js_cocos2dx_ParticleSystem_getLifeVar));
    cls->defineFunction("setStartSizeVar", _SE(js_cocos2dx_ParticleSystem_setStartSizeVar));
    cls->defineFunction("getStartRadius", _SE(js_cocos2dx_ParticleSystem_getStartRadius));
    cls->defineFunction("getParticleCount", _SE(js_cocos2dx_ParticleSystem_getParticleCount));
    cls->defineFunction("getStartRadiusVar", _SE(js_cocos2dx_ParticleSystem_getStartRadiusVar));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_ParticleSystem_getBlendFunc));
    cls->defineFunction("setStartColorVar", _SE(js_cocos2dx_ParticleSystem_setStartColorVar));
    cls->defineFunction("setEndSpin", _SE(js_cocos2dx_ParticleSystem_setEndSpin));
    cls->defineFunction("setRadialAccel", _SE(js_cocos2dx_ParticleSystem_setRadialAccel));
    cls->defineFunction("initWithDictionary", _SE(js_cocos2dx_ParticleSystem_initWithDictionary));
    cls->defineFunction("isAutoRemoveOnFinish", _SE(js_cocos2dx_ParticleSystem_isAutoRemoveOnFinish));
    cls->defineFunction("getTotalParticles", _SE(js_cocos2dx_ParticleSystem_getTotalParticles));
    cls->defineFunction("setStartRadiusVar", _SE(js_cocos2dx_ParticleSystem_setStartRadiusVar));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_ParticleSystem_setBlendFunc));
    cls->defineFunction("getEndRadiusVar", _SE(js_cocos2dx_ParticleSystem_getEndRadiusVar));
    cls->defineFunction("getStartColorVar", _SE(js_cocos2dx_ParticleSystem_getStartColorVar));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParticleSystem_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSystem_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSystem_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSystem_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSystem>(cls);

    __jsb_cocos2d_ParticleSystem_proto = cls->getProto();
    __jsb_cocos2d_ParticleSystem_class = cls;

    jsb_set_extend_property("cc", "_ParticleSystem");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSystemQuad_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSystemQuad_class = nullptr;

static bool js_cocos2dx_ParticleSystemQuad_setDisplayFrame(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_setDisplayFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_setDisplayFrame : Error processing arguments");
        cobj->setDisplayFrame(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_setDisplayFrame)

static bool js_cocos2dx_ParticleSystemQuad_setTextureWithRect(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_setTextureWithRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        cocos2d::Rect arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_setTextureWithRect : Error processing arguments");
        cobj->setTextureWithRect(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_setTextureWithRect)

static bool js_cocos2dx_ParticleSystemQuad_listenRendererRecreated(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSystemQuad_listenRendererRecreated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::EventCustom* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_listenRendererRecreated : Error processing arguments");
        cobj->listenRendererRecreated(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_listenRendererRecreated)

static bool js_cocos2dx_ParticleSystemQuad_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 0) {
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create();
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 1) {
            cocos2d::ValueMap arg0;
            ok &= seval_to_ccvaluemap(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::ParticleSystemQuad* result = cocos2d::ParticleSystemQuad::create(arg0);
            ok &= native_ptr_to_seval<cocos2d::ParticleSystemQuad>((cocos2d::ParticleSystemQuad*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_create)

static bool js_cocos2dx_ParticleSystemQuad_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSystemQuad_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSystemQuad::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSystemQuad_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSystemQuad_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSystemQuad_finalize)

static bool js_cocos2dx_ParticleSystemQuad_constructor(se::State& s)
{
    cocos2d::ParticleSystemQuad* cobj = new (std::nothrow) cocos2d::ParticleSystemQuad();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSystemQuad_constructor, __jsb_cocos2d_ParticleSystemQuad_class, js_cocos2d_ParticleSystemQuad_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystem_proto;

static bool js_cocos2d_ParticleSystemQuad_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSystemQuad)", s.nativeThisObject());
    cocos2d::ParticleSystemQuad* cobj = (cocos2d::ParticleSystemQuad*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSystemQuad_finalize)

bool js_register_cocos2dx_ParticleSystemQuad(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSystem", obj, __jsb_cocos2d_ParticleSystem_proto, _SE(js_cocos2dx_ParticleSystemQuad_constructor));

    cls->defineFunction("setDisplayFrame", _SE(js_cocos2dx_ParticleSystemQuad_setDisplayFrame));
    cls->defineFunction("setTextureWithRect", _SE(js_cocos2dx_ParticleSystemQuad_setTextureWithRect));
    cls->defineFunction("listenRendererRecreated", _SE(js_cocos2dx_ParticleSystemQuad_listenRendererRecreated));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSystemQuad_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSystemQuad_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSystemQuad_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSystemQuad>(cls);

    __jsb_cocos2d_ParticleSystemQuad_proto = cls->getProto();
    __jsb_cocos2d_ParticleSystemQuad_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleFire_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFire_class = nullptr;

static bool js_cocos2dx_ParticleFire_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFire::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFire_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFire_create)

static bool js_cocos2dx_ParticleFire_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFire_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFire::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFire_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFire_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFire_finalize)

static bool js_cocos2dx_ParticleFire_constructor(se::State& s)
{
    cocos2d::ParticleFire* cobj = new (std::nothrow) cocos2d::ParticleFire();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFire_constructor, __jsb_cocos2d_ParticleFire_class, js_cocos2d_ParticleFire_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleFire_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleFire)", s.nativeThisObject());
    cocos2d::ParticleFire* cobj = (cocos2d::ParticleFire*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFire_finalize)

bool js_register_cocos2dx_ParticleFire(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFire", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFire_constructor));

    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFire_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFire_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleFire_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFire>(cls);

    __jsb_cocos2d_ParticleFire_proto = cls->getProto();
    __jsb_cocos2d_ParticleFire_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleFireworks_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFireworks_class = nullptr;

static bool js_cocos2dx_ParticleFireworks_init(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFireworks_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_init)

static bool js_cocos2dx_ParticleFireworks_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_initWithTotalParticles)

static bool js_cocos2dx_ParticleFireworks_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFireworks::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFireworks_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_create)

static bool js_cocos2dx_ParticleFireworks_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFireworks_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFireworks::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFireworks_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFireworks_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFireworks_finalize)

static bool js_cocos2dx_ParticleFireworks_constructor(se::State& s)
{
    cocos2d::ParticleFireworks* cobj = new (std::nothrow) cocos2d::ParticleFireworks();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFireworks_constructor, __jsb_cocos2d_ParticleFireworks_class, js_cocos2d_ParticleFireworks_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleFireworks_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleFireworks)", s.nativeThisObject());
    cocos2d::ParticleFireworks* cobj = (cocos2d::ParticleFireworks*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFireworks_finalize)

bool js_register_cocos2dx_ParticleFireworks(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFireworks", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFireworks_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleFireworks_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleFireworks_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFireworks_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFireworks_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleFireworks_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFireworks>(cls);

    __jsb_cocos2d_ParticleFireworks_proto = cls->getProto();
    __jsb_cocos2d_ParticleFireworks_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSun_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSun_class = nullptr;

static bool js_cocos2dx_ParticleSun_init(se::State& s)
{
    cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSun_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_init)

static bool js_cocos2dx_ParticleSun_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_initWithTotalParticles)

static bool js_cocos2dx_ParticleSun_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSun::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSun_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_create)

static bool js_cocos2dx_ParticleSun_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSun_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSun::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSun_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSun_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSun_finalize)

static bool js_cocos2dx_ParticleSun_constructor(se::State& s)
{
    cocos2d::ParticleSun* cobj = new (std::nothrow) cocos2d::ParticleSun();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSun_constructor, __jsb_cocos2d_ParticleSun_class, js_cocos2d_ParticleSun_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleSun_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSun)", s.nativeThisObject());
    cocos2d::ParticleSun* cobj = (cocos2d::ParticleSun*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSun_finalize)

bool js_register_cocos2dx_ParticleSun(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSun", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSun_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSun_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSun_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSun_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSun_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSun_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSun>(cls);

    __jsb_cocos2d_ParticleSun_proto = cls->getProto();
    __jsb_cocos2d_ParticleSun_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleGalaxy_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleGalaxy_class = nullptr;

static bool js_cocos2dx_ParticleGalaxy_init(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleGalaxy_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_init)

static bool js_cocos2dx_ParticleGalaxy_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_initWithTotalParticles)

static bool js_cocos2dx_ParticleGalaxy_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleGalaxy::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleGalaxy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_create)

static bool js_cocos2dx_ParticleGalaxy_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleGalaxy_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleGalaxy::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleGalaxy_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleGalaxy_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleGalaxy_finalize)

static bool js_cocos2dx_ParticleGalaxy_constructor(se::State& s)
{
    cocos2d::ParticleGalaxy* cobj = new (std::nothrow) cocos2d::ParticleGalaxy();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleGalaxy_constructor, __jsb_cocos2d_ParticleGalaxy_class, js_cocos2d_ParticleGalaxy_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleGalaxy_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleGalaxy)", s.nativeThisObject());
    cocos2d::ParticleGalaxy* cobj = (cocos2d::ParticleGalaxy*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleGalaxy_finalize)

bool js_register_cocos2dx_ParticleGalaxy(se::Object* obj)
{
    auto cls = se::Class::create("ParticleGalaxy", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleGalaxy_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleGalaxy_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleGalaxy_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleGalaxy_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleGalaxy_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleGalaxy_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleGalaxy>(cls);

    __jsb_cocos2d_ParticleGalaxy_proto = cls->getProto();
    __jsb_cocos2d_ParticleGalaxy_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleFlower_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleFlower_class = nullptr;

static bool js_cocos2dx_ParticleFlower_init(se::State& s)
{
    cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFlower_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_init)

static bool js_cocos2dx_ParticleFlower_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_initWithTotalParticles)

static bool js_cocos2dx_ParticleFlower_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleFlower::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFlower_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_create)

static bool js_cocos2dx_ParticleFlower_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleFlower_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleFlower::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleFlower_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleFlower_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleFlower_finalize)

static bool js_cocos2dx_ParticleFlower_constructor(se::State& s)
{
    cocos2d::ParticleFlower* cobj = new (std::nothrow) cocos2d::ParticleFlower();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleFlower_constructor, __jsb_cocos2d_ParticleFlower_class, js_cocos2d_ParticleFlower_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleFlower_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleFlower)", s.nativeThisObject());
    cocos2d::ParticleFlower* cobj = (cocos2d::ParticleFlower*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleFlower_finalize)

bool js_register_cocos2dx_ParticleFlower(se::Object* obj)
{
    auto cls = se::Class::create("ParticleFlower", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleFlower_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleFlower_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleFlower_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleFlower_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleFlower_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleFlower_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleFlower>(cls);

    __jsb_cocos2d_ParticleFlower_proto = cls->getProto();
    __jsb_cocos2d_ParticleFlower_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleMeteor_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleMeteor_class = nullptr;

static bool js_cocos2dx_ParticleMeteor_init(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleMeteor_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_init)

static bool js_cocos2dx_ParticleMeteor_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_initWithTotalParticles)

static bool js_cocos2dx_ParticleMeteor_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleMeteor::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleMeteor_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_create)

static bool js_cocos2dx_ParticleMeteor_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleMeteor_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleMeteor::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleMeteor_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleMeteor_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleMeteor_finalize)

static bool js_cocos2dx_ParticleMeteor_constructor(se::State& s)
{
    cocos2d::ParticleMeteor* cobj = new (std::nothrow) cocos2d::ParticleMeteor();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleMeteor_constructor, __jsb_cocos2d_ParticleMeteor_class, js_cocos2d_ParticleMeteor_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleMeteor_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleMeteor)", s.nativeThisObject());
    cocos2d::ParticleMeteor* cobj = (cocos2d::ParticleMeteor*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleMeteor_finalize)

bool js_register_cocos2dx_ParticleMeteor(se::Object* obj)
{
    auto cls = se::Class::create("ParticleMeteor", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleMeteor_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleMeteor_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleMeteor_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleMeteor_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleMeteor_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleMeteor_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleMeteor>(cls);

    __jsb_cocos2d_ParticleMeteor_proto = cls->getProto();
    __jsb_cocos2d_ParticleMeteor_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSpiral_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSpiral_class = nullptr;

static bool js_cocos2dx_ParticleSpiral_init(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSpiral_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_init)

static bool js_cocos2dx_ParticleSpiral_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_initWithTotalParticles)

static bool js_cocos2dx_ParticleSpiral_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSpiral::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSpiral_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_create)

static bool js_cocos2dx_ParticleSpiral_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSpiral_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSpiral::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSpiral_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSpiral_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSpiral_finalize)

static bool js_cocos2dx_ParticleSpiral_constructor(se::State& s)
{
    cocos2d::ParticleSpiral* cobj = new (std::nothrow) cocos2d::ParticleSpiral();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSpiral_constructor, __jsb_cocos2d_ParticleSpiral_class, js_cocos2d_ParticleSpiral_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleSpiral_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSpiral)", s.nativeThisObject());
    cocos2d::ParticleSpiral* cobj = (cocos2d::ParticleSpiral*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSpiral_finalize)

bool js_register_cocos2dx_ParticleSpiral(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSpiral", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSpiral_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSpiral_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSpiral_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSpiral_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSpiral_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSpiral_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSpiral>(cls);

    __jsb_cocos2d_ParticleSpiral_proto = cls->getProto();
    __jsb_cocos2d_ParticleSpiral_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleExplosion_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleExplosion_class = nullptr;

static bool js_cocos2dx_ParticleExplosion_init(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleExplosion_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_init)

static bool js_cocos2dx_ParticleExplosion_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_initWithTotalParticles)

static bool js_cocos2dx_ParticleExplosion_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleExplosion::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleExplosion_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_create)

static bool js_cocos2dx_ParticleExplosion_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleExplosion_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleExplosion::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleExplosion_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleExplosion_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleExplosion_finalize)

static bool js_cocos2dx_ParticleExplosion_constructor(se::State& s)
{
    cocos2d::ParticleExplosion* cobj = new (std::nothrow) cocos2d::ParticleExplosion();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleExplosion_constructor, __jsb_cocos2d_ParticleExplosion_class, js_cocos2d_ParticleExplosion_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleExplosion_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleExplosion)", s.nativeThisObject());
    cocos2d::ParticleExplosion* cobj = (cocos2d::ParticleExplosion*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleExplosion_finalize)

bool js_register_cocos2dx_ParticleExplosion(se::Object* obj)
{
    auto cls = se::Class::create("ParticleExplosion", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleExplosion_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleExplosion_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleExplosion_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleExplosion_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleExplosion_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleExplosion_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleExplosion>(cls);

    __jsb_cocos2d_ParticleExplosion_proto = cls->getProto();
    __jsb_cocos2d_ParticleExplosion_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSmoke_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSmoke_class = nullptr;

static bool js_cocos2dx_ParticleSmoke_init(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSmoke_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_init)

static bool js_cocos2dx_ParticleSmoke_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_initWithTotalParticles)

static bool js_cocos2dx_ParticleSmoke_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSmoke::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSmoke_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_create)

static bool js_cocos2dx_ParticleSmoke_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSmoke_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSmoke::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSmoke_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSmoke_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSmoke_finalize)

static bool js_cocos2dx_ParticleSmoke_constructor(se::State& s)
{
    cocos2d::ParticleSmoke* cobj = new (std::nothrow) cocos2d::ParticleSmoke();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSmoke_constructor, __jsb_cocos2d_ParticleSmoke_class, js_cocos2d_ParticleSmoke_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleSmoke_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSmoke)", s.nativeThisObject());
    cocos2d::ParticleSmoke* cobj = (cocos2d::ParticleSmoke*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSmoke_finalize)

bool js_register_cocos2dx_ParticleSmoke(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSmoke", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSmoke_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSmoke_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSmoke_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSmoke_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSmoke_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSmoke_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSmoke>(cls);

    __jsb_cocos2d_ParticleSmoke_proto = cls->getProto();
    __jsb_cocos2d_ParticleSmoke_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleSnow_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleSnow_class = nullptr;

static bool js_cocos2dx_ParticleSnow_init(se::State& s)
{
    cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSnow_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_init)

static bool js_cocos2dx_ParticleSnow_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_initWithTotalParticles)

static bool js_cocos2dx_ParticleSnow_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleSnow::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSnow_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_create)

static bool js_cocos2dx_ParticleSnow_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleSnow_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleSnow::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleSnow_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleSnow_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleSnow_finalize)

static bool js_cocos2dx_ParticleSnow_constructor(se::State& s)
{
    cocos2d::ParticleSnow* cobj = new (std::nothrow) cocos2d::ParticleSnow();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleSnow_constructor, __jsb_cocos2d_ParticleSnow_class, js_cocos2d_ParticleSnow_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleSnow_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleSnow)", s.nativeThisObject());
    cocos2d::ParticleSnow* cobj = (cocos2d::ParticleSnow*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleSnow_finalize)

bool js_register_cocos2dx_ParticleSnow(se::Object* obj)
{
    auto cls = se::Class::create("ParticleSnow", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleSnow_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleSnow_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleSnow_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleSnow_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleSnow_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleSnow_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleSnow>(cls);

    __jsb_cocos2d_ParticleSnow_proto = cls->getProto();
    __jsb_cocos2d_ParticleSnow_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParticleRain_proto = nullptr;
se::Class* __jsb_cocos2d_ParticleRain_class = nullptr;

static bool js_cocos2dx_ParticleRain_init(se::State& s)
{
    cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleRain_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_init)

static bool js_cocos2dx_ParticleRain_initWithTotalParticles(se::State& s)
{
    cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Error processing arguments");
        bool result = cobj->initWithTotalParticles(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_initWithTotalParticles : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_initWithTotalParticles)

static bool js_cocos2dx_ParticleRain_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParticleRain::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleRain_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_create)

static bool js_cocos2dx_ParticleRain_createWithTotalParticles(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParticleRain_createWithTotalParticles : Error processing arguments");
        auto result = cocos2d::ParticleRain::createWithTotalParticles(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParticleRain_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParticleRain_createWithTotalParticles)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParticleRain_finalize)

static bool js_cocos2dx_ParticleRain_constructor(se::State& s)
{
    cocos2d::ParticleRain* cobj = new (std::nothrow) cocos2d::ParticleRain();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParticleRain_constructor, __jsb_cocos2d_ParticleRain_class, js_cocos2d_ParticleRain_finalize)



extern se::Object* __jsb_cocos2d_ParticleSystemQuad_proto;

static bool js_cocos2d_ParticleRain_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParticleRain)", s.nativeThisObject());
    cocos2d::ParticleRain* cobj = (cocos2d::ParticleRain*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParticleRain_finalize)

bool js_register_cocos2dx_ParticleRain(se::Object* obj)
{
    auto cls = se::Class::create("ParticleRain", obj, __jsb_cocos2d_ParticleSystemQuad_proto, _SE(js_cocos2dx_ParticleRain_constructor));

    cls->defineFunction("init", _SE(js_cocos2dx_ParticleRain_init));
    cls->defineFunction("initWithTotalParticles", _SE(js_cocos2dx_ParticleRain_initWithTotalParticles));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParticleRain_create));
    cls->defineStaticFunction("createWithTotalParticles", _SE(js_cocos2dx_ParticleRain_createWithTotalParticles));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParticleRain_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParticleRain>(cls);

    __jsb_cocos2d_ParticleRain_proto = cls->getProto();
    __jsb_cocos2d_ParticleRain_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ProtectedNode_proto = nullptr;
se::Class* __jsb_cocos2d_ProtectedNode_class = nullptr;

static bool js_cocos2dx_ProtectedNode_addProtectedChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ProtectedNode_addProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->addProtectedChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_addProtectedChild)

static bool js_cocos2dx_ProtectedNode_disableCascadeColor(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_disableCascadeColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->disableCascadeColor();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_disableCascadeColor)

static bool js_cocos2dx_ProtectedNode_removeProtectedChildByTag(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing arguments");
        cobj->removeProtectedChildByTag(arg0);
        return true;
    }
    if (argc == 2) {
        int arg0 = 0;
        bool arg1;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChildByTag : Error processing arguments");
        cobj->removeProtectedChildByTag(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeProtectedChildByTag)

static bool js_cocos2dx_ProtectedNode_reorderProtectedChild(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_reorderProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_reorderProtectedChild : Error processing arguments");
        cobj->reorderProtectedChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_reorderProtectedChild)

static bool js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup : Error processing arguments");
        cobj->removeAllProtectedChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup)

static bool js_cocos2dx_ProtectedNode_disableCascadeOpacity(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_disableCascadeOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->disableCascadeOpacity();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_disableCascadeOpacity)

static bool js_cocos2dx_ProtectedNode_sortAllProtectedChildren(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_sortAllProtectedChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->sortAllProtectedChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_sortAllProtectedChildren)

static bool js_cocos2dx_ProtectedNode_getProtectedChildByTag(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Error processing arguments");
        cocos2d::Node* result = cobj->getProtectedChildByTag(arg0);
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_getProtectedChildByTag : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_getProtectedChildByTag)

static bool js_cocos2dx_ProtectedNode_removeProtectedChild(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Node* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Error processing arguments");
        cobj->removeProtectedChild(arg0);
        return true;
    }
    if (argc == 2) {
        cocos2d::Node* arg0 = nullptr;
        bool arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ProtectedNode_removeProtectedChild : Error processing arguments");
        cobj->removeProtectedChild(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeProtectedChild)

static bool js_cocos2dx_ProtectedNode_removeAllProtectedChildren(se::State& s)
{
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ProtectedNode_removeAllProtectedChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllProtectedChildren();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_removeAllProtectedChildren)

static bool js_cocos2dx_ProtectedNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ProtectedNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ProtectedNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ProtectedNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ProtectedNode_finalize)

static bool js_cocos2dx_ProtectedNode_constructor(se::State& s)
{
    cocos2d::ProtectedNode* cobj = new (std::nothrow) cocos2d::ProtectedNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ProtectedNode_constructor, __jsb_cocos2d_ProtectedNode_class, js_cocos2d_ProtectedNode_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_ProtectedNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ProtectedNode)", s.nativeThisObject());
    cocos2d::ProtectedNode* cobj = (cocos2d::ProtectedNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ProtectedNode_finalize)

bool js_register_cocos2dx_ProtectedNode(se::Object* obj)
{
    auto cls = se::Class::create("ProtectedNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ProtectedNode_constructor));

    cls->defineFunction("addProtectedChild", _SE(js_cocos2dx_ProtectedNode_addProtectedChild));
    cls->defineFunction("disableCascadeColor", _SE(js_cocos2dx_ProtectedNode_disableCascadeColor));
    cls->defineFunction("removeProtectedChildByTag", _SE(js_cocos2dx_ProtectedNode_removeProtectedChildByTag));
    cls->defineFunction("reorderProtectedChild", _SE(js_cocos2dx_ProtectedNode_reorderProtectedChild));
    cls->defineFunction("removeAllProtectedChildrenWithCleanup", _SE(js_cocos2dx_ProtectedNode_removeAllProtectedChildrenWithCleanup));
    cls->defineFunction("disableCascadeOpacity", _SE(js_cocos2dx_ProtectedNode_disableCascadeOpacity));
    cls->defineFunction("sortAllProtectedChildren", _SE(js_cocos2dx_ProtectedNode_sortAllProtectedChildren));
    cls->defineFunction("getProtectedChildByTag", _SE(js_cocos2dx_ProtectedNode_getProtectedChildByTag));
    cls->defineFunction("removeProtectedChild", _SE(js_cocos2dx_ProtectedNode_removeProtectedChild));
    cls->defineFunction("removeAllProtectedChildren", _SE(js_cocos2dx_ProtectedNode_removeAllProtectedChildren));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ProtectedNode_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ProtectedNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ProtectedNode>(cls);

    __jsb_cocos2d_ProtectedNode_proto = cls->getProto();
    __jsb_cocos2d_ProtectedNode_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Sprite_proto = nullptr;
se::Class* __jsb_cocos2d_Sprite_class = nullptr;

static bool js_cocos2dx_Sprite_setSpriteFrame(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::SpriteFrame* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setSpriteFrame(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setSpriteFrame(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setSpriteFrame)

static bool js_cocos2dx_Sprite_setTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTexture(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTexture(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTexture)

static bool js_cocos2dx_Sprite_getTexture(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getTexture)

static bool js_cocos2dx_Sprite_setFlippedY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setFlippedY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setFlippedY : Error processing arguments");
        cobj->setFlippedY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setFlippedY)

static bool js_cocos2dx_Sprite_setFlippedX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setFlippedX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setFlippedX : Error processing arguments");
        cobj->setFlippedX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setFlippedX)

static bool js_cocos2dx_Sprite_setRotationSkewX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setRotationSkewX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setRotationSkewX : Error processing arguments");
        cobj->setRotationSkewX(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setRotationSkewX)

static bool js_cocos2dx_Sprite_setRotationSkewY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setRotationSkewY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setRotationSkewY : Error processing arguments");
        cobj->setRotationSkewY(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setRotationSkewY)

static bool js_cocos2dx_Sprite_getResourceType(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getResourceType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getResourceType();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getResourceType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getResourceType)

static bool js_cocos2dx_Sprite_initWithTexture(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithTexture(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Texture2D* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            bool result = cobj->initWithTexture(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithTexture : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithTexture)

static bool js_cocos2dx_Sprite_getBatchNode(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteBatchNode* result = cobj->getBatchNode();
        ok &= native_ptr_to_seval<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getBatchNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getBatchNode)

static bool js_cocos2dx_Sprite_getOffsetPosition(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getOffsetPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getOffsetPosition();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getOffsetPosition : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getOffsetPosition)

static bool js_cocos2dx_Sprite_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_removeAllChildrenWithCleanup)

static bool js_cocos2dx_Sprite_setTextureRect(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_setTextureRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            cocos2d::Rect arg0;
            ok &= seval_to_Rect(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            cocos2d::Size arg2;
            ok &= seval_to_Size(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setTextureRect(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Rect arg0;
            ok &= seval_to_Rect(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setTextureRect(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTextureRect)

static bool js_cocos2dx_Sprite_initWithSpriteFrameName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Error processing arguments");
        bool result = cobj->initWithSpriteFrameName(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrameName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithSpriteFrameName)

static bool js_cocos2dx_Sprite_isFrameDisplayed(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFrameDisplayed : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFrameDisplayed : Error processing arguments");
        bool result = cobj->isFrameDisplayed(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFrameDisplayed : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFrameDisplayed)

static bool js_cocos2dx_Sprite_getAtlasIndex(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        ssize_t result = cobj->getAtlasIndex();
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getAtlasIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getAtlasIndex)

static bool js_cocos2dx_Sprite_setBatchNode(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setBatchNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteBatchNode* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setBatchNode : Error processing arguments");
        cobj->setBatchNode(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setBatchNode)

static bool js_cocos2dx_Sprite_getBlendFunc(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getBlendFunc)

static bool js_cocos2dx_Sprite_setDisplayFrameWithAnimationName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setDisplayFrameWithAnimationName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setDisplayFrameWithAnimationName : Error processing arguments");
        cobj->setDisplayFrameWithAnimationName(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setDisplayFrameWithAnimationName)

static bool js_cocos2dx_Sprite_setTextureAtlas(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setTextureAtlas)

static bool js_cocos2dx_Sprite_getSpriteFrame(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::SpriteFrame* result = cobj->getSpriteFrame();
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getSpriteFrame)

static bool js_cocos2dx_Sprite_getResourceName(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getResourceName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getResourceName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getResourceName)

static bool js_cocos2dx_Sprite_isDirty(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isDirty();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isDirty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isDirty)

static bool js_cocos2dx_Sprite_setAtlasIndex(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setAtlasIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        ssize_t arg0 = 0;
        ok &= seval_to_ssize(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setAtlasIndex : Error processing arguments");
        cobj->setAtlasIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setAtlasIndex)

static bool js_cocos2dx_Sprite_setDirty(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setDirty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setDirty : Error processing arguments");
        cobj->setDirty(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setDirty)

static bool js_cocos2dx_Sprite_isTextureRectRotated(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isTextureRectRotated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isTextureRectRotated();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isTextureRectRotated : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isTextureRectRotated)

static bool js_cocos2dx_Sprite_getTextureRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getTextureRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Rect& result = cobj->getTextureRect();
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getTextureRect : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getTextureRect)

static bool js_cocos2dx_Sprite_initWithFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_Sprite_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Rect arg1;
            ok &= seval_to_Rect(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFile(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithFile)

static bool js_cocos2dx_Sprite_setBlendFunc(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setBlendFunc)

static bool js_cocos2dx_Sprite_getTextureAtlas(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_getTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::TextureAtlas* result = cobj->getTextureAtlas();
        ok &= native_ptr_to_seval<cocos2d::TextureAtlas>((cocos2d::TextureAtlas*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_getTextureAtlas : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_getTextureAtlas)

static bool js_cocos2dx_Sprite_initWithSpriteFrame(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Error processing arguments");
        bool result = cobj->initWithSpriteFrame(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_initWithSpriteFrame : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_initWithSpriteFrame)

static bool js_cocos2dx_Sprite_isFlippedX(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFlippedX : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFlippedX();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFlippedX : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFlippedX)

static bool js_cocos2dx_Sprite_isFlippedY(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_isFlippedY : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isFlippedY();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_isFlippedY : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_isFlippedY)

static bool js_cocos2dx_Sprite_setVertexRect(se::State& s)
{
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Sprite_setVertexRect : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Rect arg0;
        ok &= seval_to_Rect(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Sprite_setVertexRect : Error processing arguments");
        cobj->setVertexRect(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Sprite_setVertexRect)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_Sprite_finalize)

static bool js_cocos2dx_Sprite_constructor(se::State& s)
{
    cocos2d::Sprite* cobj = new (std::nothrow) cocos2d::Sprite();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_Sprite_constructor, __jsb_cocos2d_Sprite_class, js_cocos2d_Sprite_finalize)

static bool js_cocos2dx_Sprite_ctor(se::State& s)
{
    cocos2d::Sprite* cobj = new (std::nothrow) cocos2d::Sprite();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_Sprite_ctor, __jsb_cocos2d_Sprite_class, js_cocos2d_Sprite_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_Sprite_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::Sprite)", s.nativeThisObject());
    cocos2d::Sprite* cobj = (cocos2d::Sprite*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_Sprite_finalize)

bool js_register_cocos2dx_Sprite(se::Object* obj)
{
    auto cls = se::Class::create("Sprite", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_Sprite_constructor));

    cls->defineFunction("setSpriteFrame", _SE(js_cocos2dx_Sprite_setSpriteFrame));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_Sprite_setTexture));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_Sprite_getTexture));
    cls->defineFunction("setFlippedY", _SE(js_cocos2dx_Sprite_setFlippedY));
    cls->defineFunction("setFlippedX", _SE(js_cocos2dx_Sprite_setFlippedX));
    cls->defineFunction("setRotationSkewX", _SE(js_cocos2dx_Sprite_setRotationSkewX));
    cls->defineFunction("setRotationSkewY", _SE(js_cocos2dx_Sprite_setRotationSkewY));
    cls->defineFunction("getResourceType", _SE(js_cocos2dx_Sprite_getResourceType));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_Sprite_initWithTexture));
    cls->defineFunction("getBatchNode", _SE(js_cocos2dx_Sprite_getBatchNode));
    cls->defineFunction("getOffsetPosition", _SE(js_cocos2dx_Sprite_getOffsetPosition));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_Sprite_removeAllChildrenWithCleanup));
    cls->defineFunction("setTextureRect", _SE(js_cocos2dx_Sprite_setTextureRect));
    cls->defineFunction("initWithSpriteFrameName", _SE(js_cocos2dx_Sprite_initWithSpriteFrameName));
    cls->defineFunction("isFrameDisplayed", _SE(js_cocos2dx_Sprite_isFrameDisplayed));
    cls->defineFunction("getAtlasIndex", _SE(js_cocos2dx_Sprite_getAtlasIndex));
    cls->defineFunction("setBatchNode", _SE(js_cocos2dx_Sprite_setBatchNode));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_Sprite_getBlendFunc));
    cls->defineFunction("setDisplayFrameWithAnimationName", _SE(js_cocos2dx_Sprite_setDisplayFrameWithAnimationName));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_Sprite_setTextureAtlas));
    cls->defineFunction("getSpriteFrame", _SE(js_cocos2dx_Sprite_getSpriteFrame));
    cls->defineFunction("getResourceName", _SE(js_cocos2dx_Sprite_getResourceName));
    cls->defineFunction("isDirty", _SE(js_cocos2dx_Sprite_isDirty));
    cls->defineFunction("setAtlasIndex", _SE(js_cocos2dx_Sprite_setAtlasIndex));
    cls->defineFunction("setDirty", _SE(js_cocos2dx_Sprite_setDirty));
    cls->defineFunction("isTextureRectRotated", _SE(js_cocos2dx_Sprite_isTextureRectRotated));
    cls->defineFunction("getTextureRect", _SE(js_cocos2dx_Sprite_getTextureRect));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_Sprite_initWithFile));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_Sprite_setBlendFunc));
    cls->defineFunction("getTextureAtlas", _SE(js_cocos2dx_Sprite_getTextureAtlas));
    cls->defineFunction("initWithSpriteFrame", _SE(js_cocos2dx_Sprite_initWithSpriteFrame));
    cls->defineFunction("isFlippedX", _SE(js_cocos2dx_Sprite_isFlippedX));
    cls->defineFunction("isFlippedY", _SE(js_cocos2dx_Sprite_isFlippedY));
    cls->defineFunction("setVertexRect", _SE(js_cocos2dx_Sprite_setVertexRect));
    cls->defineFunction("ctor", _SE(js_cocos2dx_Sprite_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_Sprite_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::Sprite>(cls);

    __jsb_cocos2d_Sprite_proto = cls->getProto();
    __jsb_cocos2d_Sprite_class = cls;

    jsb_set_extend_property("cc", "Sprite");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_RenderTexture_proto = nullptr;
se::Class* __jsb_cocos2d_RenderTexture_class = nullptr;

static bool js_cocos2dx_RenderTexture_setVirtualViewport(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setVirtualViewport : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Vec2 arg0;
        cocos2d::Rect arg1;
        cocos2d::Rect arg2;
        ok &= seval_to_Vec2(args[0], &arg0);
        ok &= seval_to_Rect(args[1], &arg1);
        ok &= seval_to_Rect(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setVirtualViewport : Error processing arguments");
        cobj->setVirtualViewport(arg0, arg1, arg2);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setVirtualViewport)

static bool js_cocos2dx_RenderTexture_clearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clearStencil : Error processing arguments");
        cobj->clearStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clearStencil)

static bool js_cocos2dx_RenderTexture_getClearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getClearDepth();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearDepth : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearDepth)

static bool js_cocos2dx_RenderTexture_getClearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getClearStencil();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearStencil : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearStencil)

static bool js_cocos2dx_RenderTexture_end(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_end : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->end();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_end)

static bool js_cocos2dx_RenderTexture_setClearStencil(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearStencil : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearStencil : Error processing arguments");
        cobj->setClearStencil(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearStencil)

static bool js_cocos2dx_RenderTexture_setSprite(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setSprite : Error processing arguments");
        cobj->setSprite(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setSprite)

static bool js_cocos2dx_RenderTexture_getSprite(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Sprite* result = cobj->getSprite();
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getSprite : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getSprite)

static bool js_cocos2dx_RenderTexture_isAutoDraw(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_isAutoDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isAutoDraw();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_isAutoDraw : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_isAutoDraw)

static bool js_cocos2dx_RenderTexture_setKeepMatrix(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setKeepMatrix : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setKeepMatrix : Error processing arguments");
        cobj->setKeepMatrix(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setKeepMatrix)

static bool js_cocos2dx_RenderTexture_setClearFlags(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearFlags : Error processing arguments");
        cobj->setClearFlags(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearFlags)

static bool js_cocos2dx_RenderTexture_begin(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_begin : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->begin();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_begin)

static bool js_cocos2dx_RenderTexture_saveToFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_RenderTexture_saveToFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Image::Format arg1;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->saveToFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Image::Format arg1;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            bool result = cobj->saveToFile(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Image::Format arg1;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            bool arg2;
            ok &= seval_to_boolean(args[2], &arg2);
            std::function<void (cocos2d::RenderTexture *, const std::basic_string<char> &)> arg3;
            do {
                if (args[3].isObject() && args[3].toObject()->isFunction())
                {
                    se::Value jsThis(s.thisObject());
                    se::Value jsFunc(args[3]);
                    jsThis.toObject()->attachObject(jsFunc.toObject());
                    auto lambda = [=](cocos2d::RenderTexture* larg0, const std::basic_string<char> & larg1) -> void {
                        se::ScriptEngine::getInstance()->clearException();
                        se::AutoHandleScope hs;
            
                        CC_UNUSED bool ok = true;
                        se::ValueArray args;
                        args.resize(2);
                        ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)larg0, &args[0]);
                        ok &= std_string_to_seval(larg1, &args[1]);
                        se::Value rval;
                        se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                        se::Object* funcObj = jsFunc.toObject();
                        bool succeed = funcObj->call(args, thisObj, &rval);
                        if (!succeed) {
                            se::ScriptEngine::getInstance()->clearException();
                        }
                    };
                    arg3 = lambda;
                }
                else
                {
                    arg3 = nullptr;
                }
            } while(false)
            ;
            if (!ok) { ok = true; break; }
            bool result = cobj->saveToFile(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool result = cobj->saveToFile(arg0);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            bool result = cobj->saveToFile(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            bool arg1;
            ok &= seval_to_boolean(args[1], &arg1);
            std::function<void (cocos2d::RenderTexture *, const std::basic_string<char> &)> arg2;
            do {
                if (args[2].isObject() && args[2].toObject()->isFunction())
                {
                    se::Value jsThis(s.thisObject());
                    se::Value jsFunc(args[2]);
                    jsThis.toObject()->attachObject(jsFunc.toObject());
                    auto lambda = [=](cocos2d::RenderTexture* larg0, const std::basic_string<char> & larg1) -> void {
                        se::ScriptEngine::getInstance()->clearException();
                        se::AutoHandleScope hs;
            
                        CC_UNUSED bool ok = true;
                        se::ValueArray args;
                        args.resize(2);
                        ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)larg0, &args[0]);
                        ok &= std_string_to_seval(larg1, &args[1]);
                        se::Value rval;
                        se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                        se::Object* funcObj = jsFunc.toObject();
                        bool succeed = funcObj->call(args, thisObj, &rval);
                        if (!succeed) {
                            se::ScriptEngine::getInstance()->clearException();
                        }
                    };
                    arg2 = lambda;
                }
                else
                {
                    arg2 = nullptr;
                }
            } while(false)
            ;
            if (!ok) { ok = true; break; }
            bool result = cobj->saveToFile(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_saveToFile : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_saveToFile)

static bool js_cocos2dx_RenderTexture_setAutoDraw(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setAutoDraw : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setAutoDraw : Error processing arguments");
        cobj->setAutoDraw(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setAutoDraw)

static bool js_cocos2dx_RenderTexture_setClearColor(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Color4F arg0;
        ok &= seval_to_Color4F(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearColor : Error processing arguments");
        cobj->setClearColor(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearColor)

static bool js_cocos2dx_RenderTexture_beginWithClear(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_RenderTexture_beginWithClear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 5) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 6) {
            float arg0 = 0;
            ok &= seval_to_float(args[0], &arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            int arg5 = 0;
            ok &= seval_to_int32(args[5], (int32_t*)&arg5);
            if (!ok) { ok = true; break; }
            cobj->beginWithClear(arg0, arg1, arg2, arg3, arg4, arg5);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_beginWithClear)

static bool js_cocos2dx_RenderTexture_clearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clearDepth : Error processing arguments");
        cobj->clearDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clearDepth)

static bool js_cocos2dx_RenderTexture_getClearColor(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearColor : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4F& result = cobj->getClearColor();
        ok &= Color4F_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearColor : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearColor)

static bool js_cocos2dx_RenderTexture_clear(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_clear : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        float arg0 = 0;
        float arg1 = 0;
        float arg2 = 0;
        float arg3 = 0;
        ok &= seval_to_float(args[0], &arg0);
        ok &= seval_to_float(args[1], &arg1);
        ok &= seval_to_float(args[2], &arg2);
        ok &= seval_to_float(args[3], &arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_clear : Error processing arguments");
        cobj->clear(arg0, arg1, arg2, arg3);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_clear)

static bool js_cocos2dx_RenderTexture_getClearFlags(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_getClearFlags : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getClearFlags();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_getClearFlags : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_getClearFlags)

static bool js_cocos2dx_RenderTexture_newImage(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_newImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Image* result = cobj->newImage();
        ok &= native_ptr_to_seval<cocos2d::Image>((cocos2d::Image*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        return true;
    }
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        cocos2d::Image* result = cobj->newImage(arg0);
        ok &= native_ptr_to_seval<cocos2d::Image>((cocos2d::Image*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_newImage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_newImage)

static bool js_cocos2dx_RenderTexture_setClearDepth(se::State& s)
{
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_RenderTexture_setClearDepth : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_setClearDepth : Error processing arguments");
        cobj->setClearDepth(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_setClearDepth)

static bool js_cocos2dx_RenderTexture_initWithWidthAndHeight(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithWidthAndHeight(arg0, arg1, arg2, arg3);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithWidthAndHeight(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_initWithWidthAndHeight : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_initWithWidthAndHeight)

static bool js_cocos2dx_RenderTexture_create(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D::PixelFormat arg2;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            unsigned int arg3 = 0;
            ok &= seval_to_uint32(args[3], (uint32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1, arg2, arg3);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::RenderTexture* result = cocos2d::RenderTexture::create(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::RenderTexture>((cocos2d::RenderTexture*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_RenderTexture_create : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_RenderTexture_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_RenderTexture_finalize)

static bool js_cocos2dx_RenderTexture_constructor(se::State& s)
{
    cocos2d::RenderTexture* cobj = new (std::nothrow) cocos2d::RenderTexture();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_RenderTexture_constructor, __jsb_cocos2d_RenderTexture_class, js_cocos2d_RenderTexture_finalize)

static bool js_cocos2dx_RenderTexture_ctor(se::State& s)
{
    cocos2d::RenderTexture* cobj = new (std::nothrow) cocos2d::RenderTexture();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_RenderTexture_ctor, __jsb_cocos2d_RenderTexture_class, js_cocos2d_RenderTexture_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_RenderTexture_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::RenderTexture)", s.nativeThisObject());
    cocos2d::RenderTexture* cobj = (cocos2d::RenderTexture*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_RenderTexture_finalize)

bool js_register_cocos2dx_RenderTexture(se::Object* obj)
{
    auto cls = se::Class::create("RenderTexture", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_RenderTexture_constructor));

    cls->defineFunction("setVirtualViewport", _SE(js_cocos2dx_RenderTexture_setVirtualViewport));
    cls->defineFunction("clearStencil", _SE(js_cocos2dx_RenderTexture_clearStencil));
    cls->defineFunction("getClearDepth", _SE(js_cocos2dx_RenderTexture_getClearDepth));
    cls->defineFunction("getClearStencil", _SE(js_cocos2dx_RenderTexture_getClearStencil));
    cls->defineFunction("end", _SE(js_cocos2dx_RenderTexture_end));
    cls->defineFunction("setClearStencil", _SE(js_cocos2dx_RenderTexture_setClearStencil));
    cls->defineFunction("setSprite", _SE(js_cocos2dx_RenderTexture_setSprite));
    cls->defineFunction("getSprite", _SE(js_cocos2dx_RenderTexture_getSprite));
    cls->defineFunction("isAutoDraw", _SE(js_cocos2dx_RenderTexture_isAutoDraw));
    cls->defineFunction("setKeepMatrix", _SE(js_cocos2dx_RenderTexture_setKeepMatrix));
    cls->defineFunction("setClearFlags", _SE(js_cocos2dx_RenderTexture_setClearFlags));
    cls->defineFunction("begin", _SE(js_cocos2dx_RenderTexture_begin));
    cls->defineFunction("saveToFile", _SE(js_cocos2dx_RenderTexture_saveToFile));
    cls->defineFunction("setAutoDraw", _SE(js_cocos2dx_RenderTexture_setAutoDraw));
    cls->defineFunction("setClearColor", _SE(js_cocos2dx_RenderTexture_setClearColor));
    cls->defineFunction("beginWithClear", _SE(js_cocos2dx_RenderTexture_beginWithClear));
    cls->defineFunction("clearDepth", _SE(js_cocos2dx_RenderTexture_clearDepth));
    cls->defineFunction("getClearColor", _SE(js_cocos2dx_RenderTexture_getClearColor));
    cls->defineFunction("clear", _SE(js_cocos2dx_RenderTexture_clear));
    cls->defineFunction("getClearFlags", _SE(js_cocos2dx_RenderTexture_getClearFlags));
    cls->defineFunction("newImage", _SE(js_cocos2dx_RenderTexture_newImage));
    cls->defineFunction("setClearDepth", _SE(js_cocos2dx_RenderTexture_setClearDepth));
    cls->defineFunction("initWithWidthAndHeight", _SE(js_cocos2dx_RenderTexture_initWithWidthAndHeight));
    cls->defineFunction("ctor", _SE(js_cocos2dx_RenderTexture_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_RenderTexture_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_RenderTexture_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::RenderTexture>(cls);

    __jsb_cocos2d_RenderTexture_proto = cls->getProto();
    __jsb_cocos2d_RenderTexture_class = cls;

    jsb_set_extend_property("cc", "RenderTexture");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_GLProgram_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgram_class = nullptr;

static bool js_cocos2dx_GLProgram_getFragmentShaderLog(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getFragmentShaderLog : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getFragmentShaderLog();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getFragmentShaderLog : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getFragmentShaderLog)

static bool js_cocos2dx_GLProgram_bindAttribLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_bindAttribLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        unsigned int arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_uint32(args[1], (uint32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_bindAttribLocation : Error processing arguments");
        cobj->bindAttribLocation(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_bindAttribLocation)

static bool js_cocos2dx_GLProgram_getUniformLocationForName(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Error processing arguments");
        int result = cobj->getUniformLocationForName(arg0);
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocationForName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniformLocationForName)

static bool js_cocos2dx_GLProgram_use(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_use : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->use();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_use)

static bool js_cocos2dx_GLProgram_getVertexShaderLog(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getVertexShaderLog : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getVertexShaderLog();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getVertexShaderLog : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getVertexShaderLog)

static bool js_cocos2dx_GLProgram_getUniform(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniform : Error processing arguments");
        cocos2d::Uniform* result = cobj->getUniform(arg0);
        ok &= uniform_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniform)

static bool js_cocos2dx_GLProgram_initWithByteArrays(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_initWithByteArrays : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithByteArrays(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithByteArrays : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithByteArrays(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithByteArrays : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_initWithByteArrays)

static bool js_cocos2dx_GLProgram_getProgram(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getProgram();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getProgram)

static bool js_cocos2dx_GLProgram_setUniformLocationWith2f(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith2f : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith2f(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith1f(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith3f(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            float arg1 = 0;
            ok &= seval_to_float(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            float arg3 = 0;
            ok &= seval_to_float(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith4f(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith2f)

static bool js_cocos2dx_GLProgram_initWithFilenames(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_initWithFilenames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFilenames(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithFilenames : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithFilenames(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_initWithFilenames : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_initWithFilenames)

static bool js_cocos2dx_GLProgram_setUniformsForBuiltins(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_setUniformsForBuiltins : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cobj->setUniformsForBuiltins();
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Mat4 arg0;
            ok &= seval_to_Mat4(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setUniformsForBuiltins(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformsForBuiltins)

static bool js_cocos2dx_GLProgram_updateUniforms(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_updateUniforms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->updateUniforms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_updateUniforms)

static bool js_cocos2dx_GLProgram_link(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_link : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->link();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_link : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_link)

static bool js_cocos2dx_GLProgram_reset(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_reset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reset();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_reset)

static bool js_cocos2dx_GLProgram_getProgramLog(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getProgramLog : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getProgramLog();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getProgramLog : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getProgramLog)

static bool js_cocos2dx_GLProgram_getAttribLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getAttribLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getAttribLocation : Error processing arguments");
        int result = cobj->getAttribLocation(arg0);
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getAttribLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getAttribLocation)

static bool js_cocos2dx_GLProgram_getUniformLocation(se::State& s)
{
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgram_getUniformLocation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocation : Error processing arguments");
        int result = cobj->getUniformLocation(arg0);
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_getUniformLocation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_getUniformLocation)

static bool js_cocos2dx_GLProgram_setUniformLocationWith2i(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_GLProgram_setUniformLocationWith2i : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith2i(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith1i(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 4) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith3i(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            int arg3 = 0;
            ok &= seval_to_int32(args[3], (int32_t*)&arg3);
            if (!ok) { ok = true; break; }
            int arg4 = 0;
            ok &= seval_to_int32(args[4], (int32_t*)&arg4);
            if (!ok) { ok = true; break; }
            cobj->setUniformLocationWith4i(arg0, arg1, arg2, arg3, arg4);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_setUniformLocationWith2i)

static bool js_cocos2dx_GLProgram_createWithByteArrays(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithByteArrays(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            const char* arg0 = nullptr;
            std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
            if (!ok) { ok = true; break; }
            const char* arg1 = nullptr;
            std::string arg1_tmp; ok &= seval_to_std_string(args[1], &arg1_tmp); arg1 = arg1_tmp.c_str();
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithByteArrays(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithByteArrays : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_createWithByteArrays)

static bool js_cocos2dx_GLProgram_createWithFilenames(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithFilenames(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::GLProgram* result = cocos2d::GLProgram::createWithFilenames(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgram_createWithFilenames : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgram_createWithFilenames)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_GLProgram_finalize)

static bool js_cocos2dx_GLProgram_constructor(se::State& s)
{
    cocos2d::GLProgram* cobj = new (std::nothrow) cocos2d::GLProgram();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_GLProgram_constructor, __jsb_cocos2d_GLProgram_class, js_cocos2d_GLProgram_finalize)

static bool js_cocos2dx_GLProgram_ctor(se::State& s)
{
    cocos2d::GLProgram* cobj = new (std::nothrow) cocos2d::GLProgram();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_GLProgram_ctor, __jsb_cocos2d_GLProgram_class, js_cocos2d_GLProgram_finalize)


    


static bool js_cocos2d_GLProgram_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::GLProgram)", s.nativeThisObject());
    cocos2d::GLProgram* cobj = (cocos2d::GLProgram*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_GLProgram_finalize)

bool js_register_cocos2dx_GLProgram(se::Object* obj)
{
    auto cls = se::Class::create("GLProgram", obj, nullptr, _SE(js_cocos2dx_GLProgram_constructor));

    cls->defineFunction("getFragmentShaderLog", _SE(js_cocos2dx_GLProgram_getFragmentShaderLog));
    cls->defineFunction("addAttribute", _SE(js_cocos2dx_GLProgram_bindAttribLocation));
    cls->defineFunction("getUniformLocationForName", _SE(js_cocos2dx_GLProgram_getUniformLocationForName));
    cls->defineFunction("use", _SE(js_cocos2dx_GLProgram_use));
    cls->defineFunction("getVertexShaderLog", _SE(js_cocos2dx_GLProgram_getVertexShaderLog));
    cls->defineFunction("getUniform", _SE(js_cocos2dx_GLProgram_getUniform));
    cls->defineFunction("initWithString", _SE(js_cocos2dx_GLProgram_initWithByteArrays));
    cls->defineFunction("getProgram", _SE(js_cocos2dx_GLProgram_getProgram));
    cls->defineFunction("setUniformLocationF32", _SE(js_cocos2dx_GLProgram_setUniformLocationWith2f));
    cls->defineFunction("init", _SE(js_cocos2dx_GLProgram_initWithFilenames));
    cls->defineFunction("setUniformsForBuiltins", _SE(js_cocos2dx_GLProgram_setUniformsForBuiltins));
    cls->defineFunction("updateUniforms", _SE(js_cocos2dx_GLProgram_updateUniforms));
    cls->defineFunction("link", _SE(js_cocos2dx_GLProgram_link));
    cls->defineFunction("reset", _SE(js_cocos2dx_GLProgram_reset));
    cls->defineFunction("getProgramLog", _SE(js_cocos2dx_GLProgram_getProgramLog));
    cls->defineFunction("getAttribLocation", _SE(js_cocos2dx_GLProgram_getAttribLocation));
    cls->defineFunction("getUniformLocation", _SE(js_cocos2dx_GLProgram_getUniformLocation));
    cls->defineFunction("setUniformLocationI32", _SE(js_cocos2dx_GLProgram_setUniformLocationWith2i));
    cls->defineFunction("ctor", _SE(js_cocos2dx_GLProgram_ctor));
    cls->defineStaticFunction("createWithByteArrays", _SE(js_cocos2dx_GLProgram_createWithByteArrays));
    cls->defineStaticFunction("createWithFilenames", _SE(js_cocos2dx_GLProgram_createWithFilenames));
    cls->defineFinalizeFunction(_SE(js_cocos2d_GLProgram_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgram>(cls);

    __jsb_cocos2d_GLProgram_proto = cls->getProto();
    __jsb_cocos2d_GLProgram_class = cls;

    jsb_set_extend_property("cc", "GLProgram");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_GLProgramCache_proto = nullptr;
se::Class* __jsb_cocos2d_GLProgramCache_class = nullptr;

static bool js_cocos2dx_GLProgramCache_notifyAllGLProgramsCreated(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_notifyAllGLProgramsCreated : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->notifyAllGLProgramsCreated();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_notifyAllGLProgramsCreated)

static bool js_cocos2dx_GLProgramCache_loadDefaultGLPrograms(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_loadDefaultGLPrograms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->loadDefaultGLPrograms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_loadDefaultGLPrograms)

static bool js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reloadDefaultGLProgramsRelativeToLights();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights)

static bool js_cocos2dx_GLProgramCache_addGLProgram(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_addGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::GLProgram* arg0 = nullptr;
        std::string arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_addGLProgram : Error processing arguments");
        cobj->addGLProgram(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_addGLProgram)

static bool js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->reloadDefaultGLPrograms();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms)

static bool js_cocos2dx_GLProgramCache_getGLProgram(se::State& s)
{
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_GLProgramCache_getGLProgram : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_getGLProgram : Error processing arguments");
        cocos2d::GLProgram* result = cobj->getGLProgram(arg0);
        ok &= native_ptr_to_seval<cocos2d::GLProgram>((cocos2d::GLProgram*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_GLProgramCache_getGLProgram : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_getGLProgram)

static bool js_cocos2dx_GLProgramCache_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::GLProgramCache::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_destroyInstance)

static bool js_cocos2dx_GLProgramCache_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::GLProgramCache::getInstance();
        se::Value instanceVal;
        native_ptr_to_seval<cocos2d::GLProgramCache>(result, __jsb_cocos2d_GLProgramCache_class, &instanceVal);
        instanceVal.toObject()->root();
        s.rval() = instanceVal;
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_GLProgramCache_getInstance)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_GLProgramCache_finalize)

static bool js_cocos2dx_GLProgramCache_constructor(se::State& s)
{
    cocos2d::GLProgramCache* cobj = new (std::nothrow) cocos2d::GLProgramCache();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_GLProgramCache_constructor, __jsb_cocos2d_GLProgramCache_class, js_cocos2d_GLProgramCache_finalize)




static bool js_cocos2d_GLProgramCache_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::GLProgramCache)", s.nativeThisObject());
    cocos2d::GLProgramCache* cobj = (cocos2d::GLProgramCache*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_GLProgramCache_finalize)

bool js_register_cocos2dx_GLProgramCache(se::Object* obj)
{
    auto cls = se::Class::create("ShaderCache", obj, nullptr, _SE(js_cocos2dx_GLProgramCache_constructor));

    cls->defineFunction("notifyAllGLProgramsCreated", _SE(js_cocos2dx_GLProgramCache_notifyAllGLProgramsCreated));
    cls->defineFunction("loadDefaultShaders", _SE(js_cocos2dx_GLProgramCache_loadDefaultGLPrograms));
    cls->defineFunction("reloadDefaultGLProgramsRelativeToLights", _SE(js_cocos2dx_GLProgramCache_reloadDefaultGLProgramsRelativeToLights));
    cls->defineFunction("addProgram", _SE(js_cocos2dx_GLProgramCache_addGLProgram));
    cls->defineFunction("reloadDefaultShaders", _SE(js_cocos2dx_GLProgramCache_reloadDefaultGLPrograms));
    cls->defineFunction("getProgram", _SE(js_cocos2dx_GLProgramCache_getGLProgram));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_GLProgramCache_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_GLProgramCache_getInstance));
    cls->defineFinalizeFunction(_SE(js_cocos2d_GLProgramCache_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::GLProgramCache>(cls);

    __jsb_cocos2d_GLProgramCache_proto = cls->getProto();
    __jsb_cocos2d_GLProgramCache_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TextureCache_proto = nullptr;
se::Class* __jsb_cocos2d_TextureCache_class = nullptr;

static bool js_cocos2dx_TextureCache_reloadTexture(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_reloadTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_reloadTexture : Error processing arguments");
        bool result = cobj->reloadTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_reloadTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_reloadTexture)

static bool js_cocos2dx_TextureCache_unbindAllImageAsync(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_unbindAllImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->unbindAllImageAsync();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_unbindAllImageAsync)

static bool js_cocos2dx_TextureCache_removeTextureForKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeTextureForKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_removeTextureForKey : Error processing arguments");
        cobj->removeTextureForKey(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeTextureForKey)

static bool js_cocos2dx_TextureCache_removeAllTextures(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeAllTextures : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeAllTextures();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeAllTextures)

static bool js_cocos2dx_TextureCache_addImageAsync(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_addImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::function<void (cocos2d::Texture2D *)> arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        do {
            if (args[1].isObject() && args[1].toObject()->isFunction())
            {
                se::Value jsThis(s.thisObject());
                se::Value jsFunc(args[1]);
                jsFunc.toObject()->root();
                auto lambda = [=](cocos2d::Texture2D* larg0) -> void {
                    se::ScriptEngine::getInstance()->clearException();
                    se::AutoHandleScope hs;
        
                    CC_UNUSED bool ok = true;
                    se::ValueArray args;
                    args.resize(1);
                    ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)larg0, &args[0]);
                    se::Value rval;
                    se::Object* thisObj = jsThis.isObject() ? jsThis.toObject() : nullptr;
                    se::Object* funcObj = jsFunc.toObject();
                    bool succeed = funcObj->call(args, thisObj, &rval);
                    if (!succeed) {
                        se::ScriptEngine::getInstance()->clearException();
                    }
                };
                arg1 = lambda;
            }
            else
            {
                arg1 = nullptr;
            }
        } while(false)
        ;
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_addImageAsync : Error processing arguments");
        cobj->addImageAsync(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_addImageAsync)

static bool js_cocos2dx_TextureCache_getAllTextures(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getAllTextures : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vector<cocos2d::Texture2D *> result = cobj->getAllTextures();
        ok &= Vector_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getAllTextures : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getAllTextures)

static bool js_cocos2dx_TextureCache_getDescription(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getDescription : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getDescription();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getDescription : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getDescription)

static bool js_cocos2dx_TextureCache_getCachedTextureInfo(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getCachedTextureInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getCachedTextureInfo();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getCachedTextureInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getCachedTextureInfo)

static bool js_cocos2dx_TextureCache_addImage(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TextureCache_addImage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            cocos2d::Image* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* result = cobj->addImage(arg0, arg1);
            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_addImage : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* result = cobj->addImage(arg0);
            ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_addImage : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_addImage)

static bool js_cocos2dx_TextureCache_unbindImageAsync(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_unbindImageAsync : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_unbindImageAsync : Error processing arguments");
        cobj->unbindImageAsync(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_unbindImageAsync)

static bool js_cocos2dx_TextureCache_getTextureForKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getTextureForKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureForKey : Error processing arguments");
        cocos2d::Texture2D* result = cobj->getTextureForKey(arg0);
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureForKey : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getTextureForKey)

static bool js_cocos2dx_TextureCache_getTextureFilePath(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_getTextureFilePath : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureFilePath : Error processing arguments");
        std::string result = cobj->getTextureFilePath(arg0);
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_getTextureFilePath : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_getTextureFilePath)

static bool js_cocos2dx_TextureCache_renameTextureWithKey(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_renameTextureWithKey : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_renameTextureWithKey : Error processing arguments");
        cobj->renameTextureWithKey(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_renameTextureWithKey)

static bool js_cocos2dx_TextureCache_removeUnusedTextures(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeUnusedTextures : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeUnusedTextures();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeUnusedTextures)

static bool js_cocos2dx_TextureCache_removeTexture(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_removeTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextureCache_removeTexture : Error processing arguments");
        cobj->removeTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_removeTexture)

static bool js_cocos2dx_TextureCache_waitForQuit(se::State& s)
{
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextureCache_waitForQuit : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->waitForQuit();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextureCache_waitForQuit)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TextureCache_finalize)

static bool js_cocos2dx_TextureCache_constructor(se::State& s)
{
    cocos2d::TextureCache* cobj = new (std::nothrow) cocos2d::TextureCache();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TextureCache_constructor, __jsb_cocos2d_TextureCache_class, js_cocos2d_TextureCache_finalize)




static bool js_cocos2d_TextureCache_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TextureCache)", s.nativeThisObject());
    cocos2d::TextureCache* cobj = (cocos2d::TextureCache*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TextureCache_finalize)

bool js_register_cocos2dx_TextureCache(se::Object* obj)
{
    auto cls = se::Class::create("TextureCache", obj, nullptr, _SE(js_cocos2dx_TextureCache_constructor));

    cls->defineFunction("reloadTexture", _SE(js_cocos2dx_TextureCache_reloadTexture));
    cls->defineFunction("unbindAllImageAsync", _SE(js_cocos2dx_TextureCache_unbindAllImageAsync));
    cls->defineFunction("removeTextureForKey", _SE(js_cocos2dx_TextureCache_removeTextureForKey));
    cls->defineFunction("removeAllTextures", _SE(js_cocos2dx_TextureCache_removeAllTextures));
    cls->defineFunction("addImageAsync", _SE(js_cocos2dx_TextureCache_addImageAsync));
    cls->defineFunction("getAllTextures", _SE(js_cocos2dx_TextureCache_getAllTextures));
    cls->defineFunction("getDescription", _SE(js_cocos2dx_TextureCache_getDescription));
    cls->defineFunction("getCachedTextureInfo", _SE(js_cocos2dx_TextureCache_getCachedTextureInfo));
    cls->defineFunction("addImage", _SE(js_cocos2dx_TextureCache_addImage));
    cls->defineFunction("unbindImageAsync", _SE(js_cocos2dx_TextureCache_unbindImageAsync));
    cls->defineFunction("getTextureForKey", _SE(js_cocos2dx_TextureCache_getTextureForKey));
    cls->defineFunction("getTextureFilePath", _SE(js_cocos2dx_TextureCache_getTextureFilePath));
    cls->defineFunction("renameTextureWithKey", _SE(js_cocos2dx_TextureCache_renameTextureWithKey));
    cls->defineFunction("removeUnusedTextures", _SE(js_cocos2dx_TextureCache_removeUnusedTextures));
    cls->defineFunction("removeTexture", _SE(js_cocos2dx_TextureCache_removeTexture));
    cls->defineFunction("waitForQuit", _SE(js_cocos2dx_TextureCache_waitForQuit));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TextureCache_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TextureCache>(cls);

    __jsb_cocos2d_TextureCache_proto = cls->getProto();
    __jsb_cocos2d_TextureCache_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Device_proto = nullptr;
se::Class* __jsb_cocos2d_Device_class = nullptr;

static bool js_cocos2dx_Device_setAccelerometerEnabled(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Device_setAccelerometerEnabled : Error processing arguments");
        cocos2d::Device::setAccelerometerEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setAccelerometerEnabled)

static bool js_cocos2dx_Device_setAccelerometerInterval(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Device_setAccelerometerInterval : Error processing arguments");
        cocos2d::Device::setAccelerometerInterval(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setAccelerometerInterval)

static bool js_cocos2dx_Device_setKeepScreenOn(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Device_setKeepScreenOn : Error processing arguments");
        cocos2d::Device::setKeepScreenOn(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_setKeepScreenOn)

static bool js_cocos2dx_Device_vibrate(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        float arg0 = 0;
        ok &= seval_to_float(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Device_vibrate : Error processing arguments");
        cocos2d::Device::vibrate(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_vibrate)

static bool js_cocos2dx_Device_getDPI(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cocos2d::Device::getDPI();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Device_getDPI : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Device_getDPI)




bool js_register_cocos2dx_Device(se::Object* obj)
{
    auto cls = se::Class::create("Device", obj, nullptr, nullptr);

    cls->defineStaticFunction("setAccelerometerEnabled", _SE(js_cocos2dx_Device_setAccelerometerEnabled));
    cls->defineStaticFunction("setAccelerometerInterval", _SE(js_cocos2dx_Device_setAccelerometerInterval));
    cls->defineStaticFunction("setKeepScreenOn", _SE(js_cocos2dx_Device_setKeepScreenOn));
    cls->defineStaticFunction("vibrate", _SE(js_cocos2dx_Device_vibrate));
    cls->defineStaticFunction("getDPI", _SE(js_cocos2dx_Device_getDPI));
    cls->install();
    JSBClassType::registerClass<cocos2d::Device>(cls);

    __jsb_cocos2d_Device_proto = cls->getProto();
    __jsb_cocos2d_Device_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SAXParser_proto = nullptr;
se::Class* __jsb_cocos2d_SAXParser_class = nullptr;

static bool js_cocos2dx_SAXParser_init(se::State& s)
{
    cocos2d::SAXParser* cobj = (cocos2d::SAXParser*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SAXParser_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        const char* arg0 = nullptr;
        std::string arg0_tmp; ok &= seval_to_std_string(args[0], &arg0_tmp); arg0 = arg0_tmp.c_str();
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SAXParser_init : Error processing arguments");
        bool result = cobj->init(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SAXParser_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SAXParser_init)




bool js_register_cocos2dx_SAXParser(se::Object* obj)
{
    auto cls = se::Class::create("PlistParser", obj, nullptr, nullptr);

    cls->defineFunction("init", _SE(js_cocos2dx_SAXParser_init));
    cls->install();
    JSBClassType::registerClass<cocos2d::SAXParser>(cls);

    __jsb_cocos2d_SAXParser_proto = cls->getProto();
    __jsb_cocos2d_SAXParser_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_Application_proto = nullptr;
se::Class* __jsb_cocos2d_Application_class = nullptr;

static bool js_cocos2dx_Application_getTargetPlatform(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getTargetPlatform : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getTargetPlatform();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_getTargetPlatform : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getTargetPlatform)

static bool js_cocos2dx_Application_getCurrentLanguage(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getCurrentLanguage : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getCurrentLanguage();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_getCurrentLanguage : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getCurrentLanguage)

static bool js_cocos2dx_Application_openURL(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Application_openURL : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_openURL : Error processing arguments");
        bool result = cobj->openURL(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_openURL : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_openURL)

static bool js_cocos2dx_Application_getVersion(se::State& s)
{
    cocos2d::Application* cobj = (cocos2d::Application*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_Application_getVersion : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getVersion();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_getVersion : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getVersion)

static bool js_cocos2dx_Application_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::Application::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_destroyInstance)

static bool js_cocos2dx_Application_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Application* result = cocos2d::Application::getInstance();
        ok &= native_ptr_to_seval<cocos2d::Application>((cocos2d::Application*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_Application_getInstance : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_Application_getInstance)




bool js_register_cocos2dx_Application(se::Object* obj)
{
    auto cls = se::Class::create("Application", obj, nullptr, nullptr);

    cls->defineFunction("getTargetPlatform", _SE(js_cocos2dx_Application_getTargetPlatform));
    cls->defineFunction("getCurrentLanguage", _SE(js_cocos2dx_Application_getCurrentLanguage));
    cls->defineFunction("openURL", _SE(js_cocos2dx_Application_openURL));
    cls->defineFunction("getVersion", _SE(js_cocos2dx_Application_getVersion));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_Application_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_Application_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::Application>(cls);

    __jsb_cocos2d_Application_proto = cls->getProto();
    __jsb_cocos2d_Application_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SpriteBatchNode_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteBatchNode_class = nullptr;

static bool js_cocos2dx_SpriteBatchNode_appendChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_appendChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_appendChild : Error processing arguments");
        cobj->appendChild(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_appendChild)

static bool js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::Sprite* arg0 = nullptr;
        int arg1 = 0;
        int arg2 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Error processing arguments");
        cocos2d::SpriteBatchNode* result = cobj->addSpriteWithoutQuad(arg0, arg1, arg2);
        ok &= native_ptr_to_seval<cocos2d::SpriteBatchNode>((cocos2d::SpriteBatchNode*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad)

static bool js_cocos2dx_SpriteBatchNode_reorderBatch(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_reorderBatch : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_reorderBatch : Error processing arguments");
        cobj->reorderBatch(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_reorderBatch)

static bool js_cocos2dx_SpriteBatchNode_initWithTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        bool result = cobj->initWithTexture(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_initWithTexture)

static bool js_cocos2dx_SpriteBatchNode_getBlendFunc(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_getBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::BlendFunc& result = cobj->getBlendFunc();
        ok &= blendfunc_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_getBlendFunc : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_getBlendFunc)

static bool js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Error processing arguments");
        ssize_t result = cobj->lowestAtlasIndexInChild(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild)

static bool js_cocos2dx_SpriteBatchNode_atlasIndexForChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        int arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_int32(args[1], (int32_t*)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Error processing arguments");
        ssize_t result = cobj->atlasIndexForChild(arg0, arg1);
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_atlasIndexForChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_atlasIndexForChild)

static bool js_cocos2dx_SpriteBatchNode_setTextureAtlas(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setTextureAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TextureAtlas* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setTextureAtlas : Error processing arguments");
        cobj->setTextureAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setTextureAtlas)

static bool js_cocos2dx_SpriteBatchNode_initWithFile(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        bool result = cobj->initWithFile(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_initWithFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_initWithFile)

static bool js_cocos2dx_SpriteBatchNode_getTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_getTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Texture2D* result = cobj->getTexture();
        ok &= native_ptr_to_seval<cocos2d::Texture2D>((cocos2d::Texture2D*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_getTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_getTexture)

static bool js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->increaseAtlasCapacity();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity)

static bool js_cocos2dx_SpriteBatchNode_insertQuadFromSprite(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_insertQuadFromSprite : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_insertQuadFromSprite : Error processing arguments");
        cobj->insertQuadFromSprite(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_insertQuadFromSprite)

static bool js_cocos2dx_SpriteBatchNode_setTexture(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setTexture : Error processing arguments");
        cobj->setTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setTexture)

static bool js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Sprite* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Error processing arguments");
        ssize_t result = cobj->rebuildIndexInOrder(arg0, arg1);
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder)

static bool js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Error processing arguments");
        ssize_t result = cobj->highestAtlasIndexInChild(arg0);
        ok &= ssize_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild)

static bool js_cocos2dx_SpriteBatchNode_removeChildAtIndex(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_removeChildAtIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        ssize_t arg0 = 0;
        bool arg1;
        ok &= seval_to_ssize(args[0], &arg0);
        ok &= seval_to_boolean(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_removeChildAtIndex : Error processing arguments");
        cobj->removeChildAtIndex(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_removeChildAtIndex)

static bool js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Sprite* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas : Error processing arguments");
        cobj->removeSpriteFromAtlas(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas)

static bool js_cocos2dx_SpriteBatchNode_setBlendFunc(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteBatchNode_setBlendFunc : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::BlendFunc arg0;
        ok &= seval_to_blendfunc(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_setBlendFunc : Error processing arguments");
        cobj->setBlendFunc(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_setBlendFunc)

static bool js_cocos2dx_SpriteBatchNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_create : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        std::string arg0;
        ssize_t arg1 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_create : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::create(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_create)

static bool js_cocos2dx_SpriteBatchNode_createWithTexture(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::createWithTexture(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    if (argc == 2) {
        cocos2d::Texture2D* arg0 = nullptr;
        ssize_t arg1 = 0;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_ssize(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteBatchNode_createWithTexture : Error processing arguments");
        auto result = cocos2d::SpriteBatchNode::createWithTexture(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_SpriteBatchNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteBatchNode_createWithTexture)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_SpriteBatchNode_finalize)

static bool js_cocos2dx_SpriteBatchNode_constructor(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = new (std::nothrow) cocos2d::SpriteBatchNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_SpriteBatchNode_constructor, __jsb_cocos2d_SpriteBatchNode_class, js_cocos2d_SpriteBatchNode_finalize)

static bool js_cocos2dx_SpriteBatchNode_ctor(se::State& s)
{
    cocos2d::SpriteBatchNode* cobj = new (std::nothrow) cocos2d::SpriteBatchNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_SpriteBatchNode_ctor, __jsb_cocos2d_SpriteBatchNode_class, js_cocos2d_SpriteBatchNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_SpriteBatchNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::SpriteBatchNode)", s.nativeThisObject());
    cocos2d::SpriteBatchNode* cobj = (cocos2d::SpriteBatchNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_SpriteBatchNode_finalize)

bool js_register_cocos2dx_SpriteBatchNode(se::Object* obj)
{
    auto cls = se::Class::create("SpriteBatchNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_SpriteBatchNode_constructor));

    cls->defineFunction("appendChild", _SE(js_cocos2dx_SpriteBatchNode_appendChild));
    cls->defineFunction("addSpriteWithoutQuad", _SE(js_cocos2dx_SpriteBatchNode_addSpriteWithoutQuad));
    cls->defineFunction("reorderBatch", _SE(js_cocos2dx_SpriteBatchNode_reorderBatch));
    cls->defineFunction("initWithTexture", _SE(js_cocos2dx_SpriteBatchNode_initWithTexture));
    cls->defineFunction("getBlendFunc", _SE(js_cocos2dx_SpriteBatchNode_getBlendFunc));
    cls->defineFunction("lowestAtlasIndexInChild", _SE(js_cocos2dx_SpriteBatchNode_lowestAtlasIndexInChild));
    cls->defineFunction("atlasIndexForChild", _SE(js_cocos2dx_SpriteBatchNode_atlasIndexForChild));
    cls->defineFunction("setTextureAtlas", _SE(js_cocos2dx_SpriteBatchNode_setTextureAtlas));
    cls->defineFunction("initWithFile", _SE(js_cocos2dx_SpriteBatchNode_initWithFile));
    cls->defineFunction("getTexture", _SE(js_cocos2dx_SpriteBatchNode_getTexture));
    cls->defineFunction("increaseAtlasCapacity", _SE(js_cocos2dx_SpriteBatchNode_increaseAtlasCapacity));
    cls->defineFunction("insertQuadFromSprite", _SE(js_cocos2dx_SpriteBatchNode_insertQuadFromSprite));
    cls->defineFunction("setTexture", _SE(js_cocos2dx_SpriteBatchNode_setTexture));
    cls->defineFunction("rebuildIndexInOrder", _SE(js_cocos2dx_SpriteBatchNode_rebuildIndexInOrder));
    cls->defineFunction("highestAtlasIndexInChild", _SE(js_cocos2dx_SpriteBatchNode_highestAtlasIndexInChild));
    cls->defineFunction("removeChildAtIndex", _SE(js_cocos2dx_SpriteBatchNode_removeChildAtIndex));
    cls->defineFunction("removeSpriteFromAtlas", _SE(js_cocos2dx_SpriteBatchNode_removeSpriteFromAtlas));
    cls->defineFunction("setBlendFunc", _SE(js_cocos2dx_SpriteBatchNode_setBlendFunc));
    cls->defineFunction("ctor", _SE(js_cocos2dx_SpriteBatchNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_SpriteBatchNode_create));
    cls->defineStaticFunction("createWithTexture", _SE(js_cocos2dx_SpriteBatchNode_createWithTexture));
    cls->defineFinalizeFunction(_SE(js_cocos2d_SpriteBatchNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteBatchNode>(cls);

    __jsb_cocos2d_SpriteBatchNode_proto = cls->getProto();
    __jsb_cocos2d_SpriteBatchNode_class = cls;

    jsb_set_extend_property("cc", "SpriteBatchNode");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_SpriteFrameCache_proto = nullptr;
se::Class* __jsb_cocos2d_SpriteFrameCache_class = nullptr;

static bool js_cocos2dx_SpriteFrameCache_reloadTexture(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Error processing arguments");
        bool result = cobj->reloadTexture(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_reloadTexture : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_reloadTexture)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        cocos2d::Texture2D* arg1 = nullptr;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent : Error processing arguments");
        cobj->addSpriteFramesWithFileContent(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFrame(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFrame : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::SpriteFrame* arg0 = nullptr;
        std::string arg1;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_addSpriteFrame : Error processing arguments");
        cobj->addSpriteFrame(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFrame)

static bool js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Texture2D* arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->addSpriteFramesWithFile(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile)

static bool js_cocos2dx_SpriteFrameCache_getSpriteFrameByName(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Error processing arguments");
        cocos2d::SpriteFrame* result = cobj->getSpriteFrameByName(arg0);
        ok &= native_ptr_to_seval<cocos2d::SpriteFrame>((cocos2d::SpriteFrame*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_getSpriteFrameByName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_getSpriteFrameByName)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile : Error processing arguments");
        cobj->removeSpriteFramesFromFile(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile)

static bool js_cocos2dx_SpriteFrameCache_init(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_init : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->init();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_init : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_init)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFrames(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeSpriteFrames();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFrames)

static bool js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->removeUnusedSpriteFrames();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent : Error processing arguments");
        cobj->removeSpriteFramesFromFileContent(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName : Error processing arguments");
        cobj->removeSpriteFrameByName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName)

static bool js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Error processing arguments");
        bool result = cobj->isSpriteFramesWithFileLoaded(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded)

static bool js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture(se::State& s)
{
    cocos2d::SpriteFrameCache* cobj = (cocos2d::SpriteFrameCache*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Texture2D* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture : Error processing arguments");
        cobj->removeSpriteFramesFromTexture(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture)

static bool js_cocos2dx_SpriteFrameCache_destroyInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cocos2d::SpriteFrameCache::destroyInstance();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_destroyInstance)

static bool js_cocos2dx_SpriteFrameCache_getInstance(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::SpriteFrameCache::getInstance();
        se::Value instanceVal;
        native_ptr_to_seval<cocos2d::SpriteFrameCache>(result, __jsb_cocos2d_SpriteFrameCache_class, &instanceVal);
        instanceVal.toObject()->root();
        s.rval() = instanceVal;
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_SpriteFrameCache_getInstance)




bool js_register_cocos2dx_SpriteFrameCache(se::Object* obj)
{
    auto cls = se::Class::create("SpriteFrameCache", obj, nullptr, nullptr);

    cls->defineFunction("reloadTexture", _SE(js_cocos2dx_SpriteFrameCache_reloadTexture));
    cls->defineFunction("addSpriteFramesWithFileContent", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFileContent));
    cls->defineFunction("addSpriteFrame", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFrame));
    cls->defineFunction("addSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_addSpriteFramesWithFile));
    cls->defineFunction("getSpriteFrame", _SE(js_cocos2dx_SpriteFrameCache_getSpriteFrameByName));
    cls->defineFunction("removeSpriteFramesFromFile", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFile));
    cls->defineFunction("init", _SE(js_cocos2dx_SpriteFrameCache_init));
    cls->defineFunction("removeSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFrames));
    cls->defineFunction("removeUnusedSpriteFrames", _SE(js_cocos2dx_SpriteFrameCache_removeUnusedSpriteFrames));
    cls->defineFunction("removeSpriteFramesFromFileContent", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromFileContent));
    cls->defineFunction("removeSpriteFrameByName", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFrameByName));
    cls->defineFunction("isSpriteFramesWithFileLoaded", _SE(js_cocos2dx_SpriteFrameCache_isSpriteFramesWithFileLoaded));
    cls->defineFunction("removeSpriteFramesFromTexture", _SE(js_cocos2dx_SpriteFrameCache_removeSpriteFramesFromTexture));
    cls->defineStaticFunction("destroyInstance", _SE(js_cocos2dx_SpriteFrameCache_destroyInstance));
    cls->defineStaticFunction("getInstance", _SE(js_cocos2dx_SpriteFrameCache_getInstance));
    cls->install();
    JSBClassType::registerClass<cocos2d::SpriteFrameCache>(cls);

    __jsb_cocos2d_SpriteFrameCache_proto = cls->getProto();
    __jsb_cocos2d_SpriteFrameCache_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TextFieldTTF_proto = nullptr;
se::Class* __jsb_cocos2d_TextFieldTTF_class = nullptr;

static bool js_cocos2dx_TextFieldTTF_getCharCount(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getCharCount : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned long result = cobj->getCharCount();
        ok &= ulong_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getCharCount : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getCharCount)

static bool js_cocos2dx_TextFieldTTF_setCursorChar(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorChar : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int8_t arg0;
        ok &= seval_to_int8(args[0], (int8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorChar : Error processing arguments");
        cobj->setCursorChar(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorChar)

static bool js_cocos2dx_TextFieldTTF_setSecureTextEntry(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setSecureTextEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setSecureTextEntry : Error processing arguments");
        cobj->setSecureTextEntry(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setSecureTextEntry)

static bool js_cocos2dx_TextFieldTTF_setCursorEnabled(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorEnabled : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorEnabled : Error processing arguments");
        cobj->setCursorEnabled(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorEnabled)

static bool js_cocos2dx_TextFieldTTF_getColorSpaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getColorSpaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Color4B& result = cobj->getColorSpaceHolder();
        ok &= Color4B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getColorSpaceHolder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getColorSpaceHolder)

static bool js_cocos2dx_TextFieldTTF_initWithPlaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithPlaceHolder(arg0, arg1, arg2);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            bool result = cobj->initWithPlaceHolder(arg0, arg1, arg2, arg3, arg4);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_initWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_initWithPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_appendString(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_appendString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_appendString : Error processing arguments");
        cobj->appendString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_appendString)

static bool js_cocos2dx_TextFieldTTF_getPasswordTextStyle(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getPasswordTextStyle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        std::string result = cobj->getPasswordTextStyle();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getPasswordTextStyle : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getPasswordTextStyle)

static bool js_cocos2dx_TextFieldTTF_setPasswordTextStyle(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setPasswordTextStyle : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setPasswordTextStyle : Error processing arguments");
        cobj->setPasswordTextStyle(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setPasswordTextStyle)

static bool js_cocos2dx_TextFieldTTF_setColorSpaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TextFieldTTF_setColorSpaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 1) {
            cocos2d::Color4B arg0;
            ok &= seval_to_Color4B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setColorSpaceHolder(arg0);
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            cocos2d::Color3B arg0;
            ok &= seval_to_Color3B(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cobj->setColorSpaceHolder(arg0);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setColorSpaceHolder)

static bool js_cocos2dx_TextFieldTTF_detachWithIME(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_detachWithIME : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->detachWithIME();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_detachWithIME : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_detachWithIME)

static bool js_cocos2dx_TextFieldTTF_setPlaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setPlaceHolder : Error processing arguments");
        cobj->setPlaceHolder(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_setCursorFromPoint(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorFromPoint : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorFromPoint : Error processing arguments");
        cobj->setCursorFromPoint(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorFromPoint)

static bool js_cocos2dx_TextFieldTTF_isSecureTextEntry(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_isSecureTextEntry : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isSecureTextEntry();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_isSecureTextEntry : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_isSecureTextEntry)

static bool js_cocos2dx_TextFieldTTF_getPlaceHolder(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_getPlaceHolder : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getPlaceHolder();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_getPlaceHolder : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_getPlaceHolder)

static bool js_cocos2dx_TextFieldTTF_setCursorPosition(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_setCursorPosition : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned long arg0 = 0;
        ok &= seval_to_ulong(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_setCursorPosition : Error processing arguments");
        cobj->setCursorPosition(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_setCursorPosition)

static bool js_cocos2dx_TextFieldTTF_attachWithIME(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TextFieldTTF_attachWithIME : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->attachWithIME();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_attachWithIME : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_attachWithIME)

static bool js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            std::string arg1;
            ok &= seval_to_std_string(args[1], &arg1);
            if (!ok) { ok = true; break; }
            float arg2 = 0;
            ok &= seval_to_float(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::TextFieldTTF* result = cocos2d::TextFieldTTF::textFieldWithPlaceHolder(arg0, arg1, arg2);
            ok &= native_ptr_to_seval<cocos2d::TextFieldTTF>((cocos2d::TextFieldTTF*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while (false);
    do {
        if (argc == 5) {
            std::string arg0;
            ok &= seval_to_std_string(args[0], &arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Size arg1;
            ok &= seval_to_Size(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TextHAlignment arg2;
            ok &= seval_to_int8(args[2], (int8_t*)&arg2);
            if (!ok) { ok = true; break; }
            std::string arg3;
            ok &= seval_to_std_string(args[3], &arg3);
            if (!ok) { ok = true; break; }
            float arg4 = 0;
            ok &= seval_to_float(args[4], &arg4);
            if (!ok) { ok = true; break; }
            cocos2d::TextFieldTTF* result = cocos2d::TextFieldTTF::textFieldWithPlaceHolder(arg0, arg1, arg2, arg3, arg4);
            ok &= native_ptr_to_seval<cocos2d::TextFieldTTF>((cocos2d::TextFieldTTF*)result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder : Error processing arguments");
            return true;
        }
    } while (false);
    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TextFieldTTF_finalize)

static bool js_cocos2dx_TextFieldTTF_constructor(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = new (std::nothrow) cocos2d::TextFieldTTF();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TextFieldTTF_constructor, __jsb_cocos2d_TextFieldTTF_class, js_cocos2d_TextFieldTTF_finalize)

static bool js_cocos2dx_TextFieldTTF_ctor(se::State& s)
{
    cocos2d::TextFieldTTF* cobj = new (std::nothrow) cocos2d::TextFieldTTF();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TextFieldTTF_ctor, __jsb_cocos2d_TextFieldTTF_class, js_cocos2d_TextFieldTTF_finalize)


    

extern se::Object* __jsb_cocos2d_Label_proto;

static bool js_cocos2d_TextFieldTTF_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TextFieldTTF)", s.nativeThisObject());
    cocos2d::TextFieldTTF* cobj = (cocos2d::TextFieldTTF*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TextFieldTTF_finalize)

bool js_register_cocos2dx_TextFieldTTF(se::Object* obj)
{
    auto cls = se::Class::create("TextFieldTTF", obj, __jsb_cocos2d_Label_proto, _SE(js_cocos2dx_TextFieldTTF_constructor));

    cls->defineFunction("getCharCount", _SE(js_cocos2dx_TextFieldTTF_getCharCount));
    cls->defineFunction("setCursorChar", _SE(js_cocos2dx_TextFieldTTF_setCursorChar));
    cls->defineFunction("setSecureTextEntry", _SE(js_cocos2dx_TextFieldTTF_setSecureTextEntry));
    cls->defineFunction("setCursorEnabled", _SE(js_cocos2dx_TextFieldTTF_setCursorEnabled));
    cls->defineFunction("getColorSpaceHolder", _SE(js_cocos2dx_TextFieldTTF_getColorSpaceHolder));
    cls->defineFunction("initWithPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_initWithPlaceHolder));
    cls->defineFunction("appendString", _SE(js_cocos2dx_TextFieldTTF_appendString));
    cls->defineFunction("getPasswordTextStyle", _SE(js_cocos2dx_TextFieldTTF_getPasswordTextStyle));
    cls->defineFunction("setPasswordTextStyle", _SE(js_cocos2dx_TextFieldTTF_setPasswordTextStyle));
    cls->defineFunction("setColorSpaceHolder", _SE(js_cocos2dx_TextFieldTTF_setColorSpaceHolder));
    cls->defineFunction("detachWithIME", _SE(js_cocos2dx_TextFieldTTF_detachWithIME));
    cls->defineFunction("setPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_setPlaceHolder));
    cls->defineFunction("setCursorFromPoint", _SE(js_cocos2dx_TextFieldTTF_setCursorFromPoint));
    cls->defineFunction("isSecureTextEntry", _SE(js_cocos2dx_TextFieldTTF_isSecureTextEntry));
    cls->defineFunction("getPlaceHolder", _SE(js_cocos2dx_TextFieldTTF_getPlaceHolder));
    cls->defineFunction("setCursorPosition", _SE(js_cocos2dx_TextFieldTTF_setCursorPosition));
    cls->defineFunction("attachWithIME", _SE(js_cocos2dx_TextFieldTTF_attachWithIME));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TextFieldTTF_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TextFieldTTF_textFieldWithPlaceHolder));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TextFieldTTF_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TextFieldTTF>(cls);

    __jsb_cocos2d_TextFieldTTF_proto = cls->getProto();
    __jsb_cocos2d_TextFieldTTF_class = cls;

    jsb_set_extend_property("cc", "TextFieldTTF");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_ParallaxNode_proto = nullptr;
se::Class* __jsb_cocos2d_ParallaxNode_class = nullptr;

static bool js_cocos2dx_ParallaxNode_addChild(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_ParallaxNode_addChild : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 4) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg2;
            ok &= seval_to_Vec2(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg3;
            ok &= seval_to_Vec2(args[3], &arg3);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2, arg3);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            int arg2 = 0;
            ok &= seval_to_int32(args[2], (int32_t*)&arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 3) {
            cocos2d::Node* arg0 = nullptr;
            ok &= seval_to_native_ptr(args[0], &arg0);
            if (!ok) { ok = true; break; }
            int arg1 = 0;
            ok &= seval_to_int32(args[1], (int32_t*)&arg1);
            if (!ok) { ok = true; break; }
            std::string arg2;
            ok &= seval_to_std_string(args[2], &arg2);
            if (!ok) { ok = true; break; }
            cobj->addChild(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_addChild)

static bool js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup(se::State& s)
{
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup : Error processing arguments");
        cobj->removeAllChildrenWithCleanup(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup)

static bool js_cocos2dx_ParallaxNode_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        auto result = cocos2d::ParallaxNode::create();
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_ParallaxNode_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_ParallaxNode_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_ParallaxNode_finalize)

static bool js_cocos2dx_ParallaxNode_constructor(se::State& s)
{
    cocos2d::ParallaxNode* cobj = new (std::nothrow) cocos2d::ParallaxNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_ParallaxNode_constructor, __jsb_cocos2d_ParallaxNode_class, js_cocos2d_ParallaxNode_finalize)

static bool js_cocos2dx_ParallaxNode_ctor(se::State& s)
{
    cocos2d::ParallaxNode* cobj = new (std::nothrow) cocos2d::ParallaxNode();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_ParallaxNode_ctor, __jsb_cocos2d_ParallaxNode_class, js_cocos2d_ParallaxNode_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_ParallaxNode_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::ParallaxNode)", s.nativeThisObject());
    cocos2d::ParallaxNode* cobj = (cocos2d::ParallaxNode*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_ParallaxNode_finalize)

bool js_register_cocos2dx_ParallaxNode(se::Object* obj)
{
    auto cls = se::Class::create("ParallaxNode", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_ParallaxNode_constructor));

    cls->defineFunction("addChild", _SE(js_cocos2dx_ParallaxNode_addChild));
    cls->defineFunction("removeAllChildrenWithCleanup", _SE(js_cocos2dx_ParallaxNode_removeAllChildrenWithCleanup));
    cls->defineFunction("ctor", _SE(js_cocos2dx_ParallaxNode_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_ParallaxNode_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_ParallaxNode_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::ParallaxNode>(cls);

    __jsb_cocos2d_ParallaxNode_proto = cls->getProto();
    __jsb_cocos2d_ParallaxNode_class = cls;

    jsb_set_extend_property("cc", "ParallaxNode");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXObject_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObject_class = nullptr;

static bool js_cocos2dx_TMXObject_getGid(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getGid : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        unsigned int result = cobj->getGid();
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getGid : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getGid)

static bool js_cocos2dx_TMXObject_setObjectName(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_setObjectName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_setObjectName : Error processing arguments");
        cobj->setObjectName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_setObjectName)

static bool js_cocos2dx_TMXObject_getObjectSize(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getObjectSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Size result = cobj->getObjectSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getObjectSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getObjectSize)

static bool js_cocos2dx_TMXObject_getProperty(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getProperty)

static bool js_cocos2dx_TMXObject_getObjectVisible(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getObjectVisible : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->getObjectVisible();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getObjectVisible : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getObjectVisible)

static bool js_cocos2dx_TMXObject_getType(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getType : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = (int)cobj->getType();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getType : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getType)

static bool js_cocos2dx_TMXObject_getId(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getId : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getId();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getId : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getId)

static bool js_cocos2dx_TMXObject_getObjectRotation(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getObjectRotation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        float result = cobj->getObjectRotation();
        ok &= float_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getObjectRotation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getObjectRotation)

static bool js_cocos2dx_TMXObject_getProperties(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getProperties)

static bool js_cocos2dx_TMXObject_getOffset(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vec2 result = cobj->getOffset();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getOffset)

static bool js_cocos2dx_TMXObject_setProperties(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_setProperties)

static bool js_cocos2dx_TMXObject_getObjectName(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getObjectName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getObjectName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getObjectName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getObjectName)

static bool js_cocos2dx_TMXObject_getNode(se::State& s)
{
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObject_getNode : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Node* result = cobj->getNode();
        ok &= native_ptr_to_seval<cocos2d::Node>((cocos2d::Node*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_getNode : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObject_getNode)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObject_finalize)

static bool js_cocos2dx_TMXObject_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::ValueMap arg0;
    cocos2d::TMXMapInfo* arg1 = nullptr;
    cocos2d::Size arg2;
    cocos2d::Color3B arg3;
    ok &= seval_to_ccvaluemap(args[0], &arg0);
    ok &= seval_to_native_ptr(args[1], &arg1);
    ok &= seval_to_Size(args[2], &arg2);
    ok &= seval_to_Color3B(args[3], &arg3);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObject_constructor : Error processing arguments");
    cocos2d::TMXObject* cobj = new (std::nothrow) cocos2d::TMXObject(arg0, arg1, arg2, arg3);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObject_constructor, __jsb_cocos2d_TMXObject_class, js_cocos2d_TMXObject_finalize)




static bool js_cocos2d_TMXObject_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXObject)", s.nativeThisObject());
    cocos2d::TMXObject* cobj = (cocos2d::TMXObject*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObject_finalize)

bool js_register_cocos2dx_TMXObject(se::Object* obj)
{
    auto cls = se::Class::create("TMXObject", obj, nullptr, _SE(js_cocos2dx_TMXObject_constructor));

    cls->defineFunction("getGid", _SE(js_cocos2dx_TMXObject_getGid));
    cls->defineFunction("setObjectName", _SE(js_cocos2dx_TMXObject_setObjectName));
    cls->defineFunction("getObjectSize", _SE(js_cocos2dx_TMXObject_getObjectSize));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXObject_getProperty));
    cls->defineFunction("getObjectVisible", _SE(js_cocos2dx_TMXObject_getObjectVisible));
    cls->defineFunction("getType", _SE(js_cocos2dx_TMXObject_getType));
    cls->defineFunction("getId", _SE(js_cocos2dx_TMXObject_getId));
    cls->defineFunction("getObjectRotation", _SE(js_cocos2dx_TMXObject_getObjectRotation));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXObject_getProperties));
    cls->defineFunction("getOffset", _SE(js_cocos2dx_TMXObject_getOffset));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXObject_setProperties));
    cls->defineFunction("getObjectName", _SE(js_cocos2dx_TMXObject_getObjectName));
    cls->defineFunction("getNode", _SE(js_cocos2dx_TMXObject_getNode));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXObject_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObject>(cls);

    __jsb_cocos2d_TMXObject_proto = cls->getProto();
    __jsb_cocos2d_TMXObject_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXObjectImage_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObjectImage_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObjectImage_finalize)

static bool js_cocos2dx_TMXObjectImage_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::TMXObject* arg0 = nullptr;
    cocos2d::TMXMapInfo* arg1 = nullptr;
    ok &= seval_to_native_ptr(args[0], &arg0);
    ok &= seval_to_native_ptr(args[1], &arg1);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectImage_constructor : Error processing arguments");
    cocos2d::TMXObjectImage* cobj = new (std::nothrow) cocos2d::TMXObjectImage(arg0, arg1);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObjectImage_constructor, __jsb_cocos2d_TMXObjectImage_class, js_cocos2d_TMXObjectImage_finalize)



extern se::Object* __jsb_cocos2d_Sprite_proto;

static bool js_cocos2d_TMXObjectImage_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXObjectImage)", s.nativeThisObject());
    cocos2d::TMXObjectImage* cobj = (cocos2d::TMXObjectImage*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObjectImage_finalize)

bool js_register_cocos2dx_TMXObjectImage(se::Object* obj)
{
    auto cls = se::Class::create("TMXObjectImage", obj, __jsb_cocos2d_Sprite_proto, _SE(js_cocos2dx_TMXObjectImage_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXObjectImage_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObjectImage>(cls);

    __jsb_cocos2d_TMXObjectImage_proto = cls->getProto();
    __jsb_cocos2d_TMXObjectImage_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXObjectShape_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObjectShape_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObjectShape_finalize)

static bool js_cocos2dx_TMXObjectShape_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::TMXObject* arg0 = nullptr;
    cocos2d::TMXMapInfo* arg1 = nullptr;
    cocos2d::Color3B arg2;
    ok &= seval_to_native_ptr(args[0], &arg0);
    ok &= seval_to_native_ptr(args[1], &arg1);
    ok &= seval_to_Color3B(args[2], &arg2);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectShape_constructor : Error processing arguments");
    cocos2d::TMXObjectShape* cobj = new (std::nothrow) cocos2d::TMXObjectShape(arg0, arg1, arg2);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObjectShape_constructor, __jsb_cocos2d_TMXObjectShape_class, js_cocos2d_TMXObjectShape_finalize)



extern se::Object* __jsb_cocos2d_DrawNode_proto;

static bool js_cocos2d_TMXObjectShape_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXObjectShape)", s.nativeThisObject());
    cocos2d::TMXObjectShape* cobj = (cocos2d::TMXObjectShape*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObjectShape_finalize)

bool js_register_cocos2dx_TMXObjectShape(se::Object* obj)
{
    auto cls = se::Class::create("TMXObjectShape", obj, __jsb_cocos2d_DrawNode_proto, _SE(js_cocos2dx_TMXObjectShape_constructor));

    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXObjectShape_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObjectShape>(cls);

    __jsb_cocos2d_TMXObjectShape_proto = cls->getProto();
    __jsb_cocos2d_TMXObjectShape_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXObjectGroup_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObjectGroup_class = nullptr;

static bool js_cocos2dx_TMXObjectGroup_setPositionOffset(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setPositionOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setPositionOffset : Error processing arguments");
        cobj->setPositionOffset(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setPositionOffset)

static bool js_cocos2dx_TMXObjectGroup_getProperty(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getProperty)

static bool js_cocos2dx_TMXObjectGroup_getPositionOffset(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getPositionOffset : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vec2& result = cobj->getPositionOffset();
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getPositionOffset : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getPositionOffset)

static bool js_cocos2dx_TMXObjectGroup_getObject(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getObject : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObject : Error processing arguments");
        cocos2d::TMXObject* result = cobj->getObject(arg0);
        ok &= native_ptr_to_seval<cocos2d::TMXObject>((cocos2d::TMXObject*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObject : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getObject)

static bool js_cocos2dx_TMXObjectGroup_getObjects(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getObjects : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Vector<cocos2d::TMXObject *>& result = cobj->getObjects();
        ok &= Vector_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getObjects : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getObjects)

static bool js_cocos2dx_TMXObjectGroup_setGroupName(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setGroupName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setGroupName : Error processing arguments");
        cobj->setGroupName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setGroupName)

static bool js_cocos2dx_TMXObjectGroup_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXObjectGroup_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getProperties)

static bool js_cocos2dx_TMXObjectGroup_getGroupName(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_getGroupName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getGroupName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_getGroupName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_getGroupName)

static bool js_cocos2dx_TMXObjectGroup_setProperties(se::State& s)
{
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroup_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroup_setProperties)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObjectGroup_finalize)

static bool js_cocos2dx_TMXObjectGroup_constructor(se::State& s)
{
    CC_UNUSED bool ok = true;
    const auto& args = s.args();
    cocos2d::TMXObjectGroupInfo* arg0 = nullptr;
    cocos2d::TMXMapInfo* arg1 = nullptr;
    ok &= seval_to_native_ptr(args[0], &arg0);
    ok &= seval_to_native_ptr(args[1], &arg1);
    SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroup_constructor : Error processing arguments");
    cocos2d::TMXObjectGroup* cobj = new (std::nothrow) cocos2d::TMXObjectGroup(arg0, arg1);
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObjectGroup_constructor, __jsb_cocos2d_TMXObjectGroup_class, js_cocos2d_TMXObjectGroup_finalize)



extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_TMXObjectGroup_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXObjectGroup)", s.nativeThisObject());
    cocos2d::TMXObjectGroup* cobj = (cocos2d::TMXObjectGroup*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObjectGroup_finalize)

bool js_register_cocos2dx_TMXObjectGroup(se::Object* obj)
{
    auto cls = se::Class::create("TMXObjectGroup", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_TMXObjectGroup_constructor));

    cls->defineFunction("setPositionOffset", _SE(js_cocos2dx_TMXObjectGroup_setPositionOffset));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXObjectGroup_getProperty));
    cls->defineFunction("getPositionOffset", _SE(js_cocos2dx_TMXObjectGroup_getPositionOffset));
    cls->defineFunction("getObject", _SE(js_cocos2dx_TMXObjectGroup_getObject));
    cls->defineFunction("getObjects", _SE(js_cocos2dx_TMXObjectGroup_getObjects));
    cls->defineFunction("setGroupName", _SE(js_cocos2dx_TMXObjectGroup_setGroupName));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXObjectGroup_getProperties));
    cls->defineFunction("getGroupName", _SE(js_cocos2dx_TMXObjectGroup_getGroupName));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXObjectGroup_setProperties));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXObjectGroup_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObjectGroup>(cls);

    __jsb_cocos2d_TMXObjectGroup_proto = cls->getProto();
    __jsb_cocos2d_TMXObjectGroup_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXLayerInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXLayerInfo_class = nullptr;

static bool js_cocos2dx_TMXLayerInfo_setProperties(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayerInfo_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayerInfo_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayerInfo_setProperties)

static bool js_cocos2dx_TMXLayerInfo_getProperties(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayerInfo_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayerInfo_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayerInfo_getProperties)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXLayerInfo_finalize)

static bool js_cocos2dx_TMXLayerInfo_constructor(se::State& s)
{
    cocos2d::TMXLayerInfo* cobj = new (std::nothrow) cocos2d::TMXLayerInfo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXLayerInfo_constructor, __jsb_cocos2d_TMXLayerInfo_class, js_cocos2d_TMXLayerInfo_finalize)




static bool js_cocos2d_TMXLayerInfo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXLayerInfo)", s.nativeThisObject());
    cocos2d::TMXLayerInfo* cobj = (cocos2d::TMXLayerInfo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXLayerInfo_finalize)

bool js_register_cocos2dx_TMXLayerInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXLayerInfo", obj, nullptr, _SE(js_cocos2dx_TMXLayerInfo_constructor));

    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXLayerInfo_setProperties));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXLayerInfo_getProperties));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXLayerInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXLayerInfo>(cls);

    __jsb_cocos2d_TMXLayerInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXLayerInfo_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXObjectGroupInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXObjectGroupInfo_class = nullptr;

static bool js_cocos2dx_TMXObjectGroupInfo_setProperties(se::State& s)
{
    cocos2d::TMXObjectGroupInfo* cobj = (cocos2d::TMXObjectGroupInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroupInfo_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroupInfo_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroupInfo_setProperties)

static bool js_cocos2dx_TMXObjectGroupInfo_getProperties(se::State& s)
{
    cocos2d::TMXObjectGroupInfo* cobj = (cocos2d::TMXObjectGroupInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXObjectGroupInfo_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXObjectGroupInfo_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXObjectGroupInfo_getProperties)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXObjectGroupInfo_finalize)

static bool js_cocos2dx_TMXObjectGroupInfo_constructor(se::State& s)
{
    cocos2d::TMXObjectGroupInfo* cobj = new (std::nothrow) cocos2d::TMXObjectGroupInfo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXObjectGroupInfo_constructor, __jsb_cocos2d_TMXObjectGroupInfo_class, js_cocos2d_TMXObjectGroupInfo_finalize)




static bool js_cocos2d_TMXObjectGroupInfo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXObjectGroupInfo)", s.nativeThisObject());
    cocos2d::TMXObjectGroupInfo* cobj = (cocos2d::TMXObjectGroupInfo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXObjectGroupInfo_finalize)

bool js_register_cocos2dx_TMXObjectGroupInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXObjectGroupInfo", obj, nullptr, _SE(js_cocos2dx_TMXObjectGroupInfo_constructor));

    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXObjectGroupInfo_setProperties));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXObjectGroupInfo_getProperties));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXObjectGroupInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXObjectGroupInfo>(cls);

    __jsb_cocos2d_TMXObjectGroupInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXObjectGroupInfo_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXTilesetInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXTilesetInfo_class = nullptr;

static bool js_cocos2dx_TMXTilesetInfo_getRectForGID(se::State& s)
{
    cocos2d::TMXTilesetInfo* cobj = (cocos2d::TMXTilesetInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        unsigned int arg0 = 0;
        ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Error processing arguments");
        cocos2d::Rect result = cobj->getRectForGID(arg0);
        ok &= Rect_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTilesetInfo_getRectForGID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTilesetInfo_getRectForGID)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXTilesetInfo_finalize)

static bool js_cocos2dx_TMXTilesetInfo_constructor(se::State& s)
{
    cocos2d::TMXTilesetInfo* cobj = new (std::nothrow) cocos2d::TMXTilesetInfo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXTilesetInfo_constructor, __jsb_cocos2d_TMXTilesetInfo_class, js_cocos2d_TMXTilesetInfo_finalize)




static bool js_cocos2d_TMXTilesetInfo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXTilesetInfo)", s.nativeThisObject());
    cocos2d::TMXTilesetInfo* cobj = (cocos2d::TMXTilesetInfo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXTilesetInfo_finalize)

bool js_register_cocos2dx_TMXTilesetInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXTilesetInfo", obj, nullptr, _SE(js_cocos2dx_TMXTilesetInfo_constructor));

    cls->defineFunction("getRectForGID", _SE(js_cocos2dx_TMXTilesetInfo_getRectForGID));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXTilesetInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXTilesetInfo>(cls);

    __jsb_cocos2d_TMXTilesetInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXTilesetInfo_class = cls;

    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXMapInfo_proto = nullptr;
se::Class* __jsb_cocos2d_TMXMapInfo_class = nullptr;

static bool js_cocos2dx_TMXMapInfo_getAllChildren(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getAllChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::Ref *>& result = cobj->getAllChildren();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getAllChildren : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::Ref *>& result = cobj->getAllChildren();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getAllChildren : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getAllChildren)

static bool js_cocos2dx_TMXMapInfo_getHexSideLength(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getHexSideLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getHexSideLength();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getHexSideLength : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getHexSideLength)

static bool js_cocos2dx_TMXMapInfo_setTileSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTileSize : Error processing arguments");
        cobj->setTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTileSize)

static bool js_cocos2dx_TMXMapInfo_initWithTMXFile(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Error processing arguments");
        bool result = cobj->initWithTMXFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithTMXFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_initWithTMXFile)

static bool js_cocos2dx_TMXMapInfo_getOrientation(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getOrientation();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getOrientation)

static bool js_cocos2dx_TMXMapInfo_setObjectGroups(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXObjectGroupInfo *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setObjectGroups : Error processing arguments");
        cobj->setObjectGroups(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setObjectGroups)

static bool js_cocos2dx_TMXMapInfo_setLayers(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setLayers : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXLayerInfo *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setLayers : Error processing arguments");
        cobj->setLayers(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setLayers)

static bool js_cocos2dx_TMXMapInfo_parseXMLFile(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Error processing arguments");
        bool result = cobj->parseXMLFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_parseXMLFile)

static bool js_cocos2dx_TMXMapInfo_getParentElement(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getParentElement : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getParentElement();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getParentElement : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getParentElement)

static bool js_cocos2dx_TMXMapInfo_setTMXFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTMXFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTMXFileName : Error processing arguments");
        cobj->setTMXFileName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTMXFileName)

static bool js_cocos2dx_TMXMapInfo_parseXMLString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Error processing arguments");
        bool result = cobj->parseXMLString(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_parseXMLString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_parseXMLString)

static bool js_cocos2dx_TMXMapInfo_getLayers(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getLayers : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXLayerInfo *>& result = cobj->getLayers();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayers : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXLayerInfo *>& result = cobj->getLayers();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayers : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getLayers)

static bool js_cocos2dx_TMXMapInfo_getStaggerAxis(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getStaggerAxis : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStaggerAxis();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getStaggerAxis : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getStaggerAxis)

static bool js_cocos2dx_TMXMapInfo_setHexSideLength(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setHexSideLength : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setHexSideLength : Error processing arguments");
        cobj->setHexSideLength(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setHexSideLength)

static bool js_cocos2dx_TMXMapInfo_getTilesets(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getTilesets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXTilesetInfo *>& result = cobj->getTilesets();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTilesets : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXTilesetInfo *>& result = cobj->getTilesets();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTilesets : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTilesets)

static bool js_cocos2dx_TMXMapInfo_getParentGID(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getParentGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getParentGID();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getParentGID : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getParentGID)

static bool js_cocos2dx_TMXMapInfo_setParentElement(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setParentElement : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setParentElement : Error processing arguments");
        cobj->setParentElement(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setParentElement)

static bool js_cocos2dx_TMXMapInfo_initWithXML(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_initWithXML : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithXML : Error processing arguments");
        bool result = cobj->initWithXML(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_initWithXML : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_initWithXML)

static bool js_cocos2dx_TMXMapInfo_setParentGID(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setParentGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setParentGID : Error processing arguments");
        cobj->setParentGID(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setParentGID)

static bool js_cocos2dx_TMXMapInfo_getLayerAttribs(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getLayerAttribs : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerAttribs();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getLayerAttribs : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getLayerAttribs)

static bool js_cocos2dx_TMXMapInfo_getTileSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getTileSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTileSize)

static bool js_cocos2dx_TMXMapInfo_setAllChildren(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setAllChildren : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::Ref *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setAllChildren : Error processing arguments");
        cobj->setAllChildren(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setAllChildren)

static bool js_cocos2dx_TMXMapInfo_getTileProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTileProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMapIntKey& result = cobj->getTileProperties();
        ok &= ccvaluemapintkey_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTileProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTileProperties)

static bool js_cocos2dx_TMXMapInfo_isStoringCharacters(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_isStoringCharacters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        bool result = cobj->isStoringCharacters();
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_isStoringCharacters : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_isStoringCharacters)

static bool js_cocos2dx_TMXMapInfo_getExternalTilesetFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getExternalTilesetFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getExternalTilesetFileName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getExternalTilesetFileName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getExternalTilesetFileName)

static bool js_cocos2dx_TMXMapInfo_getObjectGroups(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::Vector<cocos2d::TMXObjectGroupInfo *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::Vector<cocos2d::TMXObjectGroupInfo *>& result = cobj->getObjectGroups();
            ok &= Vector_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getObjectGroups : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getObjectGroups)

static bool js_cocos2dx_TMXMapInfo_getTMXFileName(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getTMXFileName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getTMXFileName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getTMXFileName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getTMXFileName)

static bool js_cocos2dx_TMXMapInfo_setStaggerIndex(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStaggerIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStaggerIndex : Error processing arguments");
        cobj->setStaggerIndex(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStaggerIndex)

static bool js_cocos2dx_TMXMapInfo_setCurrentString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setCurrentString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setCurrentString : Error processing arguments");
        cobj->setCurrentString(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setCurrentString)

static bool js_cocos2dx_TMXMapInfo_setProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setProperties)

static bool js_cocos2dx_TMXMapInfo_setOrientation(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setOrientation : Error processing arguments");
        cobj->setOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setOrientation)

static bool js_cocos2dx_TMXMapInfo_setTileProperties(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTileProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMapIntKey arg0;
        ok &= seval_to_ccvaluemapintkey(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTileProperties : Error processing arguments");
        cobj->setTileProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTileProperties)

static bool js_cocos2dx_TMXMapInfo_setMapSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setMapSize : Error processing arguments");
        cobj->setMapSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setMapSize)

static bool js_cocos2dx_TMXMapInfo_getCurrentString(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getCurrentString : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getCurrentString();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getCurrentString : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getCurrentString)

static bool js_cocos2dx_TMXMapInfo_setStoringCharacters(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStoringCharacters : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        bool arg0;
        ok &= seval_to_boolean(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStoringCharacters : Error processing arguments");
        cobj->setStoringCharacters(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStoringCharacters)

static bool js_cocos2dx_TMXMapInfo_setStaggerAxis(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setStaggerAxis : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setStaggerAxis : Error processing arguments");
        cobj->setStaggerAxis(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setStaggerAxis)

static bool js_cocos2dx_TMXMapInfo_getMapSize(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getMapSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getMapSize)

static bool js_cocos2dx_TMXMapInfo_setTilesets(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setTilesets : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vector<cocos2d::TMXTilesetInfo *> arg0;
        ok &= seval_to_Vector(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setTilesets : Error processing arguments");
        cobj->setTilesets(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setTilesets)

static bool js_cocos2dx_TMXMapInfo_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXMapInfo_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getProperties)

static bool js_cocos2dx_TMXMapInfo_getStaggerIndex(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_getStaggerIndex : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getStaggerIndex();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_getStaggerIndex : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_getStaggerIndex)

static bool js_cocos2dx_TMXMapInfo_setLayerAttribs(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXMapInfo_setLayerAttribs : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_setLayerAttribs : Error processing arguments");
        cobj->setLayerAttribs(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_setLayerAttribs)

static bool js_cocos2dx_TMXMapInfo_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_create : Error processing arguments");
        auto result = cocos2d::TMXMapInfo::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXMapInfo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_create)

static bool js_cocos2dx_TMXMapInfo_createWithXML(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXMapInfo_createWithXML : Error processing arguments");
        auto result = cocos2d::TMXMapInfo::createWithXML(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXMapInfo_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXMapInfo_createWithXML)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXMapInfo_finalize)

static bool js_cocos2dx_TMXMapInfo_constructor(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = new (std::nothrow) cocos2d::TMXMapInfo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXMapInfo_constructor, __jsb_cocos2d_TMXMapInfo_class, js_cocos2d_TMXMapInfo_finalize)

static bool js_cocos2dx_TMXMapInfo_ctor(se::State& s)
{
    cocos2d::TMXMapInfo* cobj = new (std::nothrow) cocos2d::TMXMapInfo();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXMapInfo_ctor, __jsb_cocos2d_TMXMapInfo_class, js_cocos2d_TMXMapInfo_finalize)


    


static bool js_cocos2d_TMXMapInfo_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXMapInfo)", s.nativeThisObject());
    cocos2d::TMXMapInfo* cobj = (cocos2d::TMXMapInfo*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXMapInfo_finalize)

bool js_register_cocos2dx_TMXMapInfo(se::Object* obj)
{
    auto cls = se::Class::create("TMXMapInfo", obj, nullptr, _SE(js_cocos2dx_TMXMapInfo_constructor));

    cls->defineFunction("getAllChildren", _SE(js_cocos2dx_TMXMapInfo_getAllChildren));
    cls->defineFunction("getHexSideLength", _SE(js_cocos2dx_TMXMapInfo_getHexSideLength));
    cls->defineFunction("setTileSize", _SE(js_cocos2dx_TMXMapInfo_setTileSize));
    cls->defineFunction("initWithTMXFile", _SE(js_cocos2dx_TMXMapInfo_initWithTMXFile));
    cls->defineFunction("getOrientation", _SE(js_cocos2dx_TMXMapInfo_getOrientation));
    cls->defineFunction("setObjectGroups", _SE(js_cocos2dx_TMXMapInfo_setObjectGroups));
    cls->defineFunction("setLayers", _SE(js_cocos2dx_TMXMapInfo_setLayers));
    cls->defineFunction("parseXMLFile", _SE(js_cocos2dx_TMXMapInfo_parseXMLFile));
    cls->defineFunction("getParentElement", _SE(js_cocos2dx_TMXMapInfo_getParentElement));
    cls->defineFunction("setTMXFileName", _SE(js_cocos2dx_TMXMapInfo_setTMXFileName));
    cls->defineFunction("parseXMLString", _SE(js_cocos2dx_TMXMapInfo_parseXMLString));
    cls->defineFunction("getLayers", _SE(js_cocos2dx_TMXMapInfo_getLayers));
    cls->defineFunction("getStaggerAxis", _SE(js_cocos2dx_TMXMapInfo_getStaggerAxis));
    cls->defineFunction("setHexSideLength", _SE(js_cocos2dx_TMXMapInfo_setHexSideLength));
    cls->defineFunction("getTilesets", _SE(js_cocos2dx_TMXMapInfo_getTilesets));
    cls->defineFunction("getParentGID", _SE(js_cocos2dx_TMXMapInfo_getParentGID));
    cls->defineFunction("setParentElement", _SE(js_cocos2dx_TMXMapInfo_setParentElement));
    cls->defineFunction("initWithXML", _SE(js_cocos2dx_TMXMapInfo_initWithXML));
    cls->defineFunction("setParentGID", _SE(js_cocos2dx_TMXMapInfo_setParentGID));
    cls->defineFunction("getLayerAttribs", _SE(js_cocos2dx_TMXMapInfo_getLayerAttribs));
    cls->defineFunction("getTileSize", _SE(js_cocos2dx_TMXMapInfo_getTileSize));
    cls->defineFunction("setAllChildren", _SE(js_cocos2dx_TMXMapInfo_setAllChildren));
    cls->defineFunction("getTileProperties", _SE(js_cocos2dx_TMXMapInfo_getTileProperties));
    cls->defineFunction("isStoringCharacters", _SE(js_cocos2dx_TMXMapInfo_isStoringCharacters));
    cls->defineFunction("getExternalTilesetFileName", _SE(js_cocos2dx_TMXMapInfo_getExternalTilesetFileName));
    cls->defineFunction("getObjectGroups", _SE(js_cocos2dx_TMXMapInfo_getObjectGroups));
    cls->defineFunction("getTMXFileName", _SE(js_cocos2dx_TMXMapInfo_getTMXFileName));
    cls->defineFunction("setStaggerIndex", _SE(js_cocos2dx_TMXMapInfo_setStaggerIndex));
    cls->defineFunction("setCurrentString", _SE(js_cocos2dx_TMXMapInfo_setCurrentString));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXMapInfo_setProperties));
    cls->defineFunction("setOrientation", _SE(js_cocos2dx_TMXMapInfo_setOrientation));
    cls->defineFunction("setTileProperties", _SE(js_cocos2dx_TMXMapInfo_setTileProperties));
    cls->defineFunction("setMapSize", _SE(js_cocos2dx_TMXMapInfo_setMapSize));
    cls->defineFunction("getCurrentString", _SE(js_cocos2dx_TMXMapInfo_getCurrentString));
    cls->defineFunction("setStoringCharacters", _SE(js_cocos2dx_TMXMapInfo_setStoringCharacters));
    cls->defineFunction("setStaggerAxis", _SE(js_cocos2dx_TMXMapInfo_setStaggerAxis));
    cls->defineFunction("getMapSize", _SE(js_cocos2dx_TMXMapInfo_getMapSize));
    cls->defineFunction("setTilesets", _SE(js_cocos2dx_TMXMapInfo_setTilesets));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXMapInfo_getProperties));
    cls->defineFunction("getStaggerIndex", _SE(js_cocos2dx_TMXMapInfo_getStaggerIndex));
    cls->defineFunction("setLayerAttribs", _SE(js_cocos2dx_TMXMapInfo_setLayerAttribs));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXMapInfo_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXMapInfo_create));
    cls->defineStaticFunction("createWithXML", _SE(js_cocos2dx_TMXMapInfo_createWithXML));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXMapInfo_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXMapInfo>(cls);

    __jsb_cocos2d_TMXMapInfo_proto = cls->getProto();
    __jsb_cocos2d_TMXMapInfo_class = cls;

    jsb_set_extend_property("cc", "TMXMapInfo");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXLayer_proto = nullptr;
se::Class* __jsb_cocos2d_TMXLayer_class = nullptr;

static bool js_cocos2dx_TMXLayer_getTileGIDAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        unsigned int result = cobj->getTileGIDAt(arg0);
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        return true;
    }
    if (argc == 2) {
        cocos2d::Vec2 arg0;
        cocos2d::TMXTileFlags_* arg1 = nullptr;
        ok &= seval_to_Vec2(args[0], &arg0);
        uint32_t tempData;arg1=(cocos2d::TMXTileFlags_*)&tempData;ok &= seval_to_uint32(args[1], (uint32_t *)&arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        unsigned int result = cobj->getTileGIDAt(arg0, arg1);
        ok &= uint32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileGIDAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileGIDAt)

static bool js_cocos2dx_TMXLayer_getPositionAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getPositionAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getPositionAt : Error processing arguments");
        cocos2d::Vec2 result = cobj->getPositionAt(arg0);
        ok &= Vec2_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getPositionAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getPositionAt)

static bool js_cocos2dx_TMXLayer_setLayerOrientation(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerOrientation : Error processing arguments");
        cobj->setLayerOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerOrientation)

static bool js_cocos2dx_TMXLayer_setTileOpacity(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setTileOpacity : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        uint8_t arg0;
        ok &= seval_to_uint8(args[0], (uint8_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setTileOpacity : Error processing arguments");
        cobj->setTileOpacity(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTileOpacity)

static bool js_cocos2dx_TMXLayer_releaseMap(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_releaseMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseMap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_releaseMap)

static bool js_cocos2dx_TMXLayer_getLayerSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getLayerSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerSize)

static bool js_cocos2dx_TMXLayer_setMapTileSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setMapTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setMapTileSize : Error processing arguments");
        cobj->setMapTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setMapTileSize)

static bool js_cocos2dx_TMXLayer_getLayerOrientation(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerOrientation();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerOrientation)

static bool js_cocos2dx_TMXLayer_setProperties(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setProperties)

static bool js_cocos2dx_TMXLayer_setLayerName(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerName : Error processing arguments");
        cobj->setLayerName(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerName)

static bool js_cocos2dx_TMXLayer_removeTileAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_removeTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_removeTileAt : Error processing arguments");
        cobj->removeTileAt(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_removeTileAt)

static bool js_cocos2dx_TMXLayer_initWithTilesetInfo(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        cocos2d::TMXLayerInfo* arg1 = nullptr;
        cocos2d::TMXMapInfo* arg2 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Error processing arguments");
        bool result = cobj->initWithTilesetInfo(arg0, arg1, arg2);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_initWithTilesetInfo : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_initWithTilesetInfo)

static bool js_cocos2dx_TMXLayer_setupTiles(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setupTiles : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->setupTiles();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setupTiles)

static bool js_cocos2dx_TMXLayer_setTileGID(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXLayer_setTileGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 3) {
            unsigned int arg0 = 0;
            ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cocos2d::TMXTileFlags_ arg2;
            ok &= seval_to_uint32(args[2], (uint32_t *)&arg2);
            if (!ok) { ok = true; break; }
            cobj->setTileGID(arg0, arg1, arg2);
            return true;
        }
    } while(false);

    do {
        if (argc == 2) {
            unsigned int arg0 = 0;
            ok &= seval_to_uint32(args[0], (uint32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Vec2 arg1;
            ok &= seval_to_Vec2(args[1], &arg1);
            if (!ok) { ok = true; break; }
            cobj->setTileGID(arg0, arg1);
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTileGID)

static bool js_cocos2dx_TMXLayer_getMapTileSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getMapTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapTileSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getMapTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getMapTileSize)

static bool js_cocos2dx_TMXLayer_getProperty(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getProperty)

static bool js_cocos2dx_TMXLayer_setLayerSize(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setLayerSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setLayerSize : Error processing arguments");
        cobj->setLayerSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setLayerSize)

static bool js_cocos2dx_TMXLayer_getLayerName(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getLayerName : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getLayerName();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getLayerName : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getLayerName)

static bool js_cocos2dx_TMXLayer_setTileSet(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_setTileSet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_setTileSet : Error processing arguments");
        cobj->setTileSet(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_setTileSet)

static bool js_cocos2dx_TMXLayer_getTileSet(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileSet : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::TMXTilesetInfo* result = cobj->getTileSet();
        ok &= native_ptr_to_seval<cocos2d::TMXTilesetInfo>((cocos2d::TMXTilesetInfo*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileSet : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileSet)

static bool js_cocos2dx_TMXLayer_getProperties(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXLayer_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 0) {
            cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 0) {
            const cocos2d::ValueMap& result = cobj->getProperties();
            ok &= ccvaluemap_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getProperties : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getProperties)

static bool js_cocos2dx_TMXLayer_getTileAt(se::State& s)
{
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXLayer_getTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileAt : Error processing arguments");
        cocos2d::Sprite* result = cobj->getTileAt(arg0);
        ok &= native_ptr_to_seval<cocos2d::Sprite>((cocos2d::Sprite*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_getTileAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_getTileAt)

static bool js_cocos2dx_TMXLayer_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 3) {
        cocos2d::TMXTilesetInfo* arg0 = nullptr;
        cocos2d::TMXLayerInfo* arg1 = nullptr;
        cocos2d::TMXMapInfo* arg2 = nullptr;
        ok &= seval_to_native_ptr(args[0], &arg0);
        ok &= seval_to_native_ptr(args[1], &arg1);
        ok &= seval_to_native_ptr(args[2], &arg2);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXLayer_create : Error processing arguments");
        auto result = cocos2d::TMXLayer::create(arg0, arg1, arg2);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXLayer_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 3);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXLayer_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXLayer_finalize)

static bool js_cocos2dx_TMXLayer_constructor(se::State& s)
{
    cocos2d::TMXLayer* cobj = new (std::nothrow) cocos2d::TMXLayer();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXLayer_constructor, __jsb_cocos2d_TMXLayer_class, js_cocos2d_TMXLayer_finalize)

static bool js_cocos2dx_TMXLayer_ctor(se::State& s)
{
    cocos2d::TMXLayer* cobj = new (std::nothrow) cocos2d::TMXLayer();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXLayer_ctor, __jsb_cocos2d_TMXLayer_class, js_cocos2d_TMXLayer_finalize)


    

extern se::Object* __jsb_cocos2d_SpriteBatchNode_proto;

static bool js_cocos2d_TMXLayer_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXLayer)", s.nativeThisObject());
    cocos2d::TMXLayer* cobj = (cocos2d::TMXLayer*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXLayer_finalize)

bool js_register_cocos2dx_TMXLayer(se::Object* obj)
{
    auto cls = se::Class::create("TMXLayer", obj, __jsb_cocos2d_SpriteBatchNode_proto, _SE(js_cocos2dx_TMXLayer_constructor));

    cls->defineFunction("getTileGIDAt", _SE(js_cocos2dx_TMXLayer_getTileGIDAt));
    cls->defineFunction("getPositionAt", _SE(js_cocos2dx_TMXLayer_getPositionAt));
    cls->defineFunction("setLayerOrientation", _SE(js_cocos2dx_TMXLayer_setLayerOrientation));
    cls->defineFunction("setTileOpacity", _SE(js_cocos2dx_TMXLayer_setTileOpacity));
    cls->defineFunction("releaseMap", _SE(js_cocos2dx_TMXLayer_releaseMap));
    cls->defineFunction("getLayerSize", _SE(js_cocos2dx_TMXLayer_getLayerSize));
    cls->defineFunction("setMapTileSize", _SE(js_cocos2dx_TMXLayer_setMapTileSize));
    cls->defineFunction("getLayerOrientation", _SE(js_cocos2dx_TMXLayer_getLayerOrientation));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXLayer_setProperties));
    cls->defineFunction("setLayerName", _SE(js_cocos2dx_TMXLayer_setLayerName));
    cls->defineFunction("removeTileAt", _SE(js_cocos2dx_TMXLayer_removeTileAt));
    cls->defineFunction("initWithTilesetInfo", _SE(js_cocos2dx_TMXLayer_initWithTilesetInfo));
    cls->defineFunction("setupTiles", _SE(js_cocos2dx_TMXLayer_setupTiles));
    cls->defineFunction("setTileGID", _SE(js_cocos2dx_TMXLayer_setTileGID));
    cls->defineFunction("getMapTileSize", _SE(js_cocos2dx_TMXLayer_getMapTileSize));
    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXLayer_getProperty));
    cls->defineFunction("setLayerSize", _SE(js_cocos2dx_TMXLayer_setLayerSize));
    cls->defineFunction("getLayerName", _SE(js_cocos2dx_TMXLayer_getLayerName));
    cls->defineFunction("setTileSet", _SE(js_cocos2dx_TMXLayer_setTileSet));
    cls->defineFunction("getTileSet", _SE(js_cocos2dx_TMXLayer_getTileSet));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXLayer_getProperties));
    cls->defineFunction("getTileAt", _SE(js_cocos2dx_TMXLayer_getTileAt));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXLayer_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXLayer_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXLayer_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXLayer>(cls);

    __jsb_cocos2d_TMXLayer_proto = cls->getProto();
    __jsb_cocos2d_TMXLayer_class = cls;

    jsb_set_extend_property("cc", "TMXLayer");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TMXTiledMap_proto = nullptr;
se::Class* __jsb_cocos2d_TMXTiledMap_class = nullptr;

static bool js_cocos2dx_TMXTiledMap_getProperty(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getProperty : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperty : Error processing arguments");
        cocos2d::Value result = cobj->getProperty(arg0);
        ok &= ccvalue_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperty : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getProperty)

static bool js_cocos2dx_TMXTiledMap_getLayerNum(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getLayerNum : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getLayerNum();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayerNum : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getLayerNum)

static bool js_cocos2dx_TMXTiledMap_setMapSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setMapSize : Error processing arguments");
        cobj->setMapSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setMapSize)

static bool js_cocos2dx_TMXTiledMap_getObjectGroup(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Error processing arguments");
        cocos2d::TMXObjectGroup* result = cobj->getObjectGroup(arg0);
        ok &= native_ptr_to_seval<cocos2d::TMXObjectGroup>((cocos2d::TMXObjectGroup*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroup : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getObjectGroup)

static bool js_cocos2dx_TMXTiledMap_getObjectGroups(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getObjectGroups : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::Vector<cocos2d::TMXObjectGroup *> result = cobj->getObjectGroups();
        ok &= Vector_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getObjectGroups : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getObjectGroups)

static bool js_cocos2dx_TMXTiledMap_getResourceFile(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getResourceFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const std::string& result = cobj->getResourceFile();
        ok &= std_string_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getResourceFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getResourceFile)

static bool js_cocos2dx_TMXTiledMap_initWithTMXFile(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Error processing arguments");
        bool result = cobj->initWithTMXFile(arg0);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithTMXFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_initWithTMXFile)

static bool js_cocos2dx_TMXTiledMap_getTileSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getTileSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getTileSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getTileSize)

static bool js_cocos2dx_TMXTiledMap_getMapSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getMapSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        const cocos2d::Size& result = cobj->getMapSize();
        ok &= Size_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getMapSize : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getMapSize)

static bool js_cocos2dx_TMXTiledMap_initWithXML(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_initWithXML : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithXML : Error processing arguments");
        bool result = cobj->initWithXML(arg0, arg1);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_initWithXML : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_initWithXML)

static bool js_cocos2dx_TMXTiledMap_getProperties(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        cocos2d::ValueMap& result = cobj->getProperties();
        ok &= ccvaluemap_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getProperties : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getProperties)

static bool js_cocos2dx_TMXTiledMap_getPropertiesForGID(se::State& s)
{
    CC_UNUSED bool ok = true;
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2( cobj, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    do {
        if (argc == 2) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Value** arg1 = nullptr;
            ok &= seval_to_native_ptr(args[1], &arg1);
            if (!ok) { ok = true; break; }
            bool result = cobj->getPropertiesForGID(arg0, arg1);
            ok &= boolean_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Error processing arguments");
            return true;
        }
    } while(false);

    do {
        if (argc == 1) {
            int arg0 = 0;
            ok &= seval_to_int32(args[0], (int32_t*)&arg0);
            if (!ok) { ok = true; break; }
            cocos2d::Value result = cobj->getPropertiesForGID(arg0);
            ok &= ccvalue_to_seval(result, &s.rval());
            SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getPropertiesForGID : Error processing arguments");
            return true;
        }
    } while(false);

    SE_REPORT_ERROR("wrong number of arguments: %d", (int)argc);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getPropertiesForGID)

static bool js_cocos2dx_TMXTiledMap_setTileSize(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setTileSize : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Size arg0;
        ok &= seval_to_Size(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setTileSize : Error processing arguments");
        cobj->setTileSize(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setTileSize)

static bool js_cocos2dx_TMXTiledMap_setProperties(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setProperties : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::ValueMap arg0;
        ok &= seval_to_ccvaluemap(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setProperties : Error processing arguments");
        cobj->setProperties(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setProperties)

static bool js_cocos2dx_TMXTiledMap_getLayer(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getLayer : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayer : Error processing arguments");
        cocos2d::TMXLayer* result = cobj->getLayer(arg0);
        ok &= native_ptr_to_seval<cocos2d::TMXLayer>((cocos2d::TMXLayer*)result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getLayer : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getLayer)

static bool js_cocos2dx_TMXTiledMap_getMapOrientation(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_getMapOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 0) {
        int result = cobj->getMapOrientation();
        ok &= int32_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_getMapOrientation : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_getMapOrientation)

static bool js_cocos2dx_TMXTiledMap_setMapOrientation(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TMXTiledMap_setMapOrientation : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        int arg0 = 0;
        ok &= seval_to_int32(args[0], (int32_t*)&arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_setMapOrientation : Error processing arguments");
        cobj->setMapOrientation(arg0);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_setMapOrientation)

static bool js_cocos2dx_TMXTiledMap_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        std::string arg0;
        ok &= seval_to_std_string(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_create : Error processing arguments");
        auto result = cocos2d::TMXTiledMap::create(arg0);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXTiledMap_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_create)

static bool js_cocos2dx_TMXTiledMap_createWithXML(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        std::string arg0;
        std::string arg1;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TMXTiledMap_createWithXML : Error processing arguments");
        auto result = cocos2d::TMXTiledMap::createWithXML(arg0, arg1);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TMXTiledMap_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TMXTiledMap_createWithXML)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TMXTiledMap_finalize)

static bool js_cocos2dx_TMXTiledMap_constructor(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = new (std::nothrow) cocos2d::TMXTiledMap();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TMXTiledMap_constructor, __jsb_cocos2d_TMXTiledMap_class, js_cocos2d_TMXTiledMap_finalize)

static bool js_cocos2dx_TMXTiledMap_ctor(se::State& s)
{
    cocos2d::TMXTiledMap* cobj = new (std::nothrow) cocos2d::TMXTiledMap();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TMXTiledMap_ctor, __jsb_cocos2d_TMXTiledMap_class, js_cocos2d_TMXTiledMap_finalize)


    

extern se::Object* __jsb_cocos2d_Node_proto;

static bool js_cocos2d_TMXTiledMap_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TMXTiledMap)", s.nativeThisObject());
    cocos2d::TMXTiledMap* cobj = (cocos2d::TMXTiledMap*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TMXTiledMap_finalize)

bool js_register_cocos2dx_TMXTiledMap(se::Object* obj)
{
    auto cls = se::Class::create("TMXTiledMap", obj, __jsb_cocos2d_Node_proto, _SE(js_cocos2dx_TMXTiledMap_constructor));

    cls->defineFunction("getProperty", _SE(js_cocos2dx_TMXTiledMap_getProperty));
    cls->defineFunction("getLayerNum", _SE(js_cocos2dx_TMXTiledMap_getLayerNum));
    cls->defineFunction("setMapSize", _SE(js_cocos2dx_TMXTiledMap_setMapSize));
    cls->defineFunction("getObjectGroup", _SE(js_cocos2dx_TMXTiledMap_getObjectGroup));
    cls->defineFunction("getObjectGroups", _SE(js_cocos2dx_TMXTiledMap_getObjectGroups));
    cls->defineFunction("getResourceFile", _SE(js_cocos2dx_TMXTiledMap_getResourceFile));
    cls->defineFunction("initWithTMXFile", _SE(js_cocos2dx_TMXTiledMap_initWithTMXFile));
    cls->defineFunction("getTileSize", _SE(js_cocos2dx_TMXTiledMap_getTileSize));
    cls->defineFunction("getMapSize", _SE(js_cocos2dx_TMXTiledMap_getMapSize));
    cls->defineFunction("initWithXML", _SE(js_cocos2dx_TMXTiledMap_initWithXML));
    cls->defineFunction("getProperties", _SE(js_cocos2dx_TMXTiledMap_getProperties));
    cls->defineFunction("getPropertiesForGID", _SE(js_cocos2dx_TMXTiledMap_getPropertiesForGID));
    cls->defineFunction("setTileSize", _SE(js_cocos2dx_TMXTiledMap_setTileSize));
    cls->defineFunction("setProperties", _SE(js_cocos2dx_TMXTiledMap_setProperties));
    cls->defineFunction("getLayer", _SE(js_cocos2dx_TMXTiledMap_getLayer));
    cls->defineFunction("getMapOrientation", _SE(js_cocos2dx_TMXTiledMap_getMapOrientation));
    cls->defineFunction("setMapOrientation", _SE(js_cocos2dx_TMXTiledMap_setMapOrientation));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TMXTiledMap_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TMXTiledMap_create));
    cls->defineStaticFunction("createWithXML", _SE(js_cocos2dx_TMXTiledMap_createWithXML));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TMXTiledMap_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TMXTiledMap>(cls);

    __jsb_cocos2d_TMXTiledMap_proto = cls->getProto();
    __jsb_cocos2d_TMXTiledMap_class = cls;

    jsb_set_extend_property("cc", "TMXTiledMap");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_TileMapAtlas_proto = nullptr;
se::Class* __jsb_cocos2d_TileMapAtlas_class = nullptr;

static bool js_cocos2dx_TileMapAtlas_initWithTileFile(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Error processing arguments");
        bool result = cobj->initWithTileFile(arg0, arg1, arg2, arg3);
        ok &= boolean_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_initWithTileFile : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_initWithTileFile)

static bool js_cocos2dx_TileMapAtlas_releaseMap(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_releaseMap : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    if (argc == 0) {
        cobj->releaseMap();
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 0);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_releaseMap)

static bool js_cocos2dx_TileMapAtlas_getTileAt(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_getTileAt : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 1) {
        cocos2d::Vec2 arg0;
        ok &= seval_to_Vec2(args[0], &arg0);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_getTileAt : Error processing arguments");
        cocos2d::Color3B result = cobj->getTileAt(arg0);
        ok &= Color3B_to_seval(result, &s.rval());
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_getTileAt : Error processing arguments");
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 1);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_getTileAt)

static bool js_cocos2dx_TileMapAtlas_setTile(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    SE_PRECONDITION2(cobj, false, "js_cocos2dx_TileMapAtlas_setTile : Invalid Native Object");
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 2) {
        cocos2d::Color3B arg0;
        cocos2d::Vec2 arg1;
        ok &= seval_to_Color3B(args[0], &arg0);
        ok &= seval_to_Vec2(args[1], &arg1);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_setTile : Error processing arguments");
        cobj->setTile(arg0, arg1);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 2);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_setTile)

static bool js_cocos2dx_TileMapAtlas_create(se::State& s)
{
    const auto& args = s.args();
    size_t argc = args.size();
    CC_UNUSED bool ok = true;
    if (argc == 4) {
        std::string arg0;
        std::string arg1;
        int arg2 = 0;
        int arg3 = 0;
        ok &= seval_to_std_string(args[0], &arg0);
        ok &= seval_to_std_string(args[1], &arg1);
        ok &= seval_to_int32(args[2], (int32_t*)&arg2);
        ok &= seval_to_int32(args[3], (int32_t*)&arg3);
        SE_PRECONDITION2(ok, false, "js_cocos2dx_TileMapAtlas_create : Error processing arguments");
        auto result = cocos2d::TileMapAtlas::create(arg0, arg1, arg2, arg3);
        result->retain();
        auto obj = se::Object::createObjectWithClass(__jsb_cocos2d_TileMapAtlas_class);
        obj->setPrivateData(result);
        s.rval().setObject(obj);
        return true;
    }
    SE_REPORT_ERROR("wrong number of arguments: %d, was expecting %d", (int)argc, 4);
    return false;
}
SE_BIND_FUNC(js_cocos2dx_TileMapAtlas_create)

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_TileMapAtlas_finalize)

static bool js_cocos2dx_TileMapAtlas_constructor(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = new (std::nothrow) cocos2d::TileMapAtlas();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_TileMapAtlas_constructor, __jsb_cocos2d_TileMapAtlas_class, js_cocos2d_TileMapAtlas_finalize)

static bool js_cocos2dx_TileMapAtlas_ctor(se::State& s)
{
    cocos2d::TileMapAtlas* cobj = new (std::nothrow) cocos2d::TileMapAtlas();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_TileMapAtlas_ctor, __jsb_cocos2d_TileMapAtlas_class, js_cocos2d_TileMapAtlas_finalize)


    

extern se::Object* __jsb_cocos2d_AtlasNode_proto;

static bool js_cocos2d_TileMapAtlas_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::TileMapAtlas)", s.nativeThisObject());
    cocos2d::TileMapAtlas* cobj = (cocos2d::TileMapAtlas*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_TileMapAtlas_finalize)

bool js_register_cocos2dx_TileMapAtlas(se::Object* obj)
{
    auto cls = se::Class::create("TileMapAtlas", obj, __jsb_cocos2d_AtlasNode_proto, _SE(js_cocos2dx_TileMapAtlas_constructor));

    cls->defineFunction("initWithTileFile", _SE(js_cocos2dx_TileMapAtlas_initWithTileFile));
    cls->defineFunction("releaseMap", _SE(js_cocos2dx_TileMapAtlas_releaseMap));
    cls->defineFunction("getTileAt", _SE(js_cocos2dx_TileMapAtlas_getTileAt));
    cls->defineFunction("setTile", _SE(js_cocos2dx_TileMapAtlas_setTile));
    cls->defineFunction("ctor", _SE(js_cocos2dx_TileMapAtlas_ctor));
    cls->defineStaticFunction("create", _SE(js_cocos2dx_TileMapAtlas_create));
    cls->defineFinalizeFunction(_SE(js_cocos2d_TileMapAtlas_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::TileMapAtlas>(cls);

    __jsb_cocos2d_TileMapAtlas_proto = cls->getProto();
    __jsb_cocos2d_TileMapAtlas_class = cls;

    jsb_set_extend_property("cc", "TileMapAtlas");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

se::Object* __jsb_cocos2d_BaseJSAction_proto = nullptr;
se::Class* __jsb_cocos2d_BaseJSAction_class = nullptr;

SE_DECLARE_FINALIZE_FUNC(js_cocos2d_BaseJSAction_finalize)

static bool js_cocos2dx_BaseJSAction_constructor(se::State& s)
{
    cocos2d::BaseJSAction* cobj = new (std::nothrow) cocos2d::BaseJSAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_CTOR(js_cocos2dx_BaseJSAction_constructor, __jsb_cocos2d_BaseJSAction_class, js_cocos2d_BaseJSAction_finalize)

static bool js_cocos2dx_BaseJSAction_ctor(se::State& s)
{
    cocos2d::BaseJSAction* cobj = new (std::nothrow) cocos2d::BaseJSAction();
    s.thisObject()->setPrivateData(cobj);
    return true;
}
SE_BIND_SUB_CLS_CTOR(js_cocos2dx_BaseJSAction_ctor, __jsb_cocos2d_BaseJSAction_class, js_cocos2d_BaseJSAction_finalize)


    

extern se::Object* __jsb_cocos2d_Action_proto;

static bool js_cocos2d_BaseJSAction_finalize(se::State& s)
{
    CCLOGINFO("jsbindings: finalizing JS object %p (cocos2d::BaseJSAction)", s.nativeThisObject());
    cocos2d::BaseJSAction* cobj = (cocos2d::BaseJSAction*)s.nativeThisObject();
    if (cobj->getReferenceCount() == 1)
        cobj->autorelease();
    else
        cobj->release();
    return true;
}
SE_BIND_FINALIZE_FUNC(js_cocos2d_BaseJSAction_finalize)

bool js_register_cocos2dx_BaseJSAction(se::Object* obj)
{
    auto cls = se::Class::create("BaseJSAction", obj, __jsb_cocos2d_Action_proto, _SE(js_cocos2dx_BaseJSAction_constructor));

    cls->defineFunction("ctor", _SE(js_cocos2dx_BaseJSAction_ctor));
    cls->defineFinalizeFunction(_SE(js_cocos2d_BaseJSAction_finalize));
    cls->install();
    JSBClassType::registerClass<cocos2d::BaseJSAction>(cls);

    __jsb_cocos2d_BaseJSAction_proto = cls->getProto();
    __jsb_cocos2d_BaseJSAction_class = cls;

    jsb_set_extend_property("cc", "BaseJSAction");
    se::ScriptEngine::getInstance()->clearException();
    return true;
}

bool register_all_cocos2dx(se::Object* obj)
{
    // Get the ns
    se::Value nsVal;
    if (!obj->getProperty("cc", &nsVal))
    {
        se::HandleObject jsobj(se::Object::createPlainObject());
        nsVal.setObject(jsobj);
        obj->setProperty("cc", nsVal);
    }
    se::Object* ns = nsVal.toObject();

    js_register_cocos2dx_Acceleration(ns);
    js_register_cocos2dx_Action(ns);
    js_register_cocos2dx_FiniteTimeAction(ns);
    js_register_cocos2dx_ActionInstant(ns);
    js_register_cocos2dx_Hide(ns);
    js_register_cocos2dx_TMXObjectGroupInfo(ns);
    js_register_cocos2dx_Node(ns);
    js_register_cocos2dx_ParticleSystem(ns);
    js_register_cocos2dx_ParticleSystemQuad(ns);
    js_register_cocos2dx_ParticleSpiral(ns);
    js_register_cocos2dx_ActionInterval(ns);
    js_register_cocos2dx_MoveBy(ns);
    js_register_cocos2dx_MoveTo(ns);
    js_register_cocos2dx_JumpBy(ns);
    js_register_cocos2dx_EventListener(ns);
    js_register_cocos2dx_EventListenerKeyboard(ns);
    js_register_cocos2dx_EventListenerMouse(ns);
    js_register_cocos2dx_ComponentContainer(ns);
    js_register_cocos2dx_Director(ns);
    js_register_cocos2dx_Scheduler(ns);
    js_register_cocos2dx_ActionEase(ns);
    js_register_cocos2dx_EaseElastic(ns);
    js_register_cocos2dx_EaseElasticOut(ns);
    js_register_cocos2dx_EaseQuadraticActionInOut(ns);
    js_register_cocos2dx_EaseBackOut(ns);
    js_register_cocos2dx_Texture2D(ns);
    js_register_cocos2dx_SkewTo(ns);
    js_register_cocos2dx_SkewBy(ns);
    js_register_cocos2dx_EaseQuadraticActionOut(ns);
    js_register_cocos2dx_Layer(ns);
    js_register_cocos2dx_TMXTilesetInfo(ns);
    js_register_cocos2dx_TMXTiledMap(ns);
    js_register_cocos2dx_FadeTo(ns);
    js_register_cocos2dx_FadeIn(ns);
    js_register_cocos2dx_EventListenerCustom(ns);
    js_register_cocos2dx_EaseSineInOut(ns);
    js_register_cocos2dx_EaseElasticInOut(ns);
    js_register_cocos2dx_EaseBounce(ns);
    js_register_cocos2dx_Show(ns);
    js_register_cocos2dx_FadeOut(ns);
    js_register_cocos2dx_CallFunc(ns);
    js_register_cocos2dx_Event(ns);
    js_register_cocos2dx_EventMouse(ns);
    js_register_cocos2dx_GLView(ns);
    js_register_cocos2dx_EaseBezierAction(ns);
    js_register_cocos2dx_ParticleFireworks(ns);
    js_register_cocos2dx_MenuItem(ns);
    js_register_cocos2dx_MenuItemSprite(ns);
    js_register_cocos2dx_MenuItemImage(ns);
    js_register_cocos2dx_ParticleFire(ns);
    js_register_cocos2dx_ParticleSmoke(ns);
    js_register_cocos2dx_EaseRateAction(ns);
    js_register_cocos2dx_EaseIn(ns);
    js_register_cocos2dx_EaseExponentialInOut(ns);
    js_register_cocos2dx_CardinalSplineTo(ns);
    js_register_cocos2dx_CatmullRomTo(ns);
    js_register_cocos2dx_EaseExponentialOut(ns);
    js_register_cocos2dx_Label(ns);
    js_register_cocos2dx_Application(ns);
    js_register_cocos2dx_DelayTime(ns);
    js_register_cocos2dx_AsyncTaskPool(ns);
    js_register_cocos2dx_ParticleSnow(ns);
    js_register_cocos2dx_DrawNode(ns);
    js_register_cocos2dx_TMXObjectShape(ns);
    js_register_cocos2dx_EaseElasticIn(ns);
    js_register_cocos2dx_EaseCircleActionInOut(ns);
    js_register_cocos2dx_TMXObject(ns);
    js_register_cocos2dx_EventAcceleration(ns);
    js_register_cocos2dx_EaseCubicActionIn(ns);
    js_register_cocos2dx_SpriteBatchNode(ns);
    js_register_cocos2dx_Configuration(ns);
    js_register_cocos2dx_ParticleSun(ns);
    js_register_cocos2dx_TMXLayer(ns);
    js_register_cocos2dx_FlipX(ns);
    js_register_cocos2dx_FlipY(ns);
    js_register_cocos2dx_RepeatForever(ns);
    js_register_cocos2dx_Place(ns);
    js_register_cocos2dx_EventListenerAcceleration(ns);
    js_register_cocos2dx_GLProgram(ns);
    js_register_cocos2dx_EaseBounceOut(ns);
    js_register_cocos2dx_RenderTexture(ns);
    js_register_cocos2dx_SpriteFrameCache(ns);
    js_register_cocos2dx_ClippingNode(ns);
    js_register_cocos2dx_ParticleFlower(ns);
    js_register_cocos2dx_EaseCircleActionIn(ns);
    js_register_cocos2dx_Image(ns);
    js_register_cocos2dx_Blink(ns);
    js_register_cocos2dx_JumpTo(ns);
    js_register_cocos2dx_AtlasNode(ns);
    js_register_cocos2dx_Touch(ns);
    js_register_cocos2dx_SAXParser(ns);
    js_register_cocos2dx_CardinalSplineBy(ns);
    js_register_cocos2dx_CatmullRomBy(ns);
    js_register_cocos2dx_TMXLayerInfo(ns);
    js_register_cocos2dx_EaseSineIn(ns);
    js_register_cocos2dx_EaseBounceIn(ns);
    js_register_cocos2dx_TMXObjectGroup(ns);
    js_register_cocos2dx_ParticleGalaxy(ns);
    js_register_cocos2dx_MenuItemLabel(ns);
    js_register_cocos2dx_EaseQuinticActionIn(ns);
    js_register_cocos2dx_LayerColor(ns);
    js_register_cocos2dx_LayerGradient(ns);
    js_register_cocos2dx_EventListenerTouchAllAtOnce(ns);
    js_register_cocos2dx_ToggleVisibility(ns);
    js_register_cocos2dx_Repeat(ns);
    js_register_cocos2dx_LayerMultiplex(ns);
    js_register_cocos2dx_TintTo(ns);
    js_register_cocos2dx_EaseBackInOut(ns);
    js_register_cocos2dx_TargetedAction(ns);
    js_register_cocos2dx_RotateTo(ns);
    js_register_cocos2dx_Device(ns);
    js_register_cocos2dx_EventListenerFocus(ns);
    js_register_cocos2dx_BezierBy(ns);
    js_register_cocos2dx_BezierTo(ns);
    js_register_cocos2dx_ParticleMeteor(ns);
    js_register_cocos2dx_SpriteFrame(ns);
    js_register_cocos2dx_ActionManager(ns);
    js_register_cocos2dx_ParticleBatchNode(ns);
    js_register_cocos2dx_EventFocus(ns);
    js_register_cocos2dx_EaseQuinticActionInOut(ns);
    js_register_cocos2dx_TileMapAtlas(ns);
    js_register_cocos2dx_ScaleTo(ns);
    js_register_cocos2dx_Spawn(ns);
    js_register_cocos2dx_EaseQuarticActionInOut(ns);
    js_register_cocos2dx_GLProgramState(ns);
    js_register_cocos2dx_EaseCircleActionOut(ns);
    js_register_cocos2dx_EaseCubicActionInOut(ns);
    js_register_cocos2dx_EaseQuarticActionOut(ns);
    js_register_cocos2dx_EaseBackIn(ns);
    js_register_cocos2dx_ParticleExplosion(ns);
    js_register_cocos2dx_TintBy(ns);
    js_register_cocos2dx_ReverseTime(ns);
    js_register_cocos2dx_EaseQuarticActionIn(ns);
    js_register_cocos2dx_Menu(ns);
    js_register_cocos2dx_EaseInOut(ns);
    js_register_cocos2dx_ScaleBy(ns);
    js_register_cocos2dx_EventTouch(ns);
    js_register_cocos2dx_TMXMapInfo(ns);
    js_register_cocos2dx_EaseExponentialIn(ns);
    js_register_cocos2dx_EaseQuinticActionOut(ns);
    js_register_cocos2dx_EventDispatcher(ns);
    js_register_cocos2dx_MenuItemAtlasFont(ns);
    js_register_cocos2dx_Sprite(ns);
    js_register_cocos2dx_ParallaxNode(ns);
    js_register_cocos2dx_EventCustom(ns);
    js_register_cocos2dx_Component(ns);
    js_register_cocos2dx_EaseCubicActionOut(ns);
    js_register_cocos2dx_EventListenerTouchOneByOne(ns);
    js_register_cocos2dx_TextFieldTTF(ns);
    js_register_cocos2dx_ParticleRain(ns);
    js_register_cocos2dx_EaseOut(ns);
    js_register_cocos2dx_MenuItemFont(ns);
    js_register_cocos2dx_EaseSineOut(ns);
    js_register_cocos2dx_TextureCache(ns);
    js_register_cocos2dx_MenuItemToggle(ns);
    js_register_cocos2dx_RemoveSelf(ns);
    js_register_cocos2dx_LabelTTF(ns);
    js_register_cocos2dx_ProtectedNode(ns);
    js_register_cocos2dx_MotionStreak(ns);
    js_register_cocos2dx_RotateBy(ns);
    js_register_cocos2dx_FileUtils(ns);
    js_register_cocos2dx_CallFuncN(ns);
    js_register_cocos2dx_BaseJSAction(ns);
    js_register_cocos2dx_Sequence(ns);
    js_register_cocos2dx_EaseBounceInOut(ns);
    js_register_cocos2dx_Scene(ns);
    js_register_cocos2dx_GLProgramCache(ns);
    js_register_cocos2dx_EaseQuadraticActionIn(ns);
    js_register_cocos2dx_Speed(ns);
    js_register_cocos2dx_TMXObjectImage(ns);
    return true;
}

